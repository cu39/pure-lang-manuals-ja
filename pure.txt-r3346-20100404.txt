===============
The Pure Manual
===============

:著者: Albert Graf <Dr.Graef at t-online.de>
:訳者: cu39 <cu393uc at gmail.com>
:日付: |date|

.. Note: This document is formatted using docutils. The Makefile has rules
.. to build the documentation in html and pdf format. The latter needs TeX
.. and relies on the preamble.tex file to adjust the formatting. You might
.. have to edit preamble.tex to make this work with your local TeX
.. installation.

.. role:: dfn(strong)
.. default-role:: dfn

.. |date| date::
.. |time| date:: %H:%M

.. |GPL| replace:: GNU General Public License
.. |LGPL| replace:: GNU Lesser General Public License
.. |FDL| replace:: GNU Free Documentation License

.. _FDL: http://www.gnu.org/copyleft/fdl.html
.. _GPL: http://www.gnu.org/copyleft/gpl.html
.. _LGPL: http://www.gnu.org/copyleft/lgpl.html

.. _Pure Library Manual: purelib.html

.. Teach TeX how to hyphenate 'namespace'.

.. raw:: latex

   \hyphenation{name-space}
   \hyphenation{name-spaces}

Copyright (c) 2009-2010 by Albert Graf. This document is available under the
|FDL|_. Also see the Copying_ section for licensing information of the
software.

This manual describes the Pure programming language and how to invoke the Pure
interpreter program. To read the manual inside the interpreter, just type
``help`` at the command prompt. See the `Online Help`_ section for details.

このマニュアルは Pure プログラミング言語と Pure インタープリタプログラムを動かす方法を説明します。インタープリタを使っている最中にこのテキストを読むには、ただ ``help`` とタイプして下さい。詳しくは `Online Help`_ セクションを参照。

There is a companion to this manual, the `Pure Library Manual`_ which contains
the description of the standard library operations. More information about
Pure can be found under the following URLs:

このマニュアルには `Pure Library Manual`_ という仲間もいて、標準ライブラリの働きを解説しています。以下のURLではさらに Pure に関する情報を見つけることができます:

* Pure website: http://pure-lang.googlecode.com
* Pure mailing list: http://groups.google.com/group/pure-lang

翻訳版に関する注意

この文書は pure.txt (r3346, Apr. 4, 2010) を日本語へ翻訳したものです。

原文は |FDL|_ ライセンスの下で公開されており、それに基づいてこの翻訳版も FDL の下で公開されています。

「〔」 [#]_ と「〕」 [#]_ に囲まれた語句は原典の表現を注記したものです。

.. [#] U+3014 始め亀甲括弧／LEFT TORTOISE SHELL BRACKET
.. [#] U+3015 終わり亀甲括弧／RIGHT TORTOISE SHELL BRACKET

.. contents::
.. sectnum::

Introduction
============

イントロダクション

Pure is a modern-style functional programming language based on term
rewriting. Pure programs are basically collections of equational rules used to
evaluate expressions in a symbolic fashion by reducing them to normal form. An
overview of the language can be found in the `Pure Overview`_ section below,
and subsequent sections discuss most language features in detail.

Pure は項書き替えを基礎とする現代的な関数型プログラミング言語です。Pure プログラムは基本的に等式ルールの集合です。この等式は、式を記号的な方法で正規形へ還元して評価するのに使われます。言語の全体像は下にある `Pure Overview`_ セクションとそれに続くセクションにあり、言語機能のほとんどについて詳細に議論しています。

The Pure interpreter has an LLVM_ backend which JIT-compiles Pure programs to
machine code, hence programs run blazingly fast and interfacing to C modules
is easy, while the interpreter still provides a convenient, fully interactive
environment for running Pure scripts and evaluating expressions. You can also
compile your scripts to standalone executables if you prefer that.

Pure インタープリタは LLVM_ バックエンドを持っています。 LLVM は Pure プログラムをマシン語に JIT コンパイルします。なのでプログラムは激しく高速で、Cモジュールへ簡単に接続することができます。その一方でインタープリタは、 Pure で書かれたスクリプトや式を、完全にインタラクティブな使いやすい環境で走らせることができます。またお好みなら、スクリプトをスタンドアロンの実行ファイルにコンパイルすることもできます。

Pure programs (a.k.a. scripts) are just ordinary text files containing Pure
code. They must be encoded in UTF-8 (which subsumes 7 bit ASCII), other
encodings such as Latin-1 are not supported. A bunch of syntax highlighting
files and programming modes for various popular text editors are included in
the Pure sources. There's no difference between the Pure programming language
and the input language accepted by the interpreter, except that the
interpreter also understands some special commands when running in interactive
mode; see the `Interactive Usage`_ section for details.

Pure プログラム（またはスクリプト）は Pure コードを含む単なる普通のテキストファイルです。そのファイルは UTF-8 （7ビット ASCII をその一部に含む）でエンコードされなければならず、 Latin-1 のような他のエンコーディングはサポートされません。Pureのソースには、有名なテキストエディタ用のシンタックスハイライト用ファイルやプログラミングモードがたくさん含まれています。Pure言語とインタープリタが許容する入力言語の間にほとんど違いはありませんが、インタラクティブモードで実行されているインタープリタはさらに特別なコマンドを理解します。詳しくは `Interactive Usage`_ を参照して下さい。

(In case you're wondering, the name "Pure" actually refers to the
adjective. But you can also write it as "PURE" and take this as a recursive
acronym for the "Pure Universal Rewriting Engine".)

（In case you're wondering, "Pure"という名前は実際には形容詞を表しています。しかしまた "PURE" と書いてもいいし、それを "Pure Universal Rewriting Engine" という再帰的頭字語と理解してもかまいません）

Invoking the Pure Interpreter
=============================

Pure インタープリタを起動する

The Pure interpreter is invoked as follows:

Pureインタープリタは以下のように起動されます::

  pure [options ...] [script ...] [-- args ...]
  pure [options ...] -x script [args ...]

Options
-------

The interpreter accepts various options which are described in more detail
below:

インタープリタは様々なオプションを許容します。詳細は以下の通り：

``-c``
    Batch compilation.
    バッチコンパイル。

``--ctags``, ``--etags``
    Create a tags file in ctags (vi) or etags (emacs) format.
    ctags (vi) か etags (emacs) フォーマットのタグファイルを生成する。

``--eager-jit``
    Enable eager JIT compilation. This requires LLVM 2.7 or later, otherwise
    this flag will be ignored.
    eager JIT コンパイルを有効にする。この機能はLLVM 2.7以上を必要とする。
    存在しない場合このフラグは無視される。

``-fPIC``, ``-fpic``
    Create position-independent code (batch compilation).

``-g``
    Enable symbolic debugging.
    シンボリックデバッグを有効にする。

``--help``, ``-h``
    Print help message and exit.
    ヘルプメッセージを表示して終了する。

``-i``
    Force interactive mode (read commands from stdin).
    対話モード（標準入力からコマンドを読む）を強制する。

``-I directory``
    Add a directory to be searched for included source scripts.
    インクルードするソーススクリプトを検索するディレクトリを追加する。

``-L directory``
    Add a directory to be searched for dynamic libraries.
    動的ライブラリを検索するディレクトリを追加する。

``-l libname``
    Library to be linked in batch compilation.
    バッチコンパイル時にリンクするライブラリを指定する。

``--noediting``
    Disable command-line editing.
    コマンドライン編集を無効にする。

``--noprelude``, ``-n``
    Do not load the prelude.
    preludeをロードしない。

``--norc``
    Do not run the interactive startup files.

``-o filename``
    Output filename for batch compilation.
    バッチコンパイル時の出力ファイル名を指定する。

``-q``
    Quiet startup (suppresses sign-on message in interactive mode).
    静かなスタートアップ（対話モードのサインオンメッセージを表示しない）。

``-T filename``
    Tags file to be written by ``--ctags`` or ``--etags``.
    ``--ctags`` や ``--etags`` で出力されるタグファイル名を指定する。

``-u``
    Do not strip unused functions in batch compilation.
    バッチコンパイル時に使われていない関数が削除されるのを抑制する。

``-v[level]``
    Set verbosity level. See below for details.
    メッセージ表示レベル〔verbosity level〕を設定する。詳細は下部を参照。

``--version``
    Print version information and exit.
    バージョン情報を出力して終了。

``-w``
    Enable compiler warnings about various dubious constructs and backward
    compatibility issues.
    様々な構造の曖昧さや後方互換性に関するコンパイラの警告メッセージを有効にする。

``-x``
    Execute script with given command line arguments.
    コマンドライン引数で渡されたスクリプトを実行する。

``--``
    Stop option processing and pass the remaining command line arguments in
    the ``argv`` variable.
    オプションの処理を止め、残りのコマンドライン引数を ``argv`` 変数に渡す。

(Besides these, the interpreter also understands a number of other command
line switches for setting various code generation options; please see `Code
Generation Options`_ below for details.)

（これらに加えて、インタープリタはコード生成オプションを設定する他のコマンドラインスイッチもたくさん理解します。詳しくは下部 `Code Generation Options`_ を参照して下さい。

Overview of Operation
---------------------

動作の全体像

If any source scripts are specified on the command line, they are loaded and
executed, after which the interpreter exits. Otherwise the interpreter enters
the interactive read-eval-print loop, see `Running Interactively`_ below. You
can also use the -i option to enter the interactive loop (continue reading
from stdin) even after processing some source scripts.

コマンドラインでいかなるソーススクリプトが指定された場合でも、それは読み込まれて実行され、その後インタープリタは終了します。そうでない場合、インタープリタは read-eval-print ループの対話モードに入ります。下部 `Running Interactively`_ を参照して下さい。また -i オプションを使って、ソーススクリプトを処理した後でさえも続く対話ループ（標準入力から読み込みを続ける）に入ることもできます

Options and source files are processed in the order in which they are given on
the command line. Processing of options and source files ends when either the
-- or the -x option is encountered. The -x option must be followed by the name
of a script to be executed, which becomes the "main script" of the
application. In either case, any remaining parameters are passed to the
executing script by means of the global ``argc`` and ``argv`` variables,
denoting the number of arguments and the list of the actual parameter strings,
respectively. In the case of -x this also includes the script name as
``argv!0``. The -x option is useful, in particular, to turn Pure scripts into
executable programs by including a "shebang" like the following as the first
line in your main script. (This trick only works with Unix shells, though.)

オプションとソースファイルはコマンドラインで与えられた順番通りに処理されます。オプションやソースファイルスクリプトの処理は -- か -x オプションのいずれかが現れたところで終了します。 -x オプションの後には実行すべきスクリプトが続いている必要があり、そのファイルはアプリケーションの「メインスクリプト」となります。いずれの場合でも、後に続くあらゆるパラメータは ``argc`` と ``argv`` 変数（それぞれ引数の数と、実際のパラメータ文字列を渡す）を通じて、実行されるスクリプトへ渡されます。 -x オプションの場合 ``argv!0`` として実行ファイル名を含みます。この -x オプションは、以下のように "shebang" をメインスクリプトの最初の行に置いてPureスクリプトを実行可能なプログラムにするとき特に便利です。

::

  #!/usr/local/bin/pure -x

On startup, the interpreter also defines the ``version`` variable, which is
set to the version string of the Pure interpreter, and the ``sysinfo``
variable, which provides a string identifying the host system. These are
useful if parts of your script depend on the particular version of the
interpreter and the system it runs on. (Moreover, Pure 0.21 and later also
define the variable ``compiling`` which indicates whether the program is
executed in a batch compilation, see `Compiling Scripts`_ below.)

インタープリタは起動時に ``version`` 変数（Pure インタープリタのバージョン文字列がセットされる）と ``sysinfo`` 変数（ホストシステムを同定する文字列を提供）も定義します。これらの変数は、あなたのスクリプトのある一部が、インタープリタの特定のバージョンや、そのインタープリタが動作するシステムに依存している場合に役立つものです。（さらに Pure 0.21 以上は ``compiling`` 変数も定義します。この変数はバッチコンパイルで実行されるかどうかを示します。詳しくは下部 `Compiling Scripts`_ を参照）

If available, the prelude script prelude.pure is loaded by the interpreter
prior to any other definitions, unless the -n or --noprelude option is
specified. The prelude is searched for in the directory specified with the
PURELIB environment variable. If the PURELIB variable is not set, a
system-specific default is used. Relative pathnames of other source scripts
specified on the command line are interpreted relative to the current working
directory. In addition, the executed program may load other scripts and
libraries via a ``using`` declaration in the source, which are searched for in
a number of locations, including the directories named with the -I and -L
options; see the Declarations_ and `C Interface`_ sections for details.

もし prelude スクリプト（prelude.pure）が利用できる場合、インタープリタは他のあらゆる定義に先行してこれをロードします（ -n や --noprelude が設定されない限り）。 prelude は PURELIB 環境変数で設定されたディレクトリから検索されます。もし PURELIB 変数が設定されていなければ、システム固有のデフォルトが使用されます。他のソーススクリプトの相対パス名がコマンドラインで指定されていれば、カレントワーキングディレクトリからの相対パスとして解釈されます。それに加え、実行されるプログラムが他のスクリプトやライブラリを ``using`` 宣言を通じてロードすることも可能です。このスクリプトやライブラリは -I と -L オプションで指定されるディレクトリを含め、たくさんの場所からロードされます。詳しくは Declarations_ と `C Interface`_ セクションを参照して下さい。

Compiling Scripts
-----------------

スクリプトのコンパイル

The interpreter compiles scripts, as well as definitions that you enter
interactively, automatically. This is done in an incremental fashion, as the
code is needed, and is therefore known as JIT (`just in time`) compilation.
Thus the interpreter never really "interprets" the source program or some
intermediate representation, it just acts as a frontend to the compiler,
taking care of compiling source code to native machine code before it gets
executed.

インタープリタはスクリプトだけでなく、あなたが対話的に入力する定義をも自動的にコンパイルします。このコンパイルはコードが必要となるにつれてインクリメント式に行われます。つまり JIT （`just in time`）として知られているものです。このように、インタープリタはソースプログラムや他の何らかの中間的な表現〔some intermediate representation〕を「解釈する」〔"interprets"〕ことはなく、単にコンパイラのフロントエンドとして振る舞い、ソースコードが実行される前にネイティブコードへとコンパイルする世話をしてくれます。

Pure's LLVM backend does "lazy JIT compilation" by default, meaning that each
function (global or local) is compiled no sooner than it is run for the first
time. With the --eager-jit option, however, it will also compile all other
(global or local) functions that may be called by the compiled function. (The
PURE_EAGER_JIT environment variable, when set to any value, has the same
effect, so that you do not have to specify the --eager--jit option each time
you run the interpreter.) Eager JIT compilation may be more efficient in some
cases (since bigger chunks of compilation work can be done in one go) and less
efficient in others (e.g., eager JITing may compile large chunks of code which
aren't actually called later, except in rare circumstances).

Pure の LLVM バックエンドはデフォルトでは「遅延 JIT コンパイル」を行います。「遅延JITコンパイル」〔"lazy JIT compilation"〕とは、（グローバルまたはローカルな）関数のそれぞれが、最初に実行される段階ではじめてコンパイルされることを意味します。しかし --eager-jit オプションを指定すれば、コンパイルされた関数から呼び出されるかもしれない他のすべての（ローカルまたはグローバルな）関数をもコンパイルします（PURE_EAGER_JIT 環境変数は、どんな値がセットされていても --eager-jit オプションと同じ効果を発揮するので、インタープリタを走らせるたびに毎回 --eager-jit オプションを指定する必要はなくなります）。先行 JIT コンパイル〔eager JIT compilation〕は、ある種のケースでは（比較的大きなコンパイル作業が一度に行われるので）より効果的でしょうし、別のケースでは効果的でなくなるでしょう（例えば、先行 JIT コンパイルが大きなコードの塊をコンパイルしても、実用上、それは稀な状況でしか呼ばれないものであるかもしれません）。

Note that the eager JIT mode is only available with LLVM 2.7 or later;
otherwise this option will be ignored.

先行 JIT コンパイルモードは LLVM 2.7 以降でのみ利用可能であることを忘れないで下さい。 2.6 以前だとこのオプションは無視されます。

It is also possible to compile your scripts to native code beforehand, using
the -c batch compilation option. This options forces the interpreter to
non-interactive mode (unless -i is specified as well, which overrides -c). Any
scripts specified on the command line are then executed as usual, but after
execution the interpreter takes a snapshot of the program and compiles it to
one of several supported output formats, LLVM assembler (.ll) or bitcode
(.bc), native assembler (.s) or object (.o), or a native executable, depending
on the output filename specified with -o. If the output filename ends in the
.ll extension, an LLVM assembler file is created which can then be processed
with the LLVM toolchain. If the output filename is just '-', the assembler
file is written to standard output, which is useful if you want to pass the
generated code to the LLVM tools in a pipeline. If the output filename ends in
the .bc extension, an LLVM bitcode file is created instead.

また -c バッチコンパイルオプションを使えば、あなたのスクリプトをあらかじめネイティブコードにコンパイルすることができます。このオプションはインタープリタに非対話モードを強制します（ -i オプションを使った場合は別で、-c がオーバーライドされます）。コマンドラインで定義されたあらゆるオプションは通常通り実行されますが、実行後、インタープリタはプログラムのスナップショットを撮り、それを、サポートされている出力形式のいずれかへとコンパイルします。サポートされるのは LLVM アセンブラ（.ll）、ビットコード（.bc）、ネイティブアセンブラ（.s）、オブジェクト（.o）、ネイティブな実行ファイルで、 -o オプションで指定されたファイル名次第です。もし出力ファイル名が .ll 拡張子で終わっていたら LLVM アセンブラ用のファイルが作成され、そのファイルはLLVMのツールチェーンで処理できるものとなります。もし出力ファイルが単に '-' であれば、アセンブラファイルが標準出力に書かれます。これはパイプを通じて LLVM ツールにコードを渡したいときに便利です。もし出力ファイル名が .bc で終わっていたら、 LLVM のビットコードファイルが作られます。

The .ll and .bc formats are supported natively by the Pure interpreter, no
external tools are required to generate these. If the target is an .s, .o or
executable file, the Pure interpreter creates a temporary bitcode file on
which it invokes the LLVM tools opt and llc to create a native assembler file,
and then uses gcc to assemble and link the resulting program (if requested).
You can also specify additional libraries to be linked into the executable
with the -l option. If the output filename is omitted, it defaults to
``a.out`` (``a.exe`` on Windows).

Pure インタープリタは .ll と .bc 形式をネイティブにサポートしており、外部ツールに頼らずそれらを出力できます。もしターゲットが .s や .o や実行可能ファイルであった場合、 Pure インタープリタは一時的なビットコードファイルを作成し、それに対して LLVM ツールの opt と llc を実行してネイティブなアセンブラファイルを作成します。その後（必要があれば） gcc を使って最終的なプログラムをコンパイル＆リンクします。 -l オプションを使って、実行ファイルにリンクすべき追加ライブラリを定義することも可能です。もし出力ファイル名を省略した場合、出力ファイル名は ``a.out`` （Windows では ``.exe`` ）となります。

The -c option provides a convenient way to quickly turn a Pure script into a
standalone executable which can be invoked directly from the shell. One
advantage of compiling your script is that this eliminates the JIT compilation
time and thus considerably reduces the startup time of the program. Another
reason to prefer a standalone executable is that it lets you deploy the
program on systems without a full Pure installation (usually only the runtime
library is required on the target system). On the other hand, compiled scripts
also have some limitations, mostly concerning the use of the built-in ``eval``
function. Please see the `Batch Compilation`_ section for details.

-c オプションは Pure スクリプトをスタンドアローンな実行ファイルへと素早く変える便利な方法です。この実行ファイルはシェルから直接実行できます。スクリプトをコンパイルすることの利点のひとつは、 JIT コンパイルにかかる時間を排除し、プログラムの起動時間をかなり短縮できることにあります。スタンドアローンな実行ファイルを好むべきもう一つの理由は、 Pure をフルインストールしなくてもプログラムをシステム上に配置できる点です（しばしば対象システムに合わせたラインタイムライブラリは必要になります）。その一方で、コンパイルされたスクリプトにはいくつかの制限があります。最も重大なのは、組み込み ``eval`` 関数に関する制限です。詳しくは `Batch Compilation`_ セクションを参照して下さい。

The -v64 (or -v0100) verbosity option can be used to have the interpreter
print the commands it executes during compilation, see `Verbosity and
Debugging Options`_ below. When creating an object file, this also prints the
suggested linker command (including all the dynamic modules loaded by the
script, which also have to be linked in to create a working executable), to
which you only have to add the options describing the desired output file.

-64 （あるいは -v0100）饒舌〔verbosity〕オプションを指定すると、インタープリタがコンパイル中に実行されるコマンドを出力させることができます。下部 `Verbosity and Debugging Options`_ を参照して下さい。オブジェクトファイルを作成している最中は、示唆されたリンカコマンドを出力します（スクリプトによって動的にロードされるモジュールのすべても含まれます。それらは実行ファイルを作成するためにリンクされる必要があるものです）が、そのためにあなたがしなければならないのは、求めている出力ファイルを説明するオプションを付加することだけです。

Tagging Scripts
---------------

スクリプトへのタグ付け

Pure programs often have declarations and definitions of global symbols
scattered out over many different source files. The --ctags and --etags
options let you create a tags_ file which allows you to quickly locate these
items in text editors such as vi and emacs which support this feature.

Pure で書かれたプログラムは様々なグローバルシンボルの宣言や定義を持ちますが、それらはしばしば別のソースファイルへ数多くちりばめられます。 --ctags と --etags オプションを使うと tags_ ファイルを作成できますが、これを使うと、そうしたアイテムをテキストエディター（vi や emacs など、この機能をサポートするもの）内で素早く配置することができます。

.. _tags: http://en.wikipedia.org/wiki/Ctags

If --ctags or --etags is specified, the interpreter enters a special mode in
which it only parses source files without executing them and collects
information about the locations of global symbol declarations and definitions.
The collected information is then written to a tags file in the ctags or etags
format used by vi and emacs, respectively. The desired name of the tags file
can be specified with the -T option; it defaults to ``tags`` for --ctags and
``TAGS`` for --etags (which matches the default tags file names used by vi and
emacs, respectively).

もし --ctags か --etags が定義されている場合、インタープリタは特別モードになり、ソースファイルを実行せず、解析だけを行ってグローバルシンボルの宣言と定義を収集します。その後、集められた情報は tags ファイル内に ctags か etags フォーマット（vi と emacs で使われるフォーマット）でそれぞれ書き込まれます。 -T オプションを使って tags ファイルにお望みの名前をつけることもできます。デフォルトの名前は、 --ctags は ``tags`` 、 --etags では ``TAGS`` となります（それぞれ vi と emacs がデフォルトとして検索する tags ファイル名）。

The tags file contains information about the global constant, variable, macro,
function and operator symbols of all scripts specified on the command line, as
well as the prelude and other scripts included via a ``using`` clause. Tagged
scripts which are located in the same directory as the tags file (or,
recursively, in one of its subdirectories) are specified using relative
pathnames, while scripts outside this hierarchy (such as included scripts from
the standard library) are denoted with absolute pathnames. This scheme makes
it possible to move an entire directory together with its tags file and have
the tags information still work in the new location.

tags ファイルには、コマンドラインで指定されたスクリプトファイル、 prelude 、 ``using`` 節で宣言された他のインクルードスクリプト内にある、グローバルな定数、変数、マクロ、関数、演算子シンボルの情報が含まれています。 tags ファイルと同じディレクトリ（または、再帰的に、サブディレクトリ）にあるタグ付けされたスクリプトは、相対パスで定義されます。それに対して、この階層構造の外にあるスクリプト（例えば標準ライブラリからインクルードされたスクリプト）は絶対パスで示されます。この方式により、 tags ファイルも含めてディレクトリ全体を他の場所に移動しても、 tags ファイルの情報は同じように機能します。

Running Interactively
---------------------

If the interpreter runs in interactive mode, it repeatedly prompts you for
input (which may be any legal Pure code or some special interpreter commands
provided for interactive usage), and prints computed results. This is also
known as the `read-eval-print` loop and is described in much more detail in
the `Interactive Usage`_ section. To exit the interpreter, just type the
``quit`` command or the end-of-file character (``^D`` on Unix) at the
beginning of the command line.

インタープリタが対話モードで実行されている場合、インタープリタは繰り返しあなたに入力を促し（入力は Pure のコードでも、対話モード専用のコマンドでもかまいません）、計算結果を表示します。これは `read-eval-print` ループとしても知られ、 `Interactive Usage`_ セクションでより詳細に説明されます。インタープリタを終了するには、ただ ``quit`` コマンドを打ち込むか、コマンドラインの先頭で end-of-file 文字（Unix では ``^D`` ）を入力します。

The interpreter may also source a few additional interactive startup files
immediately before entering the interactive loop, unless the --norc option is
specified. First .purerc in the user's home directory is read, then .purerc in
the current working directory. These are ordinary Pure scripts which can be
used to provide additional definitions for interactive usage. Finally, a .pure
file in the current directory (containing a dump from a previous interactive
session) is loaded if it is present.

インタープリタは他にも対話モード用の追加的な初期ファイルをたどります。これは対話ループに入る直前に行われますが、 --norc オプションが設定された場合は実行されません。まず最初にユーザのホームディレクトリにある .purerc ファイルが読み込まれ、次にカレントワーキングディレクトリにある .purerc が読み込まれます。通常これらのファイルは Pure スクリプトで、対話モード用の追加定義を行うために使われます。最後に、カレントディレクトリの .pure ファイル（直前の対話モードセッションのダンプを含む）が（もしあれば）読み込まれます。

When the interpreter is in interactive mode and reads from a tty, unless the
--noediting option is specified, commands are usually read using readline(3)
or some compatible replacement, providing completion for all commands listed
under `Interactive Usage`_, as well as for symbols defined in the running
program. When exiting the interpreter, the command history is stored in
~/.pure_history, from where it is restored the next time you run the
interpreter.

インタープリタが対話モードかつ tty から読まれている場合、 --noediting オプションが指定されていなければ、コマンドは普通 readline(3) かその互換代替を使って読み込まれます。 `Interactive Usage`_ 以下にリストされている全コマンドと、実行中のプログラムで定義されているシンボルの補完機能を使うことができます。インタープリタを終了するとき、コマンド履歴が ~/.pure_history ファイルに保存され、次回インタープリタが起動したときにこのファイルから履歴を復旧します。

As of Pure 0.22, the interpreter also provides a simple source level debugger
when run in interactive mode, see Debugging_ for details. To enable the
interactive debugger, you need to specify the -g option when invoking the
interpreter. This option causes your script to run *much* slower and also
disables tail call optimization, so you should only use this option if you
want to run the debugger.

Pure 0.22 以降では、インタープリタの対話モードはシンプルなソースレベルデバッガも提供しています。詳しくは Debugging_ セクションを参照して下さい。対話デバッガを有効にするには、インタープリタ起動時に -g オプションを指定する必要があります。このオプションはあなたのスクリプトの実行を *かなり* 遅くし、また末尾呼び出しの最適化を無効にします。そのためこのオプションはデバッガを使いたいときだけ指定する方がよいでしょう。

Verbosity and Debugging Options
-------------------------------

饒舌さとデバッグオプション

The -v option is useful for debugging the interpreter, or if you are
interested in the code your program gets compiled to. The level argument is
optional; it defaults to 1. Seven different levels are implemented at this
time (one more bit is reserved for future extensions). For most purposes, only
the first two levels will be useful for the average Pure programmer; the
remaining levels are most likely to be used by the Pure interpreter
developers.

-v オプションはインタープリタでデバッグを行う際や、あなたのプログラムがコンパイルされた結果のコードに興味がある場合に役立ちます。レベル引数を指定してもしなくてもかまいません。デフォルトは 1 です。今のところ 7 段階のレベルが実装されています（もう 1 ビットが将来の拡張用に予約されています）。平均的な Pure プログラマーのたいがいの用途では、最初の 2 レベルで充分役に立つでしょう。残りのレベルは Pure インタープリタ開発者が使うようなものです。

1 (0x1, 001)
    denotes echoing of parsed definitions and expressions.
    定義と式の解析結果をエコーすることを示します。

2 (0x2, 002)
    adds special annotations concerning local bindings (de Bruijn indices,
    subterm paths; this can be helpful to debug tricky variable binding
    issues).
    ローカル束縛に関する特別な注釈を付加します（de Bruijn インデックス、下位項パス〔subterm paths〕）。これはトリッキーな変数束縛をデバッグする際に役立ちうるものです。

4 (0x4, 004)
    adds descriptions of the matching automata for the left-hand sides of
    equations (you probably want to see this only when working on the guts of
    the interpreter).
    等式左辺への自動マッチングの説明を付加します（これを見たいと思うのは、インタープリタの内蔵部について作業しているときだけでしょう）。

8 (0x8, 010)
    dumps the "real" output code (LLVM assembler, which is as close to the
    native machine code for your program as it gets; you definitely don't want
    to see this unless you have to inspect the generated code for bugs or
    performance issues).
    「本当の」出力コードをダンプします（LLVM アセンブラのことです。このコードはあなたのプログラムがネイティブな機械語になったものとほぼ同じです。この出力を見たいと思うのは、バグやパフォーマンスの問題のため生成コードを精査する必要がある場合くらいでしょう）。

16 (0x10, 020)
    adds debugging messages from the bison(1) parser; useful for debugging the
    parser.
    bison(1) からのデバッグメッセージを付加します。構文解析器（パーサー）をデバッグするのに役立ちます。

32 (0x20, 040)
    adds debugging messages from the flex(1) lexer; useful for debugging the
    lexer.
    flex レキサーからのデバッグメッセージを付加します。字句解析器（レキサー）をデバッグするのに役立ちます。

64 (0x40, 0100)
    turns on verbose batch compilation; this is useful if you want to see
    exactly which commands get executed during batch compilation (-c).
    饒舌なバッチコンパイルを有効にします。バッチコンパイル（-c）中にどのコマンドが実行されているのか正確に見たいときに役立ちます。

These values can be or'ed together, and, for convenience, can be specified in
either decimal, hexadecimal or octal. Thus 0xff or 0777 always gives you full
debugging output (which isn't likely to be used by anyone but the Pure
developers). Some useful flag combinations for experts are (in octal) 007
(echo definitions along with de Bruijn indices and matching automata), 011
(definitions and assembler code) and 021 (parser debugging output along with
parsed definitions).

これらの値をまとめて or 接続することができます。また、便利なことに、10進数、16進数、8進数のいずれでも指定することができます。したがって 0xff や 0777 を指定すると常に完全なデバッグ出力を得ることができます（使うのは Pure 開発者くらいでしょうが）。エキスパートにとって役立ちそうなフラグの組み合わせは、（8進数で） 007 （定義、de Bruijn インデックス、自動マッチングをエコー）、 011 （定義とアセンブラコード）、 021 （パーサーのデバッグ出力、解析された定義）です。

Note that the -v option is only applied after the prelude has been loaded. If
you want to debug the prelude, use the -n option and specify the prelude.pure
file explicitly on the command line. Verbose output is also suppressed for
modules imported through a ``using`` clause. As a remedy, you can use the
interactive ``show`` command (see the `Interactive Usage`_ section) to list
definitions along with additional debugging information.

-v オプションが適用されるのは prelude を読み込んだ後からであることを忘れないで下さい。もし prelude をデバッグしたい場合、コマンドラインから -n オプションで prelude.pure ファイルを明示指定して下さい。 ``using`` 節を通じてインポートされるモジュールに対しても饒舌な出力は抑制されます。そこでも饒舌に出力させたいなら、対話モードの ``show`` コマンド（ `Interactive Usage`_ 節を参照）を使い、定義とともに追加のデバッグ情報をリストすることができます。

Code Generation Options
-----------------------

コード生成オプション

Besides the options listed above, the interpreter also understands some
additional command line switches and corresponding environment variables to
control various code generation options. The options take the form ``--opt``
and ``--noopt``, respectively, where ``opt`` denotes the option name (see
below for a list of supported options). By default, these options are all
enabled; ``--noopt`` disables the option, ``--opt`` reenables it. In addition,
for each option ``opt`` there is also a corresponding environment variable
``PURE_NOOPT`` (with the option name in uppercase) which, when set, disables
the option by default. (Setting this variable to any value will do, the
interpreter only checks whether the variable exists in the environment.)

上でリストされたオプションに加えて、インタープリタは、追加的なコマンドラインスイッチとそれに対応する環境変数をもう少し理解します。これらは様々なコード生成オプションを制御するためのもので、それぞれ ``--opt`` と ``--noopt`` という形式をとります。このとき ``opt`` 部分はオプション名を示しています（サポートされるオプションは下にあるリストを参照して下さい）。デフォルトでは、これらのオプションの全てが有効です。 ``--noopt`` はオプションを無効にし、 ``--opt`` はそれを再び有効にします。加えて、各オプション ``opt`` には、それぞれ対応する環境変数 ``PURE_NOOPT`` （OPT 部分に大文字のオプション名を指定する）があります。これが設定されている場合、そのオプションはデフォルトで無効となります（変数にいかなる値が設定されていても動作します。インタープリタは環境にその変数が存在するかどうかだけをチェックします）。

For instance, the ``checks`` option controls stack and signal checks. Thus
``--nochecks`` on the command line disables the option, and setting the
``PURE_NOCHECKS`` environment variable makes this the default, in which case
you can use ``--checks`` on the command line to reenable the option.

例えば、 ``checks`` オプションはスタックとシグナルのチェックを制御します。したがって ``--nochecks`` をコマンドラインで指定すると、このオプションは無効となります。また、環境変数 ``PURE_NOCHECKS`` を設定した場合は無効な状態をデフォルトとします。この場合、コマンドラインで ``--checks`` を指定すると、オプションが再び有効となるわけです。

Each code generation option can also be used as a *pragma* (compiler
directive) in source code so that you can control it on a per-rule basis. The
pragma must be on a line by itself, starting in column 1, and takes the
following form (using ``--nochecks`` as an example):

  #! --nochecks // line-oriented comment may go here

各コード生成オプションは、ソース内で *プラグマ* （コンパイラディレクティブ）として使うこともでき、ルール単位でオプションを制御することができます。プラグマはそれだけで単独行を占める必要があり、行の1文字目から始まり、次のような形式をとります（例として ``--nochecks`` を使います::

  #! --nochecks // ここに一行コメントを書けます

Currently, the following code generation options are recognized:

今のところ、次のコード生成オプションが認識されます:

``--checks``, ``--nochecks``
    Enable or disable various extra stack and signal checks. By default, the
    interpreter checks for stack overflows (if the ``PURE_STACK`` environment
    variable is set) and pending signals on entry to every function, see
    `Stack Size and Tail Recursion`_ and `Handling of Asynchronous Signals`_
    for details. This is needed to catch these conditions in a reliable way,
    so we recommend to leave this enabled. However, these checks also make
    programs run a little slower (typically some 5%, YMMV). If performance is
    critical then you can disable the checks with the ``--nochecks``
    option. (Even then, a minimal amount of checking will be done, usually on
    entry to every global function.)

``--checks``, ``--nochecks``
    様々な追加スタックチェックと追加シグナルチェックを有効・無効にします。デフォルトでは、インタープリタがチェックするのはスタックオーバーフロー（ ``PURE_STACK`` 環境変数が設定されている場合）と、関数へのエントリー時の保留シグナルです。詳しくは `Stack Size and Tail Recursion`_ と `Handling of Asynchronous Signals`_ を参照して下さい。Thisはtheseを確実な方法でキャッチするために必要なもので、thisを有効なままにしておくことを推奨します。しかし、これらのチェックはプログラムの実行速度を少し遅くします（典型的には 5% ほどですが、異なる意見もあります）。パフォーマンスが非常に重要ならば、 ``--nochecks`` オプションを使ってこのチェックを無効にすることができます（その場合でも、通例としてグローバル関数へのエントリー時に、最小限のチェックが行われます）。

``--fold``, ``--nofold``
    Enable or disable constant folding in the compiler frontend. This means
    that constant expressions involving int and double values and the usual
    arithmetic and logical operations on these are precomputed at compile
    time. (This is mostly for cosmetic purposes; the LLVM backend will perform
    this optimization anyway when generating machine code.) For instance:

``--fold``, ``--nofold``
    コンパイラフロントエンドでの定数の折りたたみを有効・無効にします。 int と double の値を持つ定数式および、それらに対する算術・論理演算を、コンパイル時に事前計算します（これはほぼ表面を取り繕うためだけのものです。いずれにしても LLVM バックエンドはマシンコード生成時にこの最適化を実施します）。例えば::

      > foo x = 2*3*x;
      > show foo
      foo x = 6*x;

    Disabling constant folding in the frontend causes constant expressions to
    be shown as you entered them:

    フロントエンドでの定数折りたたみを無効にすると、あなたが入力したままの形で定数式が表示されます::

      > #! --nofold
      > bar x = 2*3*x;
      > show bar
      bar x = 2*3*x;

``--tc``, ``--notc``
    Enable or disable tail call optimization (TCO). TCO is needed to make
    tail-recursive functions execute in constant stack space, so we recommend
    to leave this enabled. However, at the time of this writing LLVM's TCO
    support is still bug-ridden on some platforms, so the ``--notc`` option
    allows you to disable it. (Note that TCO can also be disabled when
    compiling the Pure interpreter, in which case these options have no
    effect; see the installation documentation for details.)

``--tc``, ``--notc``
    末尾呼び出し最適化〔tail call optimization (TCO)〕を有効・無効にします。 TCO は一定のスタック領域内で末尾再帰関数を実行できるようにするため必要なものであり、このオプションを有効なままにすることを推奨します。しかし、このドキュメントを書いている段階では、 LLVM の TCO サポートはいくつかのプラットフォーム上でまだバグが多く残っている状態なので、 ``--notc`` オプションを無効にすることが可能なままにしてあります（ TCO は Pure インタープリタをコンパイルするときも無効にできます。その場合、このオプションは効果を持ちません。詳しくはインストールドキュメントを参照して下さい）。

Besides these, there's also a special pragma for telling the batch compiler
about "required" functions:

これらに加えて、 "required" な関数をバッチコンパイラに伝えるための特別なプラグマもあります:

``--required fun``
    Inform the batch compiler (cf. `Compiling Scripts`_) that the given
    function symbol ``fun`` should never be stripped from the program. This
    is useful, e.g., if a function is never called explicitly but only through
    ``eval``. Adding a ``--required`` pragma for the function then makes sure
    that the function is always linked into the program.

``--required fun``
    バッチコンパイラ（cf. `Compiling Scripts`_ ）に対して、与えられた関数シンボル ``fun`` をプログラムから決して取り除かないよう伝えます。このオプションが便利なのは、例えば、ある関数が明示的に呼ばれることは一度もないが、 ``eval`` を通して呼ばれることがある場合です。その関数のために ``--required`` プラグマを追加してやると、その関数が常に確実にプログラムへリンクされるようになります。

Note that the ``--required`` pragma can only be used in source code, there's
no command line option for it. An example showing how to use this option can
be found in the `Batch Compilation`_ section.

``--required`` プラグマはソースコード内だけでしか使えないことに注意して下さい。コマンドラインオプションは存在しません。このオプションの使い方を示した例は `Batch Compilation`_ セクションにあります。

Startup Files
-------------

スタートアップファイル

The interpreter may source various files during its startup. These are:

インタープリタは起動時に様々なファイルを読み込みます。以下の通り：

~/.pure_history
    Interactive command history.
    対話コマンドの履歴。

~/.purerc, .purerc, .pure
    Interactive startup files. The latter is usually a dump from a previous
    interactive session.

prelude.pure
    Standard prelude. If available, this script is loaded before any other
    definitions, unless -n was specified.
    標準prelude。prelude.pureがある場合、他のあらゆる定義に先行してロードされます（-n や --noprelude が設定されない限り）

Environment
-----------

環境

Various aspects of the interpreter can be configured through the following
shell environment variables:

以下のシェル環境変数を通じて、インタープリタの様々な側面を設定することができます。

BROWSER
    If the PURE_HELP variable is not set (see below), this specifies a
    colon-separated list of browsers to try for reading the online
    documentation. See http://catb.org/~esr/BROWSER/.

    もし PURE_HELP 変数（下を参照）が設定されていない場合、この変数がコロンで区切られたブラウザのリストを定義します。そこの含まれるブラウザはオンラインドキュメントを読む際に順に試されます。  http://catb.org/~esr/BROWSER/ を参照。

PURELIB
    Directory to search for library scripts, including the prelude. If PURELIB
    is not set, it defaults to some location specified at installation time.

    ライブラリスクリプト（prelude を含む）を検索するディレクトリです。もし PURELIB が設定されていない場合、インストール時に定義された場所をデフォルトとします。

PURE_EAGER_JIT
    Enable eager JIT compilation (same as ``--eager-jit``), see `Compiling
    Scripts`_ for details.

    短絡（JIT）コンパイルを有効にします（``--eager-jit`` と同様）。詳しくは `Compiling Scripts`_ を参照。

PURE_HELP
    Command used to browse the Pure manual. This must be a browser capable of
    displaying html files. Default is w3m(1).

    Pureマニュアルを読むのに使うコマンドを設定します。このコマンドはHTMLファイルを表示できるものでなければいけません。デフォルトは w3m(1) です。

PURE_INCLUDE
    Additional directories (in colon-separated format) to be searched for
    included scripts.

    インクルードするスクリプトファイルを探す追加ディレクトリです（コロン区切りフォーマット）。

PURE_LIBRARY
    Additional directories (in colon-separated format) to be searched for
    dynamic libraries.

    動的ライブラリを探す追加ディレクトリです（コロン区切りフォーマット）。

PURE_MORE
    Shell command to be used for paging through output of the show command,
    when the interpreter runs in interactive mode.

    インタープリタが対話モードで実行されているとき、 show コマンドの出力のページングに使われるコマンドです。

PURE_PS
    Command prompt used in the interactive command loop ("> " by default).

    対話式のコマンドループで使われるコマンドプロンプトです（デフォルトは "> "）。

PURE_STACK
    Maximum stack size in kilobytes (default: 0 = unlimited).

    最大スタックサイズをキロバイト単位で設定します（デフォルト: 0 = 制限なし）。

(Besides these, the interpreter also understands a number of other environment
variables for controlling various code generation options; please see `Code
Generation Options`_ above for details.)

これらに加え、インタープリタは他にもたくさんの環境変数を理解するので、様々なコード生成オプションをコントロールできます。詳しくは上部 `Code Generation Options`_ を参照して下さい。

Pure Overview
=============

Pureの全体像

Pure is a fairly simple yet powerful language. Programs are basically
collections of rewriting rules and expressions to be evaluated. For
convenience, it is also possible to define global variables and constants, and
for advanced uses Pure offers macro functions as a kind of preprocessing
facility. These are all described below and in the following sections.

Pureは適度にシンプルであながらパワフルでもある言語です。プログラムは基本的に、書き替えルールと、評価されるべき式の集まりです。便宜のため、グローバル変数と定数を定義することもできます。またもっと高度な使用のため、Pureはマクロ関数も提供します as a kind of preprocessing facility. これらのすべては下のセクションとそれに続くセクションで説明されます。

Here's a first example which demonstrates how to define a simple recursive
function in Pure, entered interactively in the interpreter (note that the
'``>``' symbol at the beginning of each input line is the interpreter's
default command prompt):

これはPureでシンプルな再帰関数を定義する方法を示す最初のサンプルで、インタープリタへ対話的に入力されています（各入力行の先頭にある '``>``' 記号がインタープリタのデフォルトプロンプトだということに注意して下さい）::

  > // my first Pure example
  > fact 0 = 1;
  > fact n::int = n*fact (n-1) if n>0;
  > let x = fact 10; x;
  3628800

Lexical Matters
---------------

レキシカルな要素

Pure is a free-format language; whitespace is insignificant, except if it
serves to delimit other symbols. Hence, as shown above, definitions and
expressions at the toplevel have to be terminated with a semicolon, even in
interactive mode.

Pure は自由形式〔free-format〕の言語です。ホワイトスペースは、他のシンボルの境界として機能する場合を除き、重要ではありません。したがって、上で示した通り、たとえ対話モードであっても、最上位にある定義と式はセミコロンで終わる必要があります。

Comments have the same syntax as in C++ (using ``//`` for line-oriented and
``/* ... */`` for multiline comments; the latter may not be nested). Lines
beginning with ``#!`` are treated as comments, too; as already discussed
above, on Unix-like systems this allows you to add a "shebang" to your main
script in order to turn it into an executable program.

コメントは C++ と同じ文法を持っています（ ``//`` を一行コメントに使い、 ``/* ... */`` を複数行コメントに使用。後者はネスト可能）。 ``#!`` で始まる行もまたコメント扱いで、すでに上で議論した通り、 Unix-like なシステム上では、メインスクリプトにこの "shebang" を追加して実行可能なプログラムへと変えることができます。

There are a few reserved keywords which cannot be used as identifiers:

識別子に使うことができない予約語がいくつかあります::

  case const def else end extern if infix infixl infixr let namespace
  nonfix of otherwise outfix postfix prefix private public then using
  when with

The customary notations for identifiers, numbers and strings are all
provided. In addition, Pure also allows you to define your own operator
symbols. Pure fully supports Unicode, so that you can write your programs in
almost any language and make good use of the special symbols in the Unicode
character set, provided that you encode your scripts in UTF-8. To keep this
simple, besides the ASCII punctuation characters, Pure also considers the
following code points in the Unicode repertoire as punctuation: U+00A1 through
U+00BF, U+00D7, U+00F7, and U+20D0 through through U+2BFF. This comprises the
special symbols in the Latin-1 repertoire, as well as the Combining
Diacritical Marks for Symbols, Letterlike Symbols, Number Forms, Arrows,
Mathematical Symbols, Miscellaneous Technical Symbols, Control Pictures, OCR,
Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes, Miscellaneous
Symbols, Dingbats, Miscellaneous Mathematical Symbols A, Supplemental Arrows
A, Supplemental Arrows B, Miscellaneous Mathematical Symbols B, Supplemental
Mathematical Operators, and Miscellaneous Symbols and Arrows. This should
cover almost everything you'd ever want to use in an operator symbol. All
other extended Unicode characters are effectively treated as "letters" which
can be used as identifier constituents.

識別子、数値、文字列の慣習的な表記法はすべて提供されています。加えて、Pureではあなたが自分で演算子を定義することも許されます。PureはUnicodeをフルサポートしており、（ほとんど）あらゆる言語でプログラムを書くことができ、Unicode文字セットに含まれる■特別な■記号を活用することができます（スクリプトがUTF-8でエンコードされていることが必要）。このシンプルさを保つため、ASCIIの句読点文字に加えて、PureはUnicodeレパートリーが含む以下のコードポイントを句読点とみなします: U+00A1 から U+00BF まで、 U+00D7、 U+00F7、 U+20D0 から U+2BFF まで。これは Latin-1 レパートリーの特別記号や以下の記号を含んでいます: Combining Diacritical Marks for Symbols, Letterlike Symbols, Number Forms, Arrows, Mathematical Symbols, Miscellaneous Technical Symbols, Control Pictures, OCR, Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes, Miscellaneous Symbols, Dingbats, Miscellaneous Mathematical Symbols A, Supplemental Arrows A, Supplemental Arrows B, Miscellaneous Mathematical Symbols B, Supplemental Mathematical Operators, and Miscellaneous Symbols and Arrows 。あなたが演算子シンボルとして使いたいと願うもののほぼすべてをカバーしているでしょう。その他の Unicode 拡張文字は事実上「文字」として扱われ、識別子の構成要素にすることができます。

Definitions and Expression Evaluation
-------------------------------------

定義と、式の評価

On the surface, Pure is quite similar to other modern functional languages
like Haskell_ and ML_. But under the hood it is a much more dynamic language,
more akin to Lisp. In particular, Pure is dynamically typed, so functions can
be fully polymorphic and you can add to the definition of an existing function
at any time. For instance, we can extend the example above to make the
``fact`` function work with floating point numbers, too:

表面的には、Pureは Haskell_ や ML_ のような他の現代的関数型言語とよく似ています。しかしフードの下ではもっと動的な言語で、より Lisp に近くなります。特に、Pureは動的に型を決定するので、関数はとても多態的になることができますし、あなたは既存の関数に定義を追加することができます。例えば、上で例に出した例を拡張して、 ``fact`` 関数が浮動小数点数を扱えるようにすることも可能です::

  > fact 0.0 = 1.0;
  > fact n::double = n*fact (n-1) if n>0;
  > fact 10.0;
  3628800.0
  > fact 10;
  3628800

Note the ``n::double`` construct on the left-hand side of the second
equation, which means that the equation is only to be applied for (double
precision) floating point values ``n``. This construct is also called a "type
tag" in Pure parlance, which is actually a simple form of pattern matching
(see below). Similarly, our previous definition at the beginning of this
section employed the ``int`` tag to indicate that the ``n`` parameter is an
integer value. The ``int`` and ``double`` types are built into the Pure
language, but it is also possible to introduce your own type tags for
user-defined data structures. This will be explained in more detail under
`Type Tags`_ in the `Rule Syntax`_ section below.

2番目の等式の左辺側にある ``n::double`` 構造に注意して下さい。これはこの等式が（倍精度の）浮動小数点数の値をもつ ``n`` だけに適用されるものであることを意味しています。この構造はPure用語で「型タグ」とも呼ばれるもので、実際、パターンマッチングのシンプルな形式でもあります（下部参照）。同じように、このセクション冒頭の定義では ``int`` タグを使って ``n`` パラメータが整数値であることを示しました。 ``int`` 型と ``double`` 型はPure言語に組み込まれているものですが、ほかにユーザ定義のデータ構造のための独自の型タグをあなたが導入することも可能です。それについての詳細は下部 `Rule Syntax`_ セクション内 `Type Tags`_ 部で説明します。

Expressions are generally evaluated from left to right, innermost expressions
first, i.e., using call by value semantics. Pure also has a few built-in
special forms (most notably, conditional expressions, the short-circuit
logical connectives ``&&`` and ``||``, the sequencing operator ``$$``, the
lazy evaluation operator ``&``, and the ``quote``) which take some or all of
their arguments unevaluated, using call by name.

式は一般に左から右へ、内側の式ほど先に評価されます。すなわちcall by value semanticsを使っています。Pureはまた、いくつかの組み込み特別形を持っています（特に注目すべきは条件式に関するもので、短絡論理結合子 ``&&`` と ``||`` 、継起演算子〔sequencing operator〕 ``$$`` 、遅延評価演算子 ``&`` 、そして ``quote`` ）。これらはいくつかの、あるいはすべての引数を未評価なまま持ち、call by name方式を使います。

Like in Haskell and ML, functions are often defined by pattern matching, i.e.,
the left-hand side of a definition is compared to the target expression,
binding the variables in the pattern to their actual values accordingly:

Haskell や ML のように、関数はしばしばパターンマッチングによって評価されます。つまり、定義の左辺は対象となる式と比較され、変数がパターン中の実際の値に対応するかたちで束縛されます::

  > foo (bar x) = x-1;
  > foo (bar 99);
  98

Due to its term rewriting semantics, Pure goes beyond most other functional
languages in that it can do symbolic evaluations just as well as "normal"
computations:

書き替えセマンティクスにより、「普通の」計算だけでなく記号代数的評価を行えるという点で、Pureは他の関数言語の一歩先を行っています::

  > square x = x*x;
  > square 4;
  16
  > square (a+b);
  (a+b)*(a+b)

Leaving aside the built-in support for some common data structures such as
numbers and strings, all the Pure interpreter really does is evaluate
expressions in a symbolic fashion, rewriting expressions using the equations
supplied by the programmer, until no more equations are applicable. The result
of this process is called a `normal form` which represents the "value" of the
original expression. Keeping with the tradition of term rewriting, there's no
distinction between "defined" and "constructor" function symbols in
Pure. Consequently, any function symbol or operator can be used *anywhere* on
the left-hand side of an equation, and may act as a constructor symbol if it
happens to occur in a normal form term. This enables you to work with
algebraic rules like associativity and distributivity in a direct fashion:

数値や文字列のようないくつかの有名なデータ構造は別として、Pureインタープリタが実際に行うのは、記号代数的なやり方で式を評価し、プログラマーが与えた等式によって式を書き替えてゆき、もうそれ以上は等式を適用できなくなるまで続けることです。この処理の結果は「正規形」と呼ばれ、元々の式の「値」〔"value"〕を表します。項書き替えという流儀を貫くことにより、Pure内では「定義済み」〔"defined"〕関数シンボルと「コンストラクタ」〔"constructor"〕関数シンボルの区別はありません。その結果、あらゆる関数シンボルや演算子は等式左辺の *どこでも* 使うことができ、もし正規形の項の中に現れた場合にはコンストラクタシンボルとして振る舞うことが許されます。このことにより、あなたは結合や分配のような代数のルールをそのままのやり方で使うことができます::

  > (x+y)*z = x*z+y*z; x*(y+z) = x*y+x*z;
  > x*(y*z) = (x*y)*z; x+(y+z) = (x+y)+z;
  > square (a+b);
  a*a+a*b+b*a+b*b

Note that, in contrast, languages like Haskell and ML always enforce the
so-called "constructor discipline", which stipulates that only pure
constructor symbols (without any defining equations) may occur as a subterm on
the left-hand side of a definition. Thus equational definitions like the above
are forbidden in these languages. In Pure such definitions are just normal
business, which makes the language directly usable as a tool for symbolic
algebra.

これに対して、 Haskell や ML のような言語がいわゆる「コンストラクタ原則」を常に強制することに注意して下さい。「コンストラクタ原則」の規定では、純粋なコンストラクタシンボル（いかなる定義的な等式も伴わない）だけしか定義左辺内の下位項〔subterm〕として現れることを許されません。したがって、これらの言語では上のような等式定義が許されません。しかしこのような定義は Pure では普通のことです。こうした特徴により、 Pure は記号代数のツールとして直接使えるものになっています。

Parameters in Equations
-----------------------

等式のパラメータ

Taking a look at the above examples, you might have been wondering how the
Pure interpreter figures out what the parameters (a.k.a. "variables") in an
equation are. This is quite obvious in rules involving just variables and
special operator symbols, such as ``(x+y)*z = x*z+y*z``. However, what about
an equation like ``foo (foo bar) = bar``? Since most of the time we don't
declare any symbols in Pure, how does the interpreter know that ``foo`` is a
literal function symbol here, while ``bar`` is a variable?

前段で挙げた例を見て、あなたはPureのインタープリタが等式中の何をパラメータ（「変数」とも呼ばれる）として理解するのか不思議に思っているかもしれません。例えば ``(x+y)*z = x*z+y+z`` のように、単に変数と演算専用の記号だけを含むルールであれば、この区別ははっきりしています。しかし ``foo (foo bar) = bar`` のような等式ではどうでしょうか？ Pureを使うほとんどの機会において私たちはいかなる記号も定義しないのに、インタープリタは ``foo`` がここで関数リテラルのシンボルであり、 ``bar`` が変数であることを理解できるのでしょうか？

The answer is that the interpreter considers the different positions in the
left-hand side expression of an equation. Basically, a Pure expression is just
a tree formed by applying expressions to other expressions, with the atomic
subexpressions like numbers and symbols at the leaves of the tree. (This is
even true for infix expressions like ``x+y``, since in Pure these are always
equivalent to a function application of the form ``(+) x y`` which has the
atomic subterms ``(+)``, ``x`` and ``y`` at its leaves.)

答えはこういうことです。インタープリタは等式の左辺にある式の異なる位置を考えます。Pureの式は基本的に、ある式を他の式に適用する単なるツリー形状をとり、そのツリーの枝には、数値や記号などアトム的な下位式〔subexpressions〕が葉として付いています（このことは ``x+y`` のような挿入演算子の式〔infix expressions〕についても当てはまります。なぜならPureにおいてこれらは ``(+) x y`` という形式の関数アプリケーションと常に等価〔equivalent〕であり、この式は ``(+)`` と ``x`` と ``y`` というアトム的な下位項〔subterms〕を葉として持っていることになります）。

Now the interpreter divides the leaves of the expression tree into "head" (or
"function") and "parameter" (or "variable") positions based on which leaves
are leftmost in a function application or not. Thus, in an expression like ``f
x y z``, ``f`` is in the head or function position, while ``x``, ``y`` and
``z`` are in parameter or variable positions. (Note that in an infix
expression like ``x+y``, ``(+)`` is the head symbol, not ``x``, as the
expression is really parsed as ``(+) x y``, see above.)

今やインタープリタは式の木についている複数の葉を「頭」（または「関数」）の位置と「パラメータ」（または「変数」）の位置に分割し、最も左にある葉は関数アプリケーションの位置を占めることになり、他はそうなりません。したがって、 ``f x y z`` のような式のうち、 ``f`` は頭もしくは関数の位置にあり、 ``x`` と ``y`` と ``z`` はパラメータもしくは変数の位置にあることになります（``x+y`` のような挿入演算子の式では、 あくまで ``(+)`` が頭部シンボルであり、決して ``x`` ではないことに注意して下さい。上で説明したように、この式は ``(+) x y`` として構文解析されます）。

■headは「先頭」とすべきだろうか？

Identifiers in head positions are taken as literal function symbols by the
interpreter, while identifiers in variable positions denote, well,
variables. We also refer to this convention as the `head = function rule`. It
is quite intuitive and lets us get away without declaring the variables in
equations. (There are some corner cases not covered here, however. In
particular, Pure allows you to declare special constant symbols, if you need a
symbol to be recognized as a literal even if it occurs in a variable
position. This is done by means of a ``nonfix`` declaration, see `Symbol
Declarations`_ for details.)

頭の位置にある識別子はインタープリタによって関数リテラルのシンボルとして扱われ、それに対して変数の位置にある識別子は、そう、変数を与えます。私たちはこのしきたりを `頭＝関数ルール` と呼んで言及しています。このルールはとても直感的で、等式内で変数を宣言することなく私たちは先へ進むことができます（ただし、ここではカバーしきれない厄介なケースも存在します。特に、あなたがある記号を、それが変数の位置に置かれる時でもリテラルとして認識させる必要があるならば、Pureでは特別な定数記号として宣言することが許されています。これは ``nonfix`` 宣言を通じて可能です。詳しくは `Symbol Declarations`_ を参照して下さい）。

Expression Syntax
-----------------

式の文法

The Pure language provides built-in support for machine integers (32 bit),
bigints (implemented using GMP_), floating point values (double precision IEEE
754), character strings (UTF-8 encoded) and generic C pointers (these don't
have a syntactic representation in Pure, though, so they need to be created
with external C functions). Truth values are encoded as machine integers (as
you might expect, zero denotes *false* and any non-zero value *true*). Pure
also provides some built-in support for lists and matrices, although most of
the corresponding operations are actually defined in the prelude.

Pure言語は以下のデータ型を組み込みサポートしています。machine integer (32 bit), bigint （ GMP_ を使って実装）、浮動小数点値（IEEE 754 倍精度）、character strings (UTF-8 encoded) 、ジェネリック C ポインタ（ただし、ポインタは syntactic representation を持たず、そのため外部C関数として作られる必要がある）。真偽値はmachine integerにエンコードされます（おそらくあなたの想像通り、ゼロは *false* を表し、あらゆる非ゼロ値は *true* を表します）。Pureはまた、リストとマトリクスの組み込みサポートを提供しており、それらに対応する演算〔operation〕は実際には prelude 内で定義されています。

Expressions consist of the following elements:

式は以下の要素から構成されます:

Numbers: ``4711``, ``4711L``, ``1.2e-3``
    The usual C notations for integers (decimal: ``1000``, hexadecimal:
    ``0x3e8``, octal: ``01750``) and floating point values are all provided.
    Integers can also be denoted in base 2 by using the ``0b`` or ``0B``
    prefix: ``0b1111101000``. Integer constants that are too large to fit into
    machine integers are promoted to bigints automatically.  Moreover, integer
    literals immediately followed by the uppercase letter ``L`` are always
    interpreted as bigint constants, even if they fit into machine integers.
    This notation is also used when printing bigint constants, to distinguish
    them from machine integers.

数値: ``4711``, ``4711L``, ``1.2e-3``
    従来のCの記数法で、整数（10進数: ``1000`` 、16進数: ``0x3e8`` 、8進数: ``01750``）と浮動小数点数がすべてサポートされます。整数はまた ``0b`` か ``0B`` プレフィクスを使って2進数でも記述できます: ``0b1111101000`` 。machine integerでは大きすぎて表現しきれない整数の定数は自動的に bigint へ昇格されます。さらに言えば、整数リテラルの直後に大文字の ``L`` が付いている場合、たとえ machine integer で表現しうるものでも常に bigint 定数として解釈されます。 machine integer との区別を明確にするため、この記数法は bigint 定数を出力するときでも貫かれます。

Strings: ``"Hello, world!\n"``
    String constants are double-quoted and terminated with a null character,
    like in C. In difference to C, strings are always encoded in UTF-8, and
    character escapes in Pure strings have a more flexible syntax (borrowed
    from the author's Q language) which provides notations to specify any
    Unicode character. In particular, the notation ``\``\ *n*, where *n* is an
    integer literal written in decimal (no prefix), hexadecimal (``0x``
    prefix), octal (``0`` prefix) or binary (``0b`` prefix) notation, denotes
    the Unicode character (code point) #\ *n*. Since these escapes may consist
    of a varying number of digits, parentheses may be used for disambiguation
    purposes; thus, e.g. ``"\(123)4"`` denotes character #123 followed by the
    ASCII character ``4``. The usual C-like escapes for special non-printable
    characters such as ``\n`` are also supported. Moreover, you can use
    symbolic character escapes of the form ``\&``\ *name*\ ``;``, where *name*
    is any of the XML single character entity names specified in the `XML
    Entity definitions for Characters`__. Thus, e.g., ``"\&copy;"`` denotes
    the copyright character (code point 0x000A9).

__ http://www.w3.org/TR/xml-entity-names/

文字列: ``"Hello, world!\n"``
    文字列定数はCと同じように、ダブルクォートで囲まれヌル文字で終わります。Cと異なるのは、文字列が常にUTF-8でエンコードされること、またPureの文字エスケープがCよりも柔軟な文法を持っていることです（同じ作者のQ言語から借りてきています）。この文法はあらゆるUnicode文字を特定する記法を提供します。特に ``\``[ *n* という表記法（*n* は10進法（プレフィクスなし）、16進数（``0x`` プレフィクス）、8進数（``0`` プレフィクス、2進数（``0b`` プレフィクス）いずれかの整数リテラルで示す）は、 Unicode 文字（コードポイント） #\ *n* を示します。このエスケープは様々な数字で構成することができるので、括弧を使って曖昧さを排除することができます。例えば ``"\(123)4"`` は #123 の後にASCII文字の ``4`` が続いていることを示します。従来のC方式に似た ``\n`` のような非表示の特殊文字エスケープもサポートされます。さらには ``\&``\ *name*\ ``;`` 形式の記号文字エスケープ（ *name* は `XML Entity definitions for Characters`__ で定義される単一文字エンティティ名）も使えます。したがって、例えば ``"&copy;"`` はコピーライト文字（コードポイント 0x000A9）を表します。

__ http://www.w3.org/TR/xml-entity-names/

Function and variable symbols: ``foo``, ``foo_bar``, ``BAR``, ``foo::bar``
    These consist of the usual sequence of letters (including the underscore)
    and digits, starting with a letter. Case is significant, thus ``foo``,
    ``Foo`` and ``FOO`` are distinct identifiers. The '``_``' symbol, when
    occurring on the left-hand side of an equation, is special; it denotes the
    `anonymous variable` which matches any value without actually binding a
    variable. Identifiers can also be prefixed with a namespace identifier,
    like in ``foo::bar``. (This requires that the given namespace has already
    been created, as explained under Namespaces_ in the Declarations_ section.)

関数シンボルと変数シンボル: ``foo``, ``foo_bar``, ``BAR``, ``foo::bar``
    関数と変数を表すシンボルはひとつながりの文字（アンダーバーを含む）と数字で構成され、必ず文字から始まります。大文字と小文字は区別されるので ``foo`` と ``Foo`` と ``FOO`` は別個の識別子です。 ``_`` 記号は、等式の左辺に現れたとき、特別なものとなります。このとき ``_`` は `匿名変数` を示し、実際に変数と束縛されることなくいかなる値にもマッチします。また ``foo::bar`` のように関数・変数の識別子の前に名前空間の識別子を付けることも可能です（この場合、付加した名前空間がすでに作成されていることが必要です。 Declarations_ セクション内 Namespaces_ 部で説明している通りです）。

Operator and constant symbols: ``x+y``, ``x==y``, ``not x``
    For convenience, Pure also provides you with a limited means to extend the
    syntax of the language with special operator and constant symbols by means
    of a corresponding `fixity` declaration, as discussed in section
    `Symbol Declarations`_. Besides the usual infix, prefix and postfix
    operators, Pure also provides outfix (bracket) and nonfix (constant)
    symbols. (Nonfix symbols actually work more or less like ordinary
    identifiers, but the ``nonfix`` attribute tells the compiler that when
    such a symbol occurs on the left-hand side of an equation, it is always to
    be interpreted as a literal constant, cf. `Parameters in Equations`_.)

演算子シンボルと定数シンボル: ``x+y``, ``x==y``, ``not x``
    便宜のため、 Pure は限定された意味を提供しています。対応する `fixity` 宣言を使って、特別な演算子と定数シンボルによって言語の文法を拡張するために。 `Symbol Declarations`_ セクションで議論している通り。従来の挿入〔infix〕、前置〔prefix〕、後置〔postfix〕演算子に加え、 Pure はアウトフィクス（角括弧）とノンフィクス（定数）シンボルも提供します（ノンフィクスシンボルは、実際には多かれ少なかれ普通の識別子と同じような働きをしますが、 ``nonfix`` 属性はコンパイラに対して以下のように伝える点が異なります。そのようなシンボルが等式の左辺に現れたとき、そのシンボルを常にリテラル定数と扱え、と伝えるのです。 cf. `Parameters in Equations`_ ）

    Operator and constant symbols may take the form of an identifier or a
    sequence of punctuation characters. They must always be declared before
    use. Once declared, they are always special, and can't be used as ordinary
    identifiers any more. However, like in Haskell, by enclosing an operator
    in parentheses, such as ``(+)`` or ``(not)``, you can turn it into an
    ordinary function symbol. Also, operators and constant symbols can be
    qualified with a namespace just like normal identifiers.

    演算子シンボルと定数シンボルは、1つの識別子か、句読点文字のシーケンスという形をとることができます。それらは常に使用前に宣言される必要があります。一度宣言されたら、それらシンボルは常に特別であり、もはや通常の識別子として使うことはできません。しかし、 Haskell と同じように、 ``(+)`` や ``(not)`` のように演算子を丸括弧で囲うことにより通常の関数シンボルへ変えることができます。また、演算子シンボルと定数シンボルを、普通の識別子とまったく同じように名前空間で修飾することも可能です。

Lists: ``[x,y,z]``, ``x:xs``, ``x..y``, ``x:y..z``
    Pure's basic list syntax is the same as in Haskell, thus ``[]`` is the
    empty list and ``x:xs`` denotes a list with head element ``x`` and tail
    list ``xs``. (The infix constructor symbol '``:``' is declared in the
    prelude.) The usual syntactic sugar for list values in brackets is
    provided, thus ``[x,y,z]`` is exactly the same as ``x:y:z:[]``.

リスト: ``[x,y,z]``, ``x:xs``, ``x..y``, ``x:y..z``
    Pure の基本的なリスト文法は Haskell と同じです。なので ``[]`` は空リストを、 ``x:xs`` は ``x`` が先頭要素で後の残りが ``xs`` であるリストを示します（挿入コンストラクタシンボル '``:``' は prelude で宣言されています）。角括弧はリスト値を表すよくある糖衣構文として提供されるので、 ``[x,y,z]`` は ``x:y:z:[]`` とまったく同じことです。

    There's also a way to denote arithmetic sequences such as ``1..5``, which
    denotes the list ``[1,2,3,4,5]``. (Haskell users should note the missing
    brackets. In difference to Haskell, Pure doesn't use any special syntax
    for arithmetic sequences, the '``..``' symbol is just an ordinary infix
    operator declared and defined in the prelude.) Sequences with arbitrary
    stepsizes can be written by denoting the first two sequence elements using
    the '``:``' operator, as in ``1.0:1.2..3.0``. (To prevent unwanted
    artifacts due to rounding errors, the upper bound in a floating point
    sequence is always rounded to the nearest grid point. Thus, e.g.,
    ``0.0:0.1..0.29`` actually yields ``[0.0,0.1,0.2,0.3]``, as does
    ``0.0:0.1..0.31``.)

    ``1..5`` のような形で等差数列を示す方法もあります。この例は ``[1,2,3,4,5]`` を表します（ Haskell ユーザは角括弧（ブラケット）が無いことに注意して下さい。 Haskell とは異なり、 Pure は数列のために特別な文法は使いません。 '``..``' 記号は単なる普通の挿入演算子で、 prelude 内で宣言と定義が行われています）。任意の差〔stepsizes〕は数列の最初の2要素に '``:``' を使って、 ``1.0:1.2..3.0`` のように表すことができます（四捨五入のエラーのせいで作為的な数値が混入するのを防ぐため、浮動小数点数列の境界上位は常に最も近いグリッドポイントに丸められます。例えば ``0.0:0.1..0.29`` は実際には ``[0.0,0.1,0.2,0.3]`` をもたらし、また ``0.0:0.1..0.31`` も同じ結果となります。

■TODO 小数点以下の揃えられ方について訳註として詳説を加えたい。

Tuples: ``x,y,z``
    Pure's tuples are a bit unusual: They are constructed by just "pairing"
    things using the '``,``' operator, for which the empty tuple ``()`` acts
    as a neutral element (i.e., ``(),x`` is just ``x``, as is ``x,()``). Pairs
    always associate to the right, meaning that ``x,y,z == x,(y,z) ==
    (x,y),z``, where ``x,(y,z)`` is the normalized representation. This
    implies that tuples are always flat, i.e., there are no nested tuples
    (tuples of tuples); if you need such constructs then you should use lists
    instead. Also note that parentheses are generally only used to group
    expressions and are *not* part of the tuple syntax in Pure, *except* if
    you need to include a tuple in a list or matrix. E.g., ``[(1,2),3,(4,5)]``
    is a three element list consisting of the tuple ``1,2``, the integer
    ``3``, and another tuple ``4,5``. Likewise, ``[(1,2,3)]`` is a list with a
    single element, the tuple ``1,2,3``.

タプル: ``x,y,z``
    Pure のタプルは少し珍しいものです: タプルは '``,``' を使って単純に「ペアになった」何かです。そのため、空のタプル ``()`` はニュートラルな要素として振る舞います（つまり ``(),x`` は単に ``x`` であり、 ``x,()`` もまた同様です）。ペアは常に右側のものと結びつきます。つまり ``x,y,z == x,(y,z) == (x,y),z`` であり、ここでは ``x,(y,z)`` が正規化された表現となります。このことは、タプルが常にフラットであることを含意しています。すなわち、ネストされたタプル（タプルのタプル）というものはありません。もし入れ子の構造が必要なら、タプルの代わりにリストを使うべきです。また、丸括弧は通例では式をグループ化するためだけに使われるもので、 Pure のタプル文法の一部では *ない* ことに注意して下さい。 *ただし* マトリクスやリスト内にタプルを含める必要がある場合は別です。例えば ``[(1,2),3,(4,5)]`` は 1,2 のタプル、整数 3 、もう一つのタプル ``4,5`` という3つの要素からなるリストです。同様に ``[(1,2,3)] は ``1,2,3`` という1つのタプルを持つリストです。

Matrices: ``{1.0,2.0,3.0}``, ``{1,2;3,4}``, ``{1L,y+1;foo,bar}``
    Pure also offers matrices, a kind of arrays, as a built-in data structure
    which provides efficient storage and element access. These work more or
    less like their Octave/MATLAB equivalents, but using curly braces instead
    of brackets. As indicated, commas are used to separate the columns of a
    matrix, semicolons for its rows. In fact, the ``{...}`` construct is
    rather general, allowing you to construct new matrices from individual
    elements and/or submatrices, provided that all dimensions match up. E.g.,
    ``{{1;3},{2;4}}`` is another way to write a 2x2 matrix in "column-major"
    form (however, internally all matrices are stored in C's row-major
    format).

マトリクス: ``{1.0,2.0,3.0}``, ``{1,2;3,4}``, ``{1L,y+1;foo,bar}``
    Pure はマトリクスも提供します。マトリクスは配列の一つで、組み込みのデータ構造であり、効率のよい保存とアクセスを提供します。これらは Ooctave/MATLAB のそれとだいたい同じように動作しますが、角括弧（ブラケット）の代わりに波括弧を使います。すでに示されているように、カンマはマトリクスの列〔columns〕を分け、セミコロンは行〔rows〕を分けます。実際、 ``{...}`` 構造はgeneralであり、すべての次元が一致していれば、個別の要素 and/or サブマトリクスから新しいマトリクスを作ることを許します。例えば ``{{1;3},{2;4}}`` は 2x2 のマトリクスをさきほどと別の「列優先」〔"column-major"〕フォーマットで書く方法です（とはいえ、内部的にはすべてのマトリクスはCの行優先フォーマットで保存されます）。

    Note that, while the ``[...]`` and ``{...}`` constructs look superficially
    similar, they work in very different ways. The former is just syntactic
    sugar for a corresponding constructor term and can thus be used as a
    pattern on the left-hand side of an equation. In contrast, the latter is a
    built-in operation which creates objects of a special matrix type. These
    can *not* be used as patterns (instead, matrix values can be matched using
    the special ``matrix`` type tag, see the `Rule Syntax`_ section for
    details).

    ``[...]`` と ``{...}`` は構造の外見がよく似ているのに対して、両者の動作が非常に異なることに注意して下さい。前者は単に、対応するコンストラクタの syntactic sugar であり、そのため等式左辺のパターンとして使用できます。それと対照的に、後者は組み込み処理の一つであり、専用のマトリクス型を持つオブジェクトを生み出します。こちらはパターンとして使うことはでき *ません* （その代わり、マトリクスの値は専用の ``matrix`` 型タグを使ってマッチさせることができます。詳しくは `Rule Syntax`_ セクションを参照して下さい）。

    Pure supports both numeric and symbolic matrices. The former are
    homogeneous arrays of double, complex double or (machine) int matrices,
    while the latter can contain any mixture of Pure expressions. Pure will
    pick the appropriate type for the data at hand. If a matrix contains
    values of different types, or Pure values which cannot be stored in a
    numeric matrix, then a symbolic matrix is created instead (this also
    includes the case of bigints, which are considered as symbolic values as
    far as matrix construction is concerned). Numeric matrices use an internal
    data layout that is fully compatible with the `GNU Scientific Library`_
    (GSL), and can readily be passed to GSL routines via the C interface. (The
    Pure interpreter does not require GSL, however, so numeric matrices will
    work even if GSL is not installed.)

    Pure は数値マトリクスと記号マトリクスの両者をサポートします。前者は double, complex double or (machine) int の均質な配列〔homogeneous arrays〕であり、対する後者は Pure のいかなる式をも内包することができます。 Pure は各データのために適切な型を採用するでしょう。もしマトリクスがそれぞれ型の異なる値を含んでいたら、あるいは数値マトリクスに保存できない Pure の値を含んでいたら、その代わりに代数マトリクスが創り出されます（これには bigint の場合も含まれます。マトリクス構造に関する限り bigint は代数値とみなされます）。数値マトリクスは `GNU Scientific Library` (GSL) と完全互換のデータレイアウトを使っており、Cインターフェースを使ってGSLへ容易に渡すことが可能です（しかし Pure インタープリタは GSL を必要としないので、数値マトリクスは GSL がインストールされていなくても動作します）。

    More information about matrices and corresponding examples can be found in
    the Examples_ section below.

    マトリクスに関する詳細やそれぞれの例は Example_ セクションにあります。

Comprehensions: ``[x,y | x=1..n; y=1..m; x<y]``, ``{f x | x=1..n}``
    Pure provides both list and matrix comprehensions as a convenient means to
    construct list and matrix values from a "template" expression and one or
    more "generator" and "filter" clauses. The former bind a pattern to values
    drawn from a list or matrix, the latter are just predicates determining
    which generated elements should actually be added to the result. Both list
    and matrix comprehensions are in fact syntactic sugar for a combination of
    nested lambdas, conditional expressions and "catmaps" (a collection of
    operations which combine list or matrix construction and mapping a
    function over a list or matrix, defined in the prelude), but they are
    often much easier to write.

内包: ``[x,y | x=1..n; y=1..m; x<y]``, ``{f x | x=1..n}``
    Pure はリストとマトリクスの内包を提供します。これはリスト値やマトリクス値を、 "template" 式や、1つ以上の "generator" や "filter" 節から構成するのに便利なものです。前者は、あるパターンを、リストかマトリクスで描写される値にバインドします。後者は、生成される要素のどれを結果に追加するか定義しているだけです。リスト内包とマトリクス内包の両者は、実際には、ネストされたラムダと、条件式と、 "catmaps" （リスト構造やマトリクス構造を結合し、ある関数をリストやマトリクスにマッピングする処理のコレクションで、 prelude 内で定義される）を組み合わせた糖衣構文です。しかし■それら■のほうがしばしば簡単に書けます。

    Matrix comprehensions work pretty much like list comprehensions, but
    produce matrices instead of lists. List generators in matrix
    comprehensions alternate between row and column generation so that most
    common mathematical abbreviations carry over quite easily. Examples of
    both kinds of comprehensions can be found in the Examples_ section below.

    マトリクス内包はリスト内包とほとんど同じように動作しますが、リストの代わりにマトリクスを作り出します。マトリクス内包のリストジェネレータは、行と列の生成を異なるものにします。そのため、数学的な abbreviations のほとんどをとても簡単に持ち越すことができます。両種の内包の例は下部 Examples_ セクションにあります。

Function and operator applications: ``foo x y z``, ``-x``, ``x+y``, ``(+x)``
    As in other modern FPLs, function applications are written simply as
    juxtaposition (i.e., in "curried" form) and associate to the left. This
    means that in fact all functions only take a single argument.
    Multi-argument functions are represented as chains of single-argument
    functions. For instance, in ``f x y = (f x) y`` first the function ``f``
    is applied to the first argument ``x``, yielding the function ``f x``
    which in turn gets applied to the second argument ``y``. This makes it
    possible to derive new functions from existing ones using `partial
    applications` which only specify some but not all arguments of a
    function. For instance, taking the ``max`` function from the prelude as an
    example, ``max 0`` is the function which, for a given ``x``, returns ``x``
    itself if it is nonnegative and zero otherwise. This works because
    ``(max 0) x = max 0 x`` is the maximum of ``0`` and ``x``.

関数と演算子の適用: ``foo x y z``, ``-x``, ``x+y``, ``(+x)``
    他の現代的な関数型言語と同じく、関数適用はシンプルに並置して（つまり「カリー化された」形式）書き、左と結合します。つまり、実際にはすべての関数は引数を1つだけ取ることを意味します。複数の引数を取る関数は、引数1つの関数をつなげたものとして表現されます。例えば ``f x y = (f x) y`` という例だと、まず ``f`` が最初の引数 ``x`` に適用され、関数 ``f x`` を生み出します。今度はその新たな関数が第2引数 ``y`` に適用されるわけです。このことにより、既存の関数に `部分適用` を行ってそこから新たな関数を導くことが可能となります。 `部分適用` はいくらかの、全部ではない引数を定義します。 例として prelude から ``max`` 関数を取り上げます。 ``max 0`` に ``x`` が与えられたとき、 ``x`` が負であれば ``x`` そのものを、そうでなければゼロを返します。これが機能するのは ``(max 0) x = max 0 x`` が ``0`` と ``x`` の最大値であるからです。

    Operator applications are written using prefix, postfix, outfix or infix
    notation, as the declaration of the operator demands, but are just
    ordinary function applications in disguise. As already mentioned,
    enclosing an operator in parentheses turns it into an ordinary function
    symbol, thus ``x+y`` is exactly the same as ``(+) x y``. For convenience,
    partial applications of infix operators can also be written using
    so-called `operator sections`. A *left section* takes the form ``(x+)``
    which is equivalent to the partial application ``(+) x``. A *right
    section* takes the form ``(+x)`` and is equivalent to the term ``flip (+)
    x``. (This uses the ``flip`` combinator from the prelude which is defined
    as ``flip f x y = f y x``.) Thus ``(x+) y`` is equivalent to ``x+y``,
    while ``(+x) y`` reduces to ``y+x``. For instance, ``(1/)`` denotes the
    reciprocal and ``(+1)`` the successor function. (Note that, in contrast,
    ``(-x)`` always denotes an application of unary minus; the section
    ``(+-x)`` can be used to indicate a function which subtracts ``x`` from
    its argument.)

    演算子の適用は、その演算子の宣言にもとづき、前置、後置、アウトフィクス、挿入いずれかの記法を使って書きますが、通常の関数適用が変装しただけのものです。すでに述べたように、ある演算子を丸括弧で囲むと、その演算子は普通の関数シンボルとなります。つまり ``x+y`` は ``(+) x y`` とまったく同じだということです。便宜のため、挿入演算子の部分適用はいわゆる `演算子セクション` を使って書くことも可能です。 *左セクション* は ``(x+)`` という形をとりますが、これは ``(+) x`` の部分適用と等価です。 *右セクション* は ``(+x)`` という形をとり、 ``flip (+) x`` と等価で（prelude から連結子 ``flip`` を使っていますが、これは ``flip f x y = f y x`` と定義されています）、したがって ``(x+) y`` は ``x+y`` と等価であり、それに対して ``(+x) y`` は ``y+x`` へと還元されます。例えば ``(1/)`` は逆数を示し、 ``(+1)`` は後者関数を示します（対照的に、 ``(-x)`` はいつでも単項の負数を示すことに注意して下さい。引数から ``x`` を引く関数を表すには ``(+-x)`` を使うことができます）。

Conditional expressions: ``if x then y else z``
    Evaluates to ``y`` or ``z`` depending on whether ``x`` is "true" (i.e., a
    nonzero integer). An exception is raised if the condition is not an
    integer.

条件式: ``if x then y else z``
    ``y`` と ``z`` のどちらを評価するかは ``x`` が "true" （つまり非ゼロ数）かどうかに依存します。条件式が整数でない場合は例外が起きます。

Lambdas: ``\x -> y``
    These denote anonymous functions and work pretty much like in Haskell.
    Pure supports multiple-argument lambdas (e.g, ``\x y -> x*y``), as well as
    pattern-matching lambda abstractions which match one or more patterns
    against the lambda arguments, such as ``\(x,y) -> x*y``. An exception is
    raised if the actual lambda arguments do not match the given patterns.

ラムダ: ``\x -> y``
    これらは無名関数を表しており、 Haskell とまったく同じように動作します。 Pure は複数の引数を取るラムダ（例えば ``\x y -> x*y`` ）やパターンマッチを行うラムダ抽象〔ラムダ抽出／lambda abstractions〕をサポートします。ラムダ抽出は、ラムダの引数に対して1つ以上のパターンマッチを、例えば ``\(x,y) -> x*y`` のようなかたちで行います。与えられたパターンにラムダの実際の引数がマッチしない場合、例外が起きます。

Case expressions: ``case x of rule; ... end``
    Matches an expression, discriminating over a number of different cases,
    similar to the Haskell case construct. The expression ``x`` is matched in
    turn against each left-hand side pattern in the rule list, and the first
    pattern which matches ``x`` gives the value of the entire expression, by
    evaluating the corresponding right-hand side with the variables in the
    pattern bound to their corresponding values. An exception is raised if the
    target expression doesn't match any of the patterns.

Case 式: ``case x of rule; ... end``
    Haskell の case 構造と同じく、式のマッチを行い、たくさんのそれぞれ異なる場合を識別します。式 ``x`` はルールリスト中の各左辺のパターンに対して次々マッチを試され、最初に ``x`` にマッチしたパターンが式全体の値を与えます, by evaluating the corresponding right-hand side with the variables in the pattern bound to their corresponding values. ターゲットの式がどのパターンにもマッチしなかった場合は例外が起きます。

When expressions: ``x when rule; ... end``
    An alternative way to bind local variables by matching a collection of
    subject terms against corresponding patterns, similar to Aardappel_'s
    ``when`` construct. A single binding such as ``x when u = v end`` is
    equivalent to ``case v of u = x end``, but the former is often more
    convenient to write. A ``when`` clause may contain multiple definitions,
    which are processed from left to right, so that later definitions may
    refer to the variables in earlier ones. This is exactly the same as
    several nested single definitions, with the first binding being the
    "outermost" one.

When 式: ``x when rule; ... end``
    ローカル変数を束縛するもう一つの方法です。subject項のコレクションを対応するパターンに対してマッチさせてローカル変数を束縛します。 Aardappel_ の ``when`` 構造と同じです。 ``x when u = v end`` のような単一の束縛は ``case v of u = x end`` と等価ですが、前者のほうが書きやすいことが多いでしょう。 ``when`` 節は複数の定義を含むことができ、この複数の定義は左から右へ処理されます。したがって後にある定義はそれより前にある変数を参照することができます。■これは、単独の定義をいくつかネストした場合とまったく同じで、最初に束縛されたものが "outmost" なものとなります。■

With expressions: ``x with rule; ... end``
    Defines local functions. Like Haskell's ``where`` construct, but it can be
    used anywhere inside an expression (just like Aardappel's ``where``, but
    Pure uses the keyword ``with`` which better lines up with ``case`` and
    ``when``). Several functions can be defined in a single ``with`` clause,
    and the definitions can be mutually recursive and consist of as many
    equations as you want.

With 式: ``x with rule; ... end``
    ローカル関数を定義します。 Haskell の ``where`` 構造と似ていますが、 ``with`` は式の中のどこででも使うことができます（ちょうど Aardappel の ``where`` と同じようなものですが、 Pure は ``with`` キーワードを使います which better lines up with ``case`` and ``when``）。 ``with`` 節の内側で複数の関数を定義することでき、またそれらの関数が相互に再帰的であることもできますし、あなたが望むだけたくさんの等式で構成することもできます。

Operators and Precedence
------------------------

演算子と優先順位

Expressions are parsed according to the following precedence rules: Lambda
binds most weakly, followed by ``when``, ``with`` and ``case``, followed by
conditional expressions (``if``-``then``-``else``), followed by the `simple
expressions`, i.e., all other kinds of expressions involving operators,
function applications, constants, symbols and other primary
expressions. Precedence and associativity of operator symbols are given by
their declarations (cf. `Symbol Declarations`_), and function application
binds stronger than all operators. Parentheses can be used to override default
precedences and associativities as usual.

式は以下の優先順位に従って構文解析されます: ラムダは最も弱く結びつきます。 ``when``, ``with`` and ``case`` が後続する、条件式（ ``if``-``then``-``else`` ）が後続する、`シンプルな式`、つまり他のあらゆる種類の式（演算子、関数アプリケーション、定数、シンボルと other primary expressions を含む）が後続する。演算子シンボルの優先度と結合しやすさは、その宣言により与えられます（cf. `Symbol Declarations`_ ）。また関数アプリケーションは全演算子よりも強く結びつきます。例によって、丸括弧を使うとデフォルトの優先度と結合しやすさをオーバーライドできます。

The common operator symbols like ``+``, ``-``, ``*``, ``/`` etc. are all
declared at the beginning of the prelude, see the `Pure Library Manual`_ for a
list of these. Arithmetic and relational operators mostly follow C
conventions. However, out of necessity (``!``, ``&`` and ``|`` are used for
other purposes in Pure) the logical and bitwise operations, as well as the
negated equality predicates are named a bit differently: ``~``, ``&&`` and
``||`` denote logical negation, conjunction and disjunction, while the
corresponding bitwise operations are named ``not``, ``and`` and
``or``. Moreover, following these conventions, inequality is denoted
``~=``. Also note that ``&&`` and ``||`` are special forms which are evaluated
in short-circuit mode (see below), whereas the bitwise connectives receive
their arguments using call-by-value, just like the other arithmetic
operations.

``+``, ``-``, ``*``, ``/`` などなどありふれた演算子シンボルはすべて prelude の先頭で宣言されています。これらのリストは `Pure Library Manual`_ で参照できます。算術演算子および関係演算子はほとんどCの慣例を踏襲しています。しかし、やむを得ず（Pure では ``!`` と ``&`` と ``|`` を他の目的に使っていますが）論理演算、ビット演算、negated equality predicates はちょっと違う記号を使っています: ``~``, ``&&`` and ``||`` はそれぞれ論理否定、連言命題、選言命題を表します。他方、それぞれに対応するビット演算子は ``not`` ``and`` ``or`` を使います。さらに、これらの慣習を踏襲して、等しくないこと〔inequality〕は ``~=`` で示します。また ``&&`` と ``||`` が特別形であり短絡モード（下部参照）で評価されること、その一方で、ビット結合子が他の算術演算子と同じように call-by-name を用いて引数を受けとることを覚えておいて下さい。

Special Forms
-------------

特別形

As already mentioned, some operations are actually implemented as special
forms. In particular, the conditional expression ``if x then y else z`` is a
special form with call-by-name arguments ``y`` and ``z``; only one of the
branches is actually evaluated, depending on the value of ``x``. Similarly,
the logical connectives ``&&`` and ``||`` evaluate their operands in
short-circuit mode. Thus, e.g., ``x&&y`` immediately becomes false if ``x``
evaluates to false, without ever evaluating ``y``. The built-in definitions of
these operations work as if they were defined by the following equations (but
note that the second operand is indeed passed "by name", so that it isn't
evaluated unless its value is actually needed):

すでに述べた通り、いくつかの演算は実際には特別形として実装されています。特に、条件式 ``if x then y else z`` は名前呼出しの引数 ``y`` と ``z`` を伴う特別形です。 ``x`` の値によって、枝の片方だけが実際に評価されます。同じように、論理結合子 ``&&`` と ``||`` はオペランドを短絡モードで評価します。したがって、例えば ``x&&y`` は ``x`` が偽と評価されるとただちに偽となり、 ``y`` が評価されることはありません。この処理の組み込み定義は、あたかも次のように定義された等式のように動作します（しかし2番目のオペランドは実のところ "by name" で渡されることを覚えておいて下さい。その結果として、2番目のオペランドの値は実際に必要とされない限り評価されないわけです）::

  x::int && y = if x then x else y;
  x::int || y = if x then y else x;

(Note that this isn't quite the same as in C, as the results of these
operations are *not* normalized, i.e., they may return nonzero values other
than 1 to denote "true". This has the advantage that ``&&`` and ``||`` can be
implemented tail-recursively, see `Stack Size and Tail Recursion`_. Thus, if
you need a normalized truth value then you'll have to make sure that either
both operands are already normalized, or you'll have to normalize the result
yourself.)

（これはCの場合とまったく同じというわけではありません。というのもこれらの処理の結果は正規化され *ない* からです。すなわち、これらの処理は "true" を示すために1意外の非ゼロ値を返す可能性があります。このことには ``&&`` と ``||`` を末尾再帰で実装できるという利点があります（`Stack Size and Tail Recursion`_ を参照して下さい）。したがって、もし正規化された真偽値を必要とする場合、あなたは両方のオペランドいずれもがすでに正規化されていることを確認するか、あるいは結果そのものをあなたが自分で正規化しなければなりません。

If the built-in definitions of ``&&`` and ``||`` fail then both operands are
evaluated and the resulting symbolic term is reduced using the equations
specified by the programmer, which allows you to extend the definitions of
``&&`` and ``||`` just as with other builtins. Also note that if the result
term is in normal form then it is returned as is, thus ``&&`` and ``||`` can
be used in symbolic evaluations as usual. For instance, the following
equations let you compute the disjunctive normal form of logical expressions:

``&&`` と ``||`` の組み込み定義が fail した場合、両方のオペランドが評価され、プログラマーにより定義された等式を使って the resulting symbolic term is reduced. このことにより、あなたは ``&&`` と ``||`` の定義を、他の組み込み演算子と同じように拡張することができます。また、結果の項が正規形である場合、そのまま返されます。したがって ``&&`` と ``||`` を普通通り記号代数評価に使うことができます。例えば、次の等式を使うと論理式の選言的な正規形を計算することができます。::

  // eliminate double negations:
  // 二重否定を排除する:
  ~~a           = a;

  // de Morgan's laws:
  // ド・モルガンの法則:
  ~(a || b)     = ~a && ~b;
  ~(a && b)     = ~a || ~b;

  // distributivity:
  // 分配法則
  a && (b || c) = a && b || a && c;
  (a || b) && c = a && c || b && c;

  // associativity:
  // 結合法則
  (a && b) && c = a && (b && c);
  (a || b) || c = a || (b || c);

Example:
例::

  > a || ~(b || (c && ~d));
  a||~b&&~c||~b&&d

The sequencing operator ``$$`` evaluates its left operand, immediately throws
the result away and then goes on to evaluate the right operand which gives the
result of the entire expression. This operator is useful to write
imperative-style code such as the following prompt-input interaction:

連続演算子〔sequencing operator〕 ``$$`` は左オペランドを評価し、ただちに結果を出し、続けて右オペランドを評価し、それが式全体の結果となります。この演算子は、プロンプト入力のような、命令的なコードを書くのに便利です。::

  > using system;
  > puts "Enter a number:" $$ scanf "%g";
  Enter a number:
  21
  21.0

We mention in passing here that the same effect can be achieved with a
``when`` clause, which also allows you to execute a function solely for its
side-effects and just ignore the return value:

ついでに言っておくと ``when`` 節も同じ目的に使えます。 ``when`` 節は副作用〔side-effects〕を得るために関数を単独で実行することを許し、返値をただ無視します::

  > scanf "%g" when puts "Enter a number:" end;
  Enter a number:
  21
  21.0

The ``&`` operator does lazy evaluation. This is the only postfix operator
defined in the standard prelude, written as ``x&``, where ``x`` is an
arbitrary Pure expression. It turns its operand into a kind of parameterless
anonymous closure, deferring its evaluation. These kinds of objects are also
commonly known as `thunks` or `futures`. When the value of a future is
actually needed (during pattern-matching, or when the value becomes an
argument of a C call), it is evaluated automatically and gets memoized, i.e.,
the computed result replaces the thunk so that it only has to be computed
once. Futures are useful to implement all kinds of lazy data structures in
Pure, in particular: lazy lists a.k.a. streams. A `stream` is simply a list
with a thunked tail, which allows it to be infinite. The Pure prelude defines
many functions for creating and manipulating these kinds of objects; further
details and examples can be found in the Examples_ section below.

``&`` 演算子は遅延評価を行います。標準preludeで唯一定義されている後置演算子で、 ``x`` が Pure の任意の式であるとき ``x&`` と書きます。この演算子はオペランドを一種の無名クロージャへと変え、評価を延期します。この種のオブジェクトは `thunk` や `future` としても知られています。 future の値は実際に必要とされたとき（パターンマッチングの間や、値がC呼び出しの引数となったとき）、自動的に評価され記憶されます。つまり、計算された結果がサンク〔thunk〕と入れ替わるので、サンクは一度だけ計算される必要が生じます。 future は Pure においてあらゆる種類の遅延評価データ構造を実装するのに役立ちます。特に遅延リスト a.k.a. ストリームを実装するために。`stream` は thunked tail を持つ単なるリストで、無限大になることもできます。 Pure の prelude は、この種のオブジェクトを創り、操作するための関数をたくさん定義します。さらなる詳細と具体例は下部 Examples_ セクションにあります。

Last but not least, the special form ``quote`` quotes an expression, i.e.,
``quote x`` (or, equivalently, ``'x``) returns just ``x`` itself without
evaluating it. The prelude also provides a function ``eval`` which can be used
to evaluate a quoted expression at a later time. For instance:

最後になってしまいましたが、 ``quote`` 形式はある式をクォートします。すなわち ``quote x`` （あるいは ``'x`` でも等価）は単に ``x`` を返し、評価は行いません。 prelude はまた ``eval`` 関数を提供します。 ``eval`` はクォートされた式を後で評価することができます。例えば::

  > let x = '(2*42+2^12); x;
  2*42+2^12
  > eval x;
  4180.0

The quote also inhibits evaluation inside matrix values, including the
"splicing" of embedded submatrices:

クォートはマトリクス内の値を評価することも抑制します。これには埋め込まれたサブマトリクスの接合〔"splicing"〕を抑制することも含まれます::

  > '{1,2+3,2*3};
  {1,2+3,2*3}
  > '{1,{2,3},4};
  {1,{2,3},4}

The ``quote`` should be well familiar to Lisp programmers. However, there are
some notable differences, please see `The Quote`_ in the `Caveats and Notes`_
section for details and more examples.

``quote`` は Lisp プログラマーには非常に親しみのあるものでしょう。しかし、注意すべき違いがいくつかあります。さらなる詳細と例は `Caveats and Notes`_ セクション内 `The Quote`_ を参照して下さい。

Toplevel
--------

トップレベル

At the toplevel, a Pure program basically consists of rewriting rules (which
are used to define functions and macros), constant and variable definitions,
and expressions to be evaluated:

トップレベル〔最上位層〕では、 Pure プログラムは基本的に書き替えルール（関数やマクロを定義するのに使われる）、定数と変数の定義、評価されるべき式で構成されます。

Rules: ``lhs = rhs;``
    Rewriting rules always combine a left-hand side pattern (which must be a
    simple expression) and a right-hand side (which can be any kind of Pure
    expression described above). The same format is also used in ``with``,
    ``when`` and ``case`` expressions. In toplevel rules, ``with`` and
    ``case`` expressions, this basic form can also be augmented with a
    condition ``if guard`` tacked on to the end of the rule, where ``guard``
    is an integer expression which determines whether the rule is applicable.
    Moreover, the keyword ``otherwise`` may be used to denote an empty guard
    which is always true (this is syntactic sugar to point out the "default"
    case of a definition; the interpreter just treats this as a comment). Pure
    also provides some abbreviations for factoring out common left-hand or
    right-hand sides in collections of rules; see the `Rule Syntax`_ section
    for details.

ルール: ``lhs = rhs;``
    書き替えルールは常に左辺パターン（単純な式であることが必要）と右辺（上で説明されているあらゆる種類の Pure 式）を結合します。同じフォーマットは ``with`` 、 ``when`` 、 ``case`` 式内でも使えます。トップレベルのルール、 ``with`` 式、 ``case`` 式という基本的な形式はそれぞれ ``if guard`` 条件を末尾に付けることができます。ここで ``guard`` というのは、ルールを適用してよいかどうかを示す整数式です。さらに、 ``otherwise`` キーワードを空の guard を示すものとして使うこともできます。 ``otherwise`` は常に真です（これは "default" ケースを示す糖衣構文です。インタープリタはこれを単にコメントと扱います）。 Pure はまた  provides some abbreviations for factoring out common left-hand or right-hand sides in collections of rules; 詳しくは `Rule Syntax`_ セクションを参照して下さい。

Macro rules: ``def lhs = rhs;``
    A rule starting with the keyword ``def`` defines a macro function. No
    guards or multiple left-hand and right-hand sides are permitted
    here. Macro rules are used to preprocess expressions on the right-hand
    side of other definitions at compile time, and are typically employed to
    implement user-defined special forms and simple kinds of optimization
    rules. See the Macros_ section below for details and examples.

マクロルール: ``def lhs = rhs;``
    ``def`` キーワードで始まるルールはマクロ関数を定義します。この場合、条件ガードや複数の右辺・左辺は許されません。マクロルールは、コンパイル時に他の式の右辺をぷりプロセスするために使われ、また典型的には、ユーザ定義の特別形や単純な最適化ルールを実装するために使われます。詳細と具体例は下部 Macros_ セクションを参照して下さい。

Global variable bindings: ``let lhs = rhs;``
    Binds every variable in the left-hand side pattern to the corresponding
    subterm of the right-hand side (after evaluating it). This works like a
    ``when`` clause, but serves to bind global variables occurring free on the
    right-hand side of other function and variable definitions.

グローバル変数のバインディング: ``let lhs = rhs;``
    左辺のパターン内にあるすべての変数を、右辺の下位項〔subterm〕に（まず評価を行ってから）結びつけます。これは ``when`` 節のように機能しますが、右辺に自由に現れる他の関数や変数定義をグローバル変数へ結びつけてくれます。

Constant bindings: ``const lhs = rhs;``
    An alternative form of ``let`` which defines constants rather than
    variables. (These are not to be confused with nonfix symbols which simply
    stand for themselves!) Like ``let``, this construct binds the variable
    symbols on the left-hand side to the corresponding values on the
    right-hand side (after evaluation). The difference is that ``const``
    symbols can only be defined once, and thus their values do not change
    during program execution. This also allows the compiler to apply some
    special optimizations such as constant folding.

定数バインディング
    ``let`` のもう一つの形で、変数でなく定数を定義します（この定数をノンフィクスシンボルと混同しないで下さい。ノンフィクスは単純にそれ自身を象徴し〔stand for〕ます！）。 ``let`` のように、この構造は左辺の変数シンボルを右辺の対応する値に（まず評価を行ってから）結びつけます。 ``const`` が ``let`` と異なるのは、 ``const`` は一度だけしか定義を行えないので、その値はプログラム実行中に変化しないという点です。これによりコンパイラは、例えば constant folding のような特別な最適化を行うことができます。

Toplevel expressions: ``expr;``
    A singleton expression at the toplevel, terminated with a semicolon,
    simply causes the given value to be evaluated (and the result to be
    printed, when running in interactive mode).

トップレベル式: ``expre;``
    トップレベルにある単独の式（セミコロンで終わる）は単純に、評価されるべき値を生じさせます（そして、対話モードで実行された場合は値が表示されます）。

Scoping Rules
-------------

A few remarks about the scope of identifiers and other symbols are in order
here. Like most modern functional languages, Pure uses `lexical` or `static`
binding for local functions and variables. What this means is that the binding
of a local name is completely determined at compile time by the surrounding
program text, and does not change as the program is being executed. In
particular, if a function returns another (anonymous or local) function, the
returned function captures the environment it was created in, i.e., it becomes
a (lexical) `closure`. For instance, the following function, when invoked with
a single argument ``x``, returns another function which adds ``x`` to its
argument:

識別子や他のシンボルのスコープについては、ここに若干の説明が揃っています。現代的な関数型言語のほとんどと同じように、 Pure ではローカルな関数と変数を `lexical` または `static` に束縛しています。この意味するところは、ローカルな名前の束縛はコンパイル時に周囲を取り巻くプログラムテキストと完全に境界を定められ、プログラムが実行されている間も変わることがありません。特に、もし関数がもう一つの（匿名の、あるいはローカルな）関数を返す場合、返される関数は自分が作り出された環境をキャプチャします。すなわち、それは（レキシカルな）クロージャとなるわけです。例えば、次の関数は、 ``x`` という引数とともに呼ばれると、引数に ``x`` を加算する関数を返します::

  > foo x = bar with bar y = x+y end;
  > let f = foo 99; f;
  bar
  > f 10, f 20;
  109,119

This works the same no matter what other bindings of ``x`` may be in effect
when the closure is invoked:

クロージャが作動するときに他の ``x`` バインディングが有効であったとしても、このプログラムは同じように動作します::

  > let x = 77; f 10, (f 20 when x = 88 end);
  109,119

Global bindings of variable and function symbols work a bit differently,
though. Like many languages which are to be used interactively, Pure binds
global symbols `dynamically`, so that the bindings can be changed easily at
any time during an interactive session. This is mainly a convenience for
interactive usage, but works the same no matter whether the source code is
entered interactively or being read from a script, in order to ensure
consistent behaviour between interactive and batch mode operation.

ただし、グローバルな変数や関数シンボルの束縛は、やや違った動作をします。対話式で使われる多くの言語と同じように、 Pure はグローバルシンボルを `動的に` 束縛します。なので、束縛は対話的なセッションの間のいつでも簡単に変更できます。このことは主に対話式に使うとき便利ですが、ソースコードが対話的に入力された場合でも、スクリプトファイルから読み込まれた場合でも、同じように動作します。対話型処理でもバッチモード処理でも確実に一貫した振る舞いとなるよう、こうした動作になっています。

So, for instance, you can easily bind a global variable to a new value by just
entering a corresponding ``let`` command:

なので、例えば、グローバル変数に新たな値を束縛するには、対応する ``let`` コマンドを入力するだけで済みます::

  > foo x = c*x;
  > foo 99;
  c*99
  > let c = 2; foo 99;
  198
  > let c = 3; foo 99;
  297

This works pretty much like global variables in imperative languages, but note
that in Pure the value of a global variable can only be changed with a ``let``
command at the toplevel. Thus referential transparency is unimpaired; while
the value of a global variable may change between different toplevel
expressions, it will always take the same value in a single evaluation.

これは命令型言語のグローバル変数とほぼ同じように動作します。 Pure のグローバル変数の値は最上位の ``let`` コマンドでのみ変更可能であることを覚えておいて下さい。したがって参照透過性は損なわれていません。あるグローバル変数の値は、最上位にある他の式と異なるかもしれませんが、それは一つの評価においていつも同じ値をとるでしょう。

Similarly, you can also add new equations to an existing function at any
time:

同様に、すでに存在する関数に新たな等式を追加することはいつでも可能です::

  > fact 0 = 1;
  > fact n::int = n*fact (n-1) if n>0;
  > fact 10;
  3628800
  > fact 10.0;
  fact 10.0
  > fact 1.0 = 1.0;
  > fact n::double = n*fact (n-1) if n>1;
  > fact 10.0;
  3628800.0
  > fact 10;
  3628800

(In interactive mode, it is even possible to completely erase a definition,
see section `Interactive Usage`_ for details.)

（対話モードでは定義そのものを完全に消去することさえ可能です。詳しくは `Interactive Usage`_ セクションを参照して下さい）。

So, while the meaning of a local symbol never changes once its definition has
been processed, toplevel definitions may well evolve while the program is
being processed, and the interpreter will always use the latest definitions at
a given point in the source when an expression is evaluated. This means that,
even in a script file, you have to define all symbols needed in an evaluation
before entering the expression to be evaluated.

なので、一度定義が処理されていればローカルシンボルの意味が二度と変わらないのに対し、最上位の定義はプログラムが処理される間に変化していく可能性が高くなり、またインタープリタは常に、式が評価される瞬間、ソースコードのその地点において最新の値を使います。これはつまり、たとえスクリプトファイル内であっても、その式の評価に必要な全てのシンボルを評価される前に定義しておかなければならないということです。

Rule Syntax
===========

ルール文法

Basically, the same rule syntax is used in all kinds of global and local
definitions. However, some constructs (specifically, ``when``, ``let``,
``const`` and ``def``) use a restricted rule syntax where no guards or
multiple left-hand and right-hand sides are permitted. When matching against a
function or macro call, or the subject term in a ``case`` expression, the
rules are always considered in the order in which they are written, and the
first matching rule (whose guard evaluates to a nonzero value, if applicable)
is picked. (Again, the ``when`` construct is treated differently, because each
rule is actually a separate definition.)

基本的に、グローバルorローカルなあらゆる種類の定義に使われるルール文法はすべて同じです。しかし、いくつかの構造（特に ``when``, ``let``, ``const``, ``def``）は厳格なルール文法を使います。これらはガードや複数の右辺・左辺を許容しません。関数やマクロ呼び出しに対するマッチングを行うとき、または ``case`` 式内の subject term に対してマッチングをときは、常にそれらが書かれている順番通りだと考えられ、またファースト・マッチング・ルール（whose guard evaluates to a nonzero value, if applicable）が選ばれます。（もう一度、 ``when`` 構造の扱いは異なります。それぞれのルールが実際には独立して定義されているためです）

Patterns
--------

パターン

The left-hand side of a rule is a special kind of simple expression, called a
`pattern`. Patterns consist of function and operator applications as well as
any of the "atomic" expression types (symbols, numbers, strings and list
values). *Not* permitted are any of the special expression types (lambda,
``case``, ``when``, ``with``, conditional expressions, as well as list and
matrix comprehensions). For technical reasons, the current implementation also
forbids matrix values in patterns, but it is possible to match a matrix value
as a whole using the ``matrix`` type tag, see below.

ルールの左辺は特別な種類の単独式で、 `pattern` と呼ばれます。パターンは関数、演算子アプリケーション、およびあらゆる "atomic" な式タイプ（シンボル、数値、文字列、リストなどの値）から構成されます。しかし左辺値に特別な式タイプ（ラムダ、 ``case``、``when``、``with``、条件式、リスト内包、マトリクス内包）を使うことは許されません。技術的な理由から、現在の実装ではパターン内でマトリクス値を使うことも禁止されています。しかしながら ``matrix`` 型タグを使ってマトリクス値全体をマッチさせることは可能です。詳しくは下部を参照して下さい。

As already mentioned, the '``_``' symbol is special in patterns; it denotes
the `anonymous variable` which matches an arbitrary value (independently for
all occurrences) without actually binding a variable. For instance:

すでに述べた通り、 '``_``' シンボルはパターン内で特別な意味を持ちます。 '``_``' は `無名変数` を示し、任意の値に（independently for all occurrences）マッチして、変数に束縛されることはありません。例えば::

  foo _ _ = 0;

This will match the application of ``foo`` to any combination of two
arguments (and just ignore the values of these arguments).

この場合、2つの引数がどんな組み合わせであっても ``foo`` が適用されます（引数の値はただ無視されます）。■ignore がどういう挙動か要チェック■

Constants in patterns must be matched literally. For instance:

パターン内の定数はリテラルにマッチされなければいけません■意味不明■。例えば::

  foo 0 = 1;

This will only match an application of ``foo`` to the machine integer ``0``,
not ``0.0`` or ``0L`` (even though these compare equal to ``0`` using the
'``==``' operator).

この場合、 ``foo`` が machine integer ``0`` へ適用されている場合に限りマッチします。 ``0.0`` や ``0L`` にはマッチしません（'``==``' 演算子を使って両者を ``0`` と比較するとイコールですが、だとしてもマッチしないのです）。

In difference to Haskell, patterns may contain repeated variables (other than
the anonymous variable), i.e., they may be `non-linear`. Thus rules like the
following are legal in Pure, and will only be matched if all occurrences of
the same variable in the left-hand side pattern are matched to the same
value:

Haskell と違って、パターンに繰り返しの値を含めることができます（無名配列のほかに）。すなわち、パターンは `非線形` になる可能性があります。したがって、次に示すようなルールは Pure では合法的なものです::

  > foo x x = x;
  > foo 1 1;
  1
  > foo 1 2;
  foo 1 2

Non-linear patterns are particularly useful for computer algebra where you
will frequently encounter rules such as the following:

もしあなたが次のようなルールと頻繁に出会うようなら、非線形のパターンは計算機代数のために特に役立つものとなります::

  > x*y+x*z = x*(y+z);
  > a*(3*4)+a*5;
  a*17

.. _same: purelib.html#same
.. |same| replace:: ``same``

The notion of "sameness" employed here is that of syntactical identity, which
means that the matched subterms must be identical in structure and content.
The prelude provides syntactic equality as a function |same|_ and a comparison
predicate '``===``'. Thus the above definition of ``foo`` is roughly
equivalent to the following:

ここで「同じさ」という言葉を使って示そうとしているのは、文法的な一致であり、 matched subterm は構造的にも内容的にも同じでなければなりません。 prelude は文法的な等しさ〔equality〕を |same|_ 関数と '===' 演算子で提供しています。なので、上で示した ``foo`` の定義は大まかに次の表現と等価です::

  foo x y = x if same x y;

It is important to note the differences between syntactic equality embodied by
``same`` and '``===``', and the "semantic" equality operator '``==``'. The
former are always defined on all terms, whereas '``==``' is only available on
data where it has been defined explicitly, either in the prelude or by the
programmer. Also note that '``==``' may assert that two terms are equal even
if they are syntactically different. Consider, e.g.:

``same`` や '``===``' が表す文法的な等しさと、等値演算子 '``==``' が表す意味的な等しさとの間にある違いに注意しておく必要があります。前者があらゆる項に対して定義されているのに対して、'``==``' はデータ（prelude 内かプログラマーによって明確に定義づけられている）に対してしか使えません。また '``==``' は、たとえ両項が文法的に異なっていても両者が「等しい」と断言します。次の例を考えてみて下さい::

  > 0==0.0;
  1
  > 0===0.0;
  0

This distinction is actually quite useful. It gives the programmer the
flexibility to define '``==``' in any way that he sees fit, which is
consistent with the way the other comparison operators like '``<``' and
'``>``' are handled in Pure.

この違いは非常に実用的です。プログラマーがフィットすると思うやり方で '``==``' を定義する柔軟性を与えてくれます。これは Pure が '``<``' や '``>``' など他の比較演算子を扱う方法と矛盾しません。

Patterns may also contain the following special elements which are not
permitted in right-hand side expressions:

* A Haskell-style `"as" pattern` of the form *variable* ``@`` *pattern*
  binds the given variable to the expression matched by the subpattern
  *pattern* (in addition to the variables bound by *pattern* itself). This
  is convenient if the value matched by the subpattern is to be used on the
  right-hand side of an equation.

* Haskellライクな *変数* ``@`` *パターン* という形式の `"as" パターン` は、与えられた変数を、サブパターン *パターン* にマッチする式へ結びつけます（*パターン* そのものにより結びつけられる変数に加えて）。サブパターンにマッチする値を等式右辺で使う場合に便利です。

* A left-hand side variable (including the anonymous variable) may be followed
  by a `type tag` of the form ``::`` *name*, where *name* is either one
  of the built-in type symbols ``int``, ``bigint``, ``double``, ``string``,
  ``matrix``, ``pointer``, or an existing identifier denoting a custom
  constructor symbol for a user-defined data type. The variable can then match
  only values of the designated type. Thus, for instance, '``x::int``'
  only matches machine integers. See the `Type Tags`_ section below for
  details.

* 左辺の変数（無名変数を含む）の後に ``::`` *名前* という形式の `型タグ` を付けることも可能です。 *名前* 部分には、組み込み型シンボル ``int``, ``bigint``, ``double``, ``string``, ``matrix``, ``pointer`` か、あるいはユーザ定義のデータ型を示す識別子のいずれかが入ります。このとき変数は、示された型の値にだけマッチすることになります。だから例えば '``x::int``' は machine integers だけにマッチします。詳しくは下部 `Type Tags`_ セクションを参照して下さい。

Syntactically, both "as" patterns and type tags are primary expressions. If
the subpattern of an "as" pattern is a compound expression, it *must* be
parenthesized. For instance, the following function duplicates the head
element of a list:

文法的には "as" パターンも型タグも primary expressions です。もし "as" パターンのサブパターンが合成式である場合、その式は丸括弧で囲われ *なければいけません* 。例えば、次の関数はリストの先頭要素を複製します::

  foo xs@(x:_) = x:xs;

Note that if you accidentally forget the parentheses around the subpattern
``x:_``, you still get a syntactically correct definition:

もしあなたがサブパターン ``x:_`` を丸括弧で囲うのを忘れてしまった場合、まだ文法的には正しい定義になるでしょう::

  foo xs@x:_ = x:xs;

But this gets parsed as ``(foo xs@x):_ = x:xs``, which is most certainly *not*
what you want. It is thus a good idea to just always enclose the subpattern
with parentheses in order to prevent such glitches.

しかし、これは ``(foo xs@x):_ = x:xs`` という表現と同等に解釈されます。まず間違いなくあなたが求めるものでは *ない* でしょう。なので、こんな厄介な事態を避けるため、いつでもサブパターンを丸括弧で囲うようにしておくのは良い心がけです。

Another potential pitfall is that the notation ``foo::bar`` is also used to
denote "qualified symbols" in Pure, cf. Namespaces_. Usually this will be
resolved correctly, but if ``foo`` happens to also be a valid namespace then
most likely you'll get an error message about an undeclared symbol. You can
always work around this by adding spaces around the '``::``' symbol, as in
``foo :: bar``. Spaces are never permitted in qualified symbols, so this makes
it clear that the construct denotes a type tag.

もうひとつ陥りがちな落とし穴として、Pure において ``foo::bar`` という書き方は ``型指定されたシンボル`` を示すためにも使われる点があります（cf. Namespaces_）。だいたいの場合は正しく解決されますが、もし ``foo`` が有効な名前空間である場合、

Type Tags
---------

型タグ

Type tags are really nothing but a special form of "as" patterns which
restrict variables to given data "domains". Like Lisp, Pure is essentially a
typeless language and doesn't really have a notion of "data types"; all data
belongs to the same universe of terms. Thus the only way to restrict the type
of values which can be matched by a variable is to provide an "as" pattern
which matches objects of the desired domain and nothing else. However, in the
special case of the built-in types (machine and big integers, double values,
strings, matrices and pointers) there is no way to spell out all
"constructors", as there are infinitely many (or none, as in the case of
``matrix`` and ``pointer`` which are constructed and inspected using special
primitives, but are otherwise "opaque" at the Pure level). As a remedy, an
appropriate type tag makes it possible to match these values.

型タグは "as" パターンの特別な形、以外の何者でもありません。つまり、変数を、指定されたデータ「ドメイン」に限定します。 Pure は Lisp と同じように型のない言語で、「データ型」の記法はありません。すべてのデータは同じ universe of terms に属しています。そのため、ある変数によってマッチされうる値の型を制限するには "as" パターンを与えるしかありません。 "as" パターンを持つ値は、求めるドメインを持つオブジェクトにのみマッチし、他とはしません。しかし、組み込み型の特別なケース（machine and big integers, double 値, 文字列、マトリクス、ポインタ）では、全ての "constructors" を spell out する方法はありません。なぜならそれは無限に多いからです（または、マトリクスとポインタが construct され、special primitives を使って inspect された場合は、何もないことになります。しかしそうでない場合は Pure レベルでは "opaque" です）。改善策としては、適切な型タグを付けることでそうした値にマッチさせることができます。

In order to generalize this to user-defined domains of data, Pure adopts the
convention that any other tagged variable ``x::bar`` is just a shorthand for
the "as" pattern ``x@(bar _)``. Thus a custom data type can be represented by
designating a special constructor symbol (``bar`` in the above example) which
takes the actual data as its single argument. This works the same no matter
what the internal structure of the data is (which in many cases you wouldn't
want to depend on anyway, for the sake of data abstraction).

これをユーザ定義ドメインのデータに一般化するために、 Pure では次のような慣習を適用しています。つまり、あらゆるタグ付き変数 ``x::bar`` は単に "as" パターン ``x@(bar _)`` の略記法にすぎないというものです。したがって、カスタムデータ型は特別なコンストラクタシンボルを作ることによって表されます（上の例では ``bar`` がそれに当たります）。カスタムデータ型となるコンストラクタシンボルは、実際のデータを単独の引数としてとります。この仕組みは、データの内部構造に関わらず同じように動作します（多くの場合、データ型抽象化の便宜をはかるでしょうから、内部構造に依存してしまうのは望まれないことでしょう）。

Note that this is merely a convention, but it works reasonably well and makes
up for the fact that Pure doesn't support data types at the language level.
For instance, we might represent points in the plane using a constructor
symbol ``Point`` which gets applied to pairs of coordinates. We equip this
data type with an operation ``point`` to construct a point from its
coordinates, and two operations ``xcoord`` and ``ycoord`` to retrieve the
coordinates:

このことは慣習であるにすぎないと覚えておいて下さい。しかしこれは非常に合理的に動作し、Pure が言語レベルではデータ型をサポートしていないことの代わりになってくれます。例えば ``Point`` というコンストラクタシンボルを使って平面上の点を表したいとしましょう。このコンストラクタは座標のペアに対して適用されます。私たちは ``point`` という処理によって座標ペアから点を構築し〔construct〕、また ``xcoord`` と ``ycoord`` という2つの処理によって座標を取り戻すことにします::

  point x y = Point (x,y);
  xcoord (Point (x,y)) = x;
  ycoord (Point (x,y)) = y;

Now we might define a function ``translate`` which shifts the coordinates of a
point by a given amount in the x and y directions as follows:

今や私たちは、x 方向と y 方向に指定した量だけ点の座標を動かす ``translate`` 関数を定義することができます。次のように::

  translate (x,y) p::Point = point (xcoord p+x) (ycoord p+y);

Note the use of ``Point`` as a type tag on the ``p`` variable. By these means,
we can ensure that the argument is actually an instance of the point data
type, without knowing anything about the internal representation. We can use
these definitions as follows:

``p`` 変数に対して ``Point`` を型タグとして使っていることに注目して下さい。このような方法で、内部的なデータ表現について何も知らなくても、引数が実際に point データ型であることを保証できます。このような定義を次のように使うことも可能です::

  > let p::Point = point 3 3;
  > p; translate (1,2) p;
  Point (3,3)
  Point (4,5)

Some data types in Pure's standard library (specifically, the container data
types) are actually represented in this fashion, see the `Pure Library
Manual`_ for details.

Pure の標準ライブラリにあるいくつかのデータ型（特に container データ型）は、実際このやり方で表されています。詳しくは `Pure Library Manual`_ を参照して下さい。

General Rules
-------------

The most general type of rule, used in function definitions and ``case``
expressions, consists of a left-hand side pattern, a right-hand side
expression and an optional guard. The left-hand side of a rule can be omitted
if it is the same as for the previous rule. This provides a convenient means
to write out a collection of equations for the same left-hand side which
discriminates over different conditions:

関数宣言と ``case`` 式で使われる最も一般的なタイプのルールは、左辺にパターンがあり、右辺に式と（オプションの）条件ガードで構成されます。ルールの左辺が直前のルールと同じ場合は省略できます。これは、同じ左辺に対して、異なる条件で場合分けされた等式の集まりを書くのに便利です::

  lhs       = rhs if guard;
            = rhs if guard;
            ...
            = rhs otherwise;

For instance:

例えば::

  fact n  = n*fact (n-1) if n>0;
          = 1 otherwise;

Pure also allows a collection of rules with different left-hand sides but the
same right-hand side(s) to be abbreviated as follows:

また Pure では、左辺は異なるが右辺は同じ等式の集まりを、次のように省略して書くことも許しています::

  lhs       |
            ...
  lhs       = rhs;

This is useful if you need different specializations of the same rule which
use different type tags on the left-hand side variables. For instance:

同じルールの左辺の変数に異なる型タグを使い、それぞれ違った特別化を行いたい場合に便利です。例えば::

  fact n::int    |
  fact n::double |
  fact n         = n*fact(n-1) if n>0;
                 = 1 otherwise;

In fact, the left-hand sides don't have to be related at all, so that you can
also write something like:

実際のところ、左辺にある複数の式はまったく関連づけられていません。そのため次のように書くこともできます::

  foo x | bar y = x*y;

However, this construct is most useful when using an "as" pattern to bind a
common variable to a parameter value after checking that it matches one of
several possible argument patterns (which is slightly more efficient than
using an equivalent type-checking guard). E.g., the following definition binds
the ``xs`` variable to the parameter of ``foo``, if it is either the empty
list or a list starting with an integer:

しかし、こうした構造が最も便利なのは、 共通の変数をパラメータ値に束縛するために "as" パターンを使う場合でしょう。パラメータ値がいくつかの引数パターンにマッチするか試された後で束縛されます（これは等価な型チェックガードを使うよりも少しだけ効率的です）。例えば、もしそれが空リストか整数で始まるものである場合は::

  foo xs@[] | foo xs@(_::int:_) = ... xs ...;

The same construct also works in ``case`` expressions, which is convenient if
different cases should be mapped to the same value, e.g.:

同じ構造は ``case`` 式でも機能します。異なるケースでも同じ値にマップさせたいときに便利です::

  case ans of "y" | "Y" = 1; _ = 0; end;

Sometimes it is useful if local definitions (``when`` and ``with``) can be
shared by the right-hand side and the guard of a rule. This can be done by
placing the local definitions behind the guard, as follows (we only show the
case of a single ``when`` clause here, but of course there may be any number
of ``when`` and ``with`` clauses behind the guard):

ローカル定義（ ``when`` と ``with`` ）がルール右辺とガードで共有されうる場合、これは役立ちます::

  lhs = rhs if guard when defns end;

Note that this is different from the following, which indicates that the
definitions only apply to the guard but not the right-hand side of the rule:

この例が次の例と異なることに注意して下さい。次の例では、定義がガードだけに限って適用され、ルール右辺には適用されないことを示しています::

  lhs = rhs if (guard when defns end);

Conversely, definitions placed *before* the guard only apply to the right-hand
side but not the guard (no parentheses are required in this case):

逆に、ガードの *前に* 置かれた定義は右辺にのみ適用され、ガードには適用されません（この場合、丸括弧は必要ありません）::

  lhs = rhs when defns end if guard;

An example showing the use of a local variable binding spanning both the
right-hand side and the guard of a rule is the following quadratic equation
solver, which returns the (real) solutions of the equation ``x^2+p*x+q = 0``
if the discriminant ``d = p^2/4-q`` is nonnegative:

ローカル変数の束縛を、ルールの右辺とガードの両方にまたがらせる例として、二次方程式を解く関数を次に示します。この関数は、もし ``d = p^2/4-q`` の判別式が負でなければ ``x^2+p*x+q = 0`` という等式の実数解を返します::

  > using math;
  > solve p q = -p/2+sqrt d,-p/2-sqrt d if d>=0 when d = p^2/4-q end;
  > solve 4 2; solve 2 4;
  -0.585786437626905,-3.41421356237309
  solve 2 4

Note that the above definition leaves the case of a negative discriminant
undefined.

この定義は、判別式が負である場合を未定義のままにしていることに注目して下さい。

Simple Rules
------------

As already mentioned, ``when``, ``let`` and ``const`` use a simplified kind of
rule syntax which just consists of a left-hand and a right-hand side separated
by the equals sign. In this case the meaning of the rule is to bind the
variables in the left-hand side of the rule to the corresponding subterms of
the value of the right-hand side. This is also called a `pattern binding`.

Guards or multiple left-hand or right-hand sides are not permitted in these
rules. However, it is possible to omit the left-hand side if it is just the
anonymous variable '``_``' by itself, indicating that you don't care about the
result. The right-hand side is still evaluated, if only for its side-effects,
which is handy, e.g., for adding debugging statements to your code. For
instance, here is a variation of the quadratic equation solver which also
prints the discriminant after it has been computed::

  > using math, system;
  > solve p q = -p/2+sqrt d,-p/2-sqrt d if d>=0
  > when d = p^2/4-q; printf "The discriminant is: %g\n" d; end;
  > solve 4 2;
  The discriminant is: 2
  -0.585786437626905,-3.41421356237309
  > solve 2 4;
  The discriminant is: -3
  solve 2 4

Note that simple rules of the same form ``lhs = rhs`` are also used in macro
definitions (``def``), to be discussed in the `Macros`_ section. In this case,
however, the rule denotes a real rewriting rule, not a pattern binding, hence
the left-hand side is mandatory in these rules.

Examples
========

具体例

Here are a few examples of simple Pure programs.

シンプルな Pure プログラムの例をいくつかここで示します。

The factorial:

階乗::

  fact n = n*fact (n-1) if n>0;
         = 1 otherwise;
  let facts = map fact (1..10); facts;

The Fibonacci numbers:

フィボナッチ数::

  fib n = a when a,b = fibs n end
            with fibs n = 0,1 if n<=0;
                        = case fibs (n-1) of
                            a,b = b,a+b;
                          end;
            end;
  let fibs = map fib (1..30); fibs;

It is worth noting here that Pure performs tail call optimization so that
tail-recursive definitions like the following will be executed in constant
stack space (see `Stack Size and Tail Recursion`_ in the `Caveats and Notes`_
section for more details on this):

Pure が tail call optimization を行うことはここでとても価値あることです。このおかげで次のような末尾再帰の定義を一定のスタック領域で実行できます（詳細は `Caveats and Notes`_ セクション内の `Stack Size and Tail Recursion`_ 部を参照して下さい）。::

  // tail-recursive factorial using an "accumulating parameter"
  fact n = loop 1 n with
    loop p n = if n>0 then loop (p*n) (n-1) else p;
  end;

Here is an example showing how constants are defined and used. Constant
definitions take pretty much the same form as variable definitions with
``let`` (see above), but work more like the definition of a parameterless
function whose value is precomputed at compile time:

以下の例は、定数を定義し、使用する方法を示したものです。定数定義は変数定義とほとんどまったく同じように ``let`` 形式を使います（上部を参照）。しかし定数はむしろ、引数を取らず値がコンパイル時に計算される関数のように動作します::

  > extern double atan(double);
  > const pi = 4*atan 1.0;
  > pi;
  3.14159265358979
  > foo x = 2*pi*x;
  > show foo
  foo x = 6.28318530717959*x;

Note that the compiler normally computes constant subexpression at compile
time, such as ``2*pi`` in the ``foo`` function. This works with all simple
scalars (machine ints and doubles), see `Constant Definitions`_ for details.

コンパイラは通常、定数に含まれる下位式（この例では ``2*pi`` など）をコンパイル時に計算することを覚えておいて下さい。単純スカラー（machine int と double）に対してはすべてこのように動作します。詳しくは `Constant Definitions`_ を参照して下さい。

List Comprehensions
-------------------

リスト内包

List comprehensions are Pure's main workhorse for generating and processing
all kinds of list values. Here's a well-known example, a variation of
Erathosthenes' classical prime sieve:

リスト内包は Pure であらゆる種類のリスト値を生成し、処理するための main workhorse です。ここに掲げるのはよく知られた例で、エラトステネスの篩で素数を発見する古典的アルゴリズムの変形である::

  primes n        = sieve (2..n) with
    sieve []      = [];
    sieve (p:qs)  = p : sieve [q | q = qs; q mod p];
  end;

(This definition is actually rather inefficient, there are much better albeit
more complicated implementations of this sieve.)

（この定義は実用上では非効率なもので、もっと複雑だが効率的な実装がある。）

For instance:

例えば::

  > primes 100;
  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]

If you dare, you can actually have a look at the catmap-lambda-if-then-else
expression the comprehension expanded to:

その気があるなら、 catmap-lambda-if-then-else 式で内包を拡張した例を見てみることもできます::

  > show primes
  primes n = sieve (2..n) with sieve [] = []; sieve (p:qs) = p:sieve
  (catmap (\q -> if q mod p then [q] else []) qs) end;

List comprehensions are also a useful device to organize backtracking
searches. For instance, here's an algorithm for the n queens problem, which
returns the list of all placements of n queens on an n x n board (encoded as
lists of n pairs (i,j) with i = 1..n), so that no two queens hold each other
in check:

リスト内包は、バックトラック探索を組み立てるのに便利でもあります。例えば次の例は n クイーン問題を解くアルゴリズムで、 n x n のボード上に置かれた全ての n クイーンのリストを返します（encoded as lists of n pairs (i,j) with i = 1..n）。結果、2つのクイーンがチェック内で互いをホールドすることはない。■この段落全面見直し■::

  queens n       = search n 1 [] with
    search n i p = [reverse p] if i>n;
                 = cat [search n (i+1) ((i,j):p) | j = 1..n; safe (i,j) p];
    safe (i,j) p = ~any (check (i,j)) p;
    check (i1,j1) (i2,j2)
                 = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
  end;

(Again, this algorithm is rather inefficient, see the examples included in the
Pure distribution for a much better algorithm by Libor Spacek.)

（またまた、このアルゴリズムは非効率です。 Libor Spacek によるもっと効率的なアルゴリズムの例が Pure ディストリビューションに同梱されているので、そちらを参照）

Lazy Evaluation and Streams
---------------------------

遅延評価とストリーム

As already mentioned, lists can also be evaluated in a "lazy" fashion, by just
turning the tail of a list into a future. This special kind of list is also
called a `stream`. Streams enable you to work with infinite lists (or finite
lists which are so huge that you would never want to keep them in memory in
their entirety). E.g., here's one way to define the infinite stream of all
Fibonacci numbers:

すでに述べた通り、リストは「怠惰な」やり方で評価されることも可能です。ただリストの末尾を未来へと向けてやればよいのです。この特殊なリストは `ストリーム` とも呼ばれます。ストリームを使えば、あなたは無限長のリストを扱うこともできるようになります（あるいは有限なリストであっても、あまりに大きくてその全体をメモリ上に保存したいと思わないケースもあるでしょう）。例えば、全フィボナッチ数を含む無限長ストリームを定義する方法の一つをここに示します::

  > let fibs = fibs 0L 1L with fibs a b = a : fibs b (a+b) & end;
  > fibs;
  0L:#<thunk 0xb5d54320>

Note the ``&`` on the tail of the list in the definition of the local ``fibs``
function. This turns the result of ``fibs`` into a stream, which is required
to prevent the function from recursing into samadhi. Also note that we work
with bigints in this example because the Fibonacci numbers grow quite rapidly,
so with machine integers the values would soon start wrapping around to
negative integers.

ローカルな ``fibs`` 関数のリスト末尾にある ``&`` に注目して下さい。これが ``fibs`` の結果をストリームへと変えてくれます。この関数が再帰的な瞑想に陥るのを防ぐにはこれが必要です。また、私たちはこの例で bigint を扱っていることにも注目して下さい。フィボナッチ数はすぐに大きくなり、machine integer を使っているとすぐに負の整数側に回り込んでしまうでしょう。

Streams like these can be worked with in pretty much the same way as with
lists. Of course, care must be taken not to invoke "eager" operations such as
``#`` (which computes the size of a list) on infinite streams, to prevent
infinite recursion. However, many list operations work with infinite streams
just fine, and return the appropriate stream results. E.g., the ``take``
function (which retrieves a given number of elements from the front of a list)
works with streams just as well as with "eager" lists:

このようなストリームは通常のリストとまったく同じ方法で扱うことができます。もちろん、無限に繰り返される処理を避けるため、 ``#`` （リストの長さを計算する）のような「熱心な」処理を始めないよう気をつける必要はあります。しかし、リスト処理の多くは無限長のストリームでもうまく処理できますし、適切な結果ストリームを返してくれます。例えば ``take`` 関数（与えられた数の要素をリストの先頭から取得する）はストリームを処理する場合でも「熱心な」（先行評価の）リストと同じようにうまくやってくれます::

  > take 10 fibs;
  0L:#<thunk 0xb5d54350>

Hmm, not much progress there, but that's just how streams work (or rather they
don't, they're lazy bums indeed!). Nevertheless, the stream computed with
``take`` is in fact finite and we can readily convert it to an ordinary list,
forcing its evaluation:

うーん、うまくいきませんね。でもこれがストリームの働き方なんです（もしかしたら、ずっとやらないかもしれません、なんせ怠惰なろくでなしなので！）。でも、 ``take`` で計算されたストリームは実際には有限で、強制的に評価してやれば普通のリストへと簡単に変換できます::

  > list (take 10 fibs);
  [0L,1L,1L,2L,3L,5L,8L,13L,21L,34L]

An easier way to achieve this is to cut a "slice" from the stream:

もっと簡単に実現するなら、ストリームから「スライス」を切り取ります::

  > fibs!!(0..10);
  [0L,1L,1L,2L,3L,5L,8L,13L,21L,34L,55L]

Also note that since we bound the stream to a variable, the already computed
prefix of the stream has been memoized, so that this portion of the stream is
now readily available in case we need to have another look at it later. By
these means, possibly costly reevaluations are avoided, trading memory for
execution speed:

私たちはストリームを変数に束縛したので、ストリームのうちすでに計算されたプレフィクスは記憶されていることを忘れないで下さい。なので、ストリームのこの部分をあとから使いたい場合でも簡単に使える状態になっています。この方法で実行速度とメモリーを取り引きすれば、コストがかかる可能性のある再評価を避けることができます::

  > fibs;
  0L:1L:1L:2L:3L:5L:8L:13L:21L:34L:55L:#<thunk 0xb5d54590>

Let's take a look at some of the other convenience operations for generating
stream values. The prelude defines infinite arithmetic sequences, using
``inf`` or ``-inf`` to denote an upper (or lower) infinite bound for the
sequence, e.g.:

さあ、ストリームの値を生成する便利な処理を他にも見てみましょう。 prelude は無限大の数列を定義します。そこでは ``inf`` または ``-inf`` をその数列に束縛し、正の（or 負の）無限大を示すのに使うことができます::

  > let u = 1..inf; let v = -1.0:-1.2..-inf;
  > u!!(0..10); v!!(0..10);
  [1,2,3,4,5,6,7,8,9,10,11]
  [-1.0,-1.2,-1.4,-1.6,-1.8,-2.0,-2.2,-2.4,-2.6,-2.8,-3.0]

Other useful stream generator functions are ``iterate``, which keeps applying
the same function over and over again, ``repeat``, which just repeats its
argument forever, and ``cycle``, which cycles through the elements of the
given list:

他の便利なストリーム生成関数として ``iterate`` があります。これは同じ関数を何度も何度も適用しつづけます。また ``repeat`` は、与えられた引数を永遠に繰り返します。 ``cycle`` は与えられたリストの要素を循環させます::

  > iterate (*2) 1!!(0..10);
  [1,2,4,8,16,32,64,128,256,512,1024]
  > repeat 1!!(0..10);
  [1,1,1,1,1,1,1,1,1,1,1]
  > cycle [0,1]!!(0..10);
  [0,1,0,1,0,1,0,1,0,1,0]

Moreover, list comprehensions can draw values from streams and return the
appropriate stream result:

さらに、リスト内包はストリームから値を引き出し、対応する結果ストリームとして返すことができます::

  > let rats = [m,n-m | n=2..inf; m=1..n-1; gcd m (n-m) == 1]; rats;
  (1,1):#<thunk 0xb5d54950>
  > rats!!(0..10);
  [(1,1),(1,2),(2,1),(1,3),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(5,1)]

Finally, let's rewrite our prime sieve so that it generates the infinite
stream of *all* prime numbers:

最後に、この節の最初で書いた素数の篩を書き直して、 *全* 素数を含む無限長のリストを生成するようにしましょう::

  all_primes      = sieve (2..inf) with
    sieve (p:qs)  = p : sieve [q | q = qs; q mod p] &;
  end;

Note that we can omit the empty list case of ``sieve`` here, since the sieve
now never becomes empty. Example:

ここでは ``sieve`` の空リストのケースを省略できることに注目して下さい。なぜなら、この篩が空になることはもうないからです。具体例::

  > let P = all_primes;
  > P!!(0..20);
  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73]
  > P!299;
  1987

You can also just print the entire stream. This will run forever, so hit
``Ctrl-C`` when you get bored:

ストリーム全体を出力することもできます。これは永遠に走り続けるので、飽きたところで ``Ctrl-C`` を押して下さい::

  > using system;
  > do (printf "%d\n") all_primes;
  2
  3
  5
    ...

(Make sure that you really use the ``all_primes`` function instead of the
``P`` variable to print the stream. Otherwise, because of memoization the
stream stored in ``P`` will grow with the number of elements printed until
memory is exhausted. Calling ``do`` on a fresh instance of the stream of
primes allows ``do`` to get rid of each "cons" cell after having printed the
corresponding stream element.)

（ストリームを出力するときは必ず ``P`` 変数ではなく ``all_primes`` 関数を直接出力に使うようにして下さい。そうしないと要素が記憶されてしまうので、 ``P`` に保存されるストリームが表示される要素の数だけ大きくなり、最後にはメモリを使い果たすでしょう。作ったばかりの素数ストリームインスタンスに対して ``do`` を呼び出すと、あるストリーム要素を表示したあと、対応する "cons" cell を ``do`` が取り除いていってくれます）

Matrix Computations
-------------------

マトリクス計算

Pure offers a number of basic matrix operations, such as matrix construction,
indexing, slicing, as well as getting the size and dimensions of a matrix
(these are briefly described in the `Standard Library`_ section
below). However, it does *not* supply built-in support for matrix arithmetic
and other linear algebra algorithms. The idea is that these can and should be
provided through separate libraries (please check the Pure website for the
pure-gsl module which is an ongoing project to provide a full GSL interface
for the Pure language).

Pure は基本的なマトリクス処理を数多く提供します。例えばマトリクスの構築、indexing、スライス、マトリクスの大きさや次元を得ることなどです（これらは下部 `Standard Library`_ セクションで詳しく説明されています）。しかし、マトリクス計算や他の代数アルゴリズムは組み込みでは提供され *ません* 。これらは独立したライブラリで提供可能であり、またそうすべきであるという考えからです（Pure ウェブサイトで pure-gsl モジュールをチェックしてみてください。Pure 言語に完全な GSL インターフェースを提供しようとする現在進行中のプロジェクトです）。

But Pure's facilities for matrix and list processing also make it easy to roll
your own, if desired. First, the prelude provides matrix versions of the
common list operations like ``map``, ``fold``, ``zip`` etc., which provide a
way to implement common matrix operations. E.g., multiplying a matrix ``x``
with a scalar ``a`` amounts to mapping the function ``(a*)`` to x, which
can be done as follows:

しかし Pure はマトリクスやリストを容易に扱えるよう整備されているので、お望みなら自分でそれを作るのも簡単です。まず、 prelude は、よく使うリスト処理（ ``map``, ``fold``, ``zip`` 等々）のマトリクス版を提供します。これらは共通のリスト処理を実装する手段を提供します。例えば、マトリクス ``x`` にスカラー ``a`` の数を掛けることは ``(a*)`` 関数を x に適用することに相当する、というルールは以下のように実現できます::

  > a * x::matrix = map (a*) x if ~matrixp a;
  > 2*{1,2,3;4,5,6};
  {2,4,6;8,10,12}

Likewise, matrix addition and other element-wise operations can be realized
using ``zipwith``, which combines corresponding elements of two matrices using
a given binary function:

さらに、マトリクスの加算や、エレメントに関する他の処理は ``zipwith`` を使って実現できます。これは、2つのマトリクスの互いに対応する要素を、与えられた関数を使って結合します:

  > x::matrix + y::matrix = zipwith (+) x y;
  > {1,2,3;4,5,6}+{1,2,1;3,2,3};
  {2,4,4;7,7,9}

Second, matrix comprehensions make it easy to express a variety of algorithms
which would typically be implemented using ``for`` loops in conventional
programming languages. To illustrate the use of matrix comprehensions, here is
how we can define an operation to create a square identity matrix of a given
dimension:

2番目に、マトリクス内包は様々なアルゴリズムの表現を容易にしてくれます。よくあるプログラミング言語では、典型的には ``for`` ループを使ってこのようなアルゴリズムを実装しています。マトリクス内包の使い方を例示するするため、与えられた大きさの正方行列を作り出す処理を定義する方法をここで示します::

  > eye n = {i==j | i = 1..n; j = 1..n};
  > eye 3;
  {1,0,0;0,1,0;0,0,1}

Note that the ``i==j`` term is just a Pure idiom for the Kronecker
symbol. Another point worth mentioning here is that the generator clauses of
matrix comprehensions alternate between row and column generation
automatically, if values are drawn from lists as in the example above. (More
precisely, the last generator, which varies most quickly, yields a row, the
next-to-last one a column of these row vectors, and so on.) This makes matrix
comprehensions resemble customary mathematical notation very closely.

``i==j`` 項はクロネッカー記号を表すための Pure のイディオムだと覚えておいて下さい。もう一つ触れておいたほうが良さそうな点は、上の例のようにリストから値が取り出される場合、マトリクス内包のジェネレータ節は行と列の生成を自動で交互に行うということです（より正確に言えば、最後のジェネレータは（最初に変化するわけですが）行を生成し、the next-to-last one a column of these row vectors, and so on.）。このことは、マトリクス内包を、数学の慣習的な記述と非常に似たものにしています。

Of course, matrix comprehensions can also draw values from other matrices
instead of lists. In this case the block layout of the component matrices is
preserved. For instance:

もちろん、マトリクス内包は他のマトリクスからリストでなくマトリクスを取り出すこともできます。この場合、要素となるマトリクスのブロックレイアウトは保たれます。例えば::

  > {x,y|x={1,2};y={a,b;c,d}};
  {(1,a),(1,b),(2,a),(2,b);(1,c),(1,d),(2,c),(2,d)}

Note that a matrix comprehension involving filters may fail because the
filtered result isn't a rectangular matrix any more. E.g.,
``{2*x|x={1,2,3,-4};x>0}`` works, as does ``{2*x|x={-1,2;3,-4};x>0}``, but
``{2*x|x={1,2;3,-4};x>0}`` doesn't because the rows of the result matrix have
different lengths.

マトリクス内包にフィルタを含めると失敗するので注意して下さい。なぜかというと、フィルタした結果はもはや長方形のマトリクスではないからです。例えば ``{2*x|x={1,2,3,-4};x>0}`` はうまくいきます。 ``{2*x|x={-1,2;3,-4};x>0}`` も大丈夫。しかし ``{2*x|x={1,2;3,-4};x>0}`` だとうまくいきません。結果となるマトリクスの行の長さがそれぞれ違ってしまうからです。

As a slightly more comprehensive example (no pun intended!), here is a
definition of matrix multiplication in Pure. The building block here is the
"dot" product of two vectors which can be defined as follows:

もう少しわかりやすい例として（シャレじゃなくて！ [#]_ ）、 Pure で定義したマトリクス乗算を示します。 The building block here は "dot" 関数による2つのベクターの積ですが、次のように定義できます::

  > sum = foldl (+) 0;
  > dot x::matrix y::matrix = sum $ zipwith (*) (rowvector x) (rowvector y);
  > dot {1,2,3} {1,0,1};
  4

.. [#] 訳注： "matrix *comprehension*" （マトリクス内包）の話題で "As a slightly more *comprehensive* example" （もう少しわかりやすい例として）と出ているため、ダジャレ疑惑を否定している。故意ではない表現をシャレと解釈されたくない心境は文化を問わないらしい。

The general matrix product now boils down to a simple matrix comprehension
which just computes the dot product of all rows of ``x`` with all columns of
``y`` (the ``rows`` and ``cols`` functions are prelude operations found in
matrices.pure):

ここでマトリクスの一般的な積をシンプルなマトリクス内包へと煮詰めます。 ``x`` の全行と ``y`` の全列との積を計算するだけでよいのです（ ``rows`` 関数と ``cols`` 関数は prelude で定義される演算で、 matrices.pure 内にあります）::

  > x::matrix * y::matrix = {dot u v | u = rows x; v = cols y};
  > {0,1;1,0;1,1}*{1,2,3;4,5,6};
  {4,5,6;1,2,3;5,7,9}

(For the sake of simplicity, this doesn't do much error checking. In
production code you'd check at least the conformance of matrix dimensions, of
course.)

（簡潔にするため、あまりエラーチェックを行っていません。実用するコードでは、少なくともマトリクスの大きさが一致していることをチェックすべきです）

Well, that was easy. So let's take a look at a more challenging example,
Gaussian elimination, which can be used to solve systems of linear
equations. The algorithm brings a matrix into "row echelon" form, a
generalization of triangular matrices. The resulting system can then be solved
quite easily using back substitution.

うん、簡単でした。ではもう少し骨の折れる例として、ガウスの消去法〔Gaussian elimination〕を見てみましょう。線型方程式系（連立一次方程式）を解くのに使われるものです。このアルゴリズムはマトリクスを階段行列〔"row echelon" form〕つまり三角行列を一般化したものへ変形します。その結果として得られる系は後退代入〔back substitution〕を使って簡単に解くことができます。

Here is a Pure implementation of the algorithm. Note that the real meat is in
the pivoting and elimination step (``step`` function) which is iterated over
all columns of the input matrix. In each step, ``x`` is the current matrix,
``i`` the current row index, ``j`` the current column index, and ``p`` keeps
track of the current permutation of the row indices performed during
pivoting. The algorithm returns the updated matrix ``x``, row index ``i`` and
row permutation ``p``.

このアルゴリズムを Pure で実装したものを示します。真の要点はピボッティングと消去ステップ（ ``step`` 関数）にあり、入力されたマトリクスの全ての列に対して繰り返し適用され〔＝イテレートされ〕ると覚えておいて下さい。各ステップにおいて ``x`` は現在のマトリクスであり、 ``i`` は現在の行インデックス、 ``j`` は現在の列インデックス、 ``p`` は■ピボッティング中に実行される行インデックスの現在の順列■を記録します。このアルゴリズムは更新されたマトリクス ``x`` 、行インデックス ``i`` 、順列 ``p`` を返します。

::

  gauss_elimination x::matrix = p,x
  when n,m = dim x; p,_,x = foldl step (0..n-1,0,x) (0..m-1) end;

  // One pivoting and elimination step in column j of the matrix:
  step (p,i,x) j
  = if max_x==0 then p,i,x
    else
      // updated row permutation and index:
      // 更新された行順列とインデックス
      transp i max_i p, i+1,
      {// the top rows of the matrix remain unchanged:
       // 最上段の行は変更されないまま:
       x!!(0..i-1,0..m-1);
       // the pivot row, divided by the pivot element:
       // ピボット要素によって分割されたピボット行:
       {x!(i,l)/x!(i,j)                 | l=0..m-1};
       // subtract suitable multiples of the pivot row:
       // ピボット行の suitable multiples を引く
       {x!(k,l)-x!(k,j)*x!(i,l)/x!(i,j) | k=i+1..n-1; l=0..m-1}}
  when
    n,m = dim x; max_i, max_x = pivot i (col x j);
    x = if max_x>0 then swap x i max_i else x;
  end with
    pivot i x       = foldl max (0,0) [j,abs (x!j)|j=i..#x-1];
    max (i,x) (j,y) = if x<y then j,y else i,x;
  end;

Please refer to any good textbook on numerical mathematics for a closer
description of the algorithm. But here is a brief rundown of what happens in
each elimination step: First we find the pivot element in column ``j`` of the
matrix. (We're doing partial pivoting here, i.e., we only look for the element
with the largest absolute value in column ``j``, starting at row ``i``. That's
usually good enough to achieve numerical stability.) If the pivot is zero then
we're done (the rest of the pivot column is already zeroed out). Otherwise, we
bring it into the pivot position (swapping row ``i`` and the pivot row),
divide the pivot row by the pivot, and subtract suitable multiples of the
pivot row to eliminate the elements of the pivot column in all subsequent
rows. Finally we update ``i`` and ``p`` accordingly and return the result.

このアルゴリズムの詳細な解説は numerical mathematics の良い参考書をあたって下さい。しかし、この例は各消去ステップで起きることの簡潔な要約になっています。まず、マトリクスの ``j`` 列からピボット要素を探します（ここでは部分ピボッティングを行っています。すなわち、 ``j`` 列のうちで最も大きい絶対値を持つ要素だけを、行 ``i`` から順に探します。通常、 numerical stability を保つにはこれで充分です）。もしピボットがゼロならば、完了です（残りのピボット列はすでにゼロとされています）。そうでない場合、 it をピボット位置へ移動し（行 ``i`` とピボット行を置き換える）、ピボット行をピボットで分割し、全後続行内のピボット列から要素を消去するため、適切な倍数をピボット行から引きます。

In order to complete the implementation, we still need the following little
helper functions to swap two rows of a matrix (this is used in the pivoting
step) and to apply a transposition to a permutation (represented as a list):

実装を完了するには、まだ次の小さなヘルパー関数が必要です。この関数はマトリクスの行2つを入れ替え（ピボッティングステップで使われます）、また a transposition を a permutation (represented as a list) に適用するものです::

  swap x i j = x!!(transp i j (0..n-1),0..m-1) when n,m = dim x end;
  transp i j p = [p!tr k | k=0..#p-1]
  with tr k = if k==i then j else if k==j then i else k end;

Finally, let us define a convenient print representation of double matrices a
la Octave_ (the meaning of the ``__show__`` function is explained in the
`Caveats and Notes`_ section):

最後に、便利な print representation of double matrices a la Octave_ を定義しましょう（ ``__show__`` 関数の意味は `Caveats and Notes`_ セクションで説明されています）::

  using system;
  __show__ x::matrix
  = strcat [printd j (x!(i,j))|i=0..n-1; j=0..m-1] + "\n"
  with printd 0 = sprintf "\n%10.5f"; printd _ = sprintf "%10.5f" end
  when n,m = dim x end if dmatrixp x;

Example:

具体例::

  > let x = dmatrix {2,1,-1,8; -3,-1,2,-11; -2,1,2,-3};
  > x; gauss_elimination x;
     2.00000   1.00000  -1.00000   8.00000
    -3.00000  -1.00000   2.00000 -11.00000
    -2.00000   1.00000   2.00000  -3.00000
  [1,2,0],
     1.00000   0.33333  -0.66667   3.66667
     0.00000   1.00000   0.40000   2.60000
     0.00000   0.00000   1.00000  -1.00000

Record Data
-----------

レコード

Matrices also provide a means to represent simple record-like data, by
encoding records as symbolic vectors consisting of "hash pairs" of the form
``key => value``. This kind of data structure is very convenient to represent
aggregates with lots of different components. Since the components of records
can be accessed by indexing with key values, you don't have to remember which
components are stored in which order, just knowing the keys of the required
members is enough. In contrast, tuples, lists and other kinds of constructor
terms quickly become unwieldy for such purposes.

マトリクスはシンプルなレコードのようなデータを提供します。 ``key => value`` という形式の「ハッシュペア」から構成されるシンボリックベクトルとしてレコードをエンコードします。この種のデータ構造は、様々な異なる構成要素からなる集合体を表すのにとても便利です。キーの値をインデックスとしてレコードの要素にアクセスできるので、各要素がどの順番で保存されているか覚えておく必要はなく、必要なメンバーのキーさえわかっていれば充分です。対照的に、タプルやリストなど他の constructor terms はすぐにこうした目的で扱いにくいものとなってしまいます。

.. _Record Functions: purelib.html#record-functions

The keys used for indexing the record data must be either symbols or strings,
while the corresponding values may be arbitrary Pure values. The prelude
provides some operations on these special kinds of matrices, which let you
retrieve vector elements by indexing and perform non-destructive updates, see
the `Record Functions`_ section in the `Pure Library Manual`_ for
details. Here are a few examples which illustrate how to create records and
work with them:

レコードデータの索引となるキーはシンボルか文字列である必要があります。それに対応する値は任意の Pure 値とすることができます。 prelude はこの特殊なマトリクスに対するいくつかの処理を提供します。インデックスによってベクトル要素を取り出したり、非破壊的な更新を行うことが可能となります。詳しくは `Pure Library Manual`_ 内の `Record Functions`_ セクションを参照して下さい。ここでは、レコードの作成と、それを使った作業を解説する例をいくつか示します::

  > let r = {x=>5, y=>12};
  > recordp r, member r x;
  1,1
  > r!y; r!![y,x];
  12
  {12,5}
  > insert r (x=>99);
  {x=>99,y=>12}
  > insert ans (z=>77);
  {x=>99,y=>12,z=>77}
  > delete ans z;
  {x=>99,y=>12}

Note the use of the "hash rocket" ``=>`` which denotes the ``key=>value``
associations in a record. The hash rocket is a constructor declared as an
infix operator in the prelude, see the Prelude_ section in the `Pure Library
Manual`_. There's one caveat here, however. Since neither ``=>`` nor ``!``
treat their key operand in a special way, symbols used as keys must not be
bound to a value (to ensure this, you might want to declare them as
``nonfix``), or you'll have to protect them from being evaluated by quoting
them. Thus, to be on the safe side, you should actually write:

「ハッシュロケット」 ``=>`` が使われている部分に注意を向けて下さい。この記号がレコード内での ``key=>value`` の結びつきを示しています。ハッシュロケットは prelude 内で挿入演算子として定義されているコンストラクタです（ `Pure Library Manual`_ 内の Prelude_ セクションを参照）が、一つだけ注意点があります。 ``=>`` も ``!`` も、キーとなるオペランドを特別な方法で扱っているわけではないので、キーとして使われる複数のシンボルを一つの値に束縛してはいけません（このことを確実にするため、あなたは■それら■を ``nonfix`` として宣言したくなるかもしれません）。あるいは、■それらをクォートすることで評価されるのを防ぐ必要があるでしょう。したがって、安全な道を行くのなら、あなたは次のように書くべきです::

  > let r = {'x=>5, 'y=>12};
  > r!'y; r!!['y,'x];
  12
  {12,5}

It's also possible to use strings as keys instead, which may actually be more
convenient in some cases:

代わりに文字列をキーとして使うこともできます。実際はこちらのほうが便利なケースも多いかもしれません::

  > let r = {"x"=>5, "y"=>12};
  > keys r; vals r;
  {"x","y"}
  {5,12}
  > update r "y" (r!"y"+1);
  {"x"=>5,"y"=>13}

You can also mix strings and symbols as keys in the same record (but note that
strings and symbols are always distinct, so ``y`` and ``"y"`` are really two
different keys here):

同じレコードに文字列のキーとシンボルのキーを混在させることも可能です（ただし文字列とシンボルは常に区別されるので、 ``y`` と ``"y"`` はまったく異なる2つのキーとなることを忘れないで下さい）::

  > insert r (y=>99);
  {"x"=>5,"y"=>12,y=>99}

As records are in fact just special kinds of matrices, the standard matrix
operations can be used on record values as well. For instance, the matrix
constructor provides an alternative way to quickly augment a record with a
collection of new ``key=>value`` associations:

実のところ、レコードは単なる特殊なマトリクスにすぎないので、標準的なマトリクス処理をレコード値に対して同様に使うことができます。例えば、マトリクスコンストラクタを ``key=>value`` 結合のまとまりと合わせて使うことで、レコードを素早く記述するもう一つの方法となります::

  > let r = {x=>5, y=>12};
  > let r = {r, x=>7, z=>3}; r;
  {x=>5,y=>12,x=>7,z=>3}
  > r!x, r!z;
  7,3
  > delete r x;
  {x=>5,y=>12,z=>3}
  > ans!x;
  5

As the example shows, this may produce duplicate keys, but these are handled
gracefully; indexing and updates will always work with the *last* association
for a given key in the record. If necessary, you can remove duplicate entries
from a record as follows; this will only keep the last association for each
key:

上の例が示す通り、この方法では重複したキーを作ることも許されますが、重複したキーは上品に扱われます。索引〔＝indexing＝キーを指定して値を取得すること〕と更新は常に、与えられたキーを持つ結合のうち *最後に作られた* ものに対して動作するのです。もし必要なら、レコードの重複エントリーを次のように削除することができます。これは各キーの最後の結合だけを保存します::

  > record r;
  {x=>7,y=>12,z=>3}

In fact, the ``record`` operation not only removes duplicates, but also orders
the record entries by keys. This produces a kind of normalized representation
which is useful if you want to compare or combine two record values
irrespective of the ordering of the fields. For instance:

実のところ、 ``record`` 処理は重複を消去するだけでなく、レコードのエントリーをキーによって整列させることもします。これにより一種の正規化された姿が作り出されるので、2つのレコードの値を、フィールドの並び方に関係なく比較・結合したい場合に役立ちます。例えば::

  > record {x=>5, y=>12} === record {y=>12, x=>5};
  1

The ``record`` function can also be used to construct a normalized record
directly from a list or tuple of hash pairs:

また ``record`` 関数は、リストやタプルのハッシュペアから、正規化されたレコードを直接構築するのにも使えます::

  > record [x=>5, x=>7, y=>12];
  {x=>7,y=>12}

Other matrix operations such as ``map``, ``foldl``, etc., and matrix
comprehensions can be applied to records just as easily. This enables you to
perform bulk updates of record data in a straightforward way. For instance,
here's how you can define a function ``maprec`` which applies a function to
all values stored in a record:

``map`` や ``foldl`` などなど他のマトリクス処理や、マトリクス内包も簡単にレコードへ適用できます。これにより、レコードのデータを大量に更新する際もわかりやすい方法で実行できます。例えば、次の例では ``maprec`` 関数を定義する方法を示しています。これは、与えられた関数を、レコードに保存されている全ての値に適用します::

  > maprec f = map (\(u=>v) -> u=>f v);
  > maprec (*2) {x=>5,y=>12};
  {x=>10,y=>24}

Another example: The following ``ziprec`` function collects pairs of values
stored under common keys in two records (we also normalize the result here so
that duplicate keys are always removed):

例をもうひとつ。次の ``ziprec`` 関数は、2つのレコードに共通するキーの下に保存されている値のペアを集めてくるものです::

  > ziprec x y = record {u=>(x!u,y!u) | u = keys x; member y u};
  > ziprec {a=>3,x=>5,y=>12} {x=>10,y=>24,z=>7};
  {x=>(5,10),y=>(12,24)}

Thus the full power of generic matrix operations is available for records,
which turns them into a very versatile data structure, much more powerful than
records in conventional programming languages which are usually limited to
constructing records and accessing or modifying their components. Note that
since the values stored in records can be arbitrary Pure values, you can also
have mutable records by making use of Pure's expression references (see
`Expression References`_ in the library manual). And of course records can be
nested, too:

このように、ジェネリックなマトリクス処理のフルパワーをレコードに対して使うことができ、レコードを万能な〔versatile〕データ構造に変えてくれます。従来のプログラミング言語に備わっているレコードは、構築するにも、構成要素に対してアクセスや更新をするにも、しばしば制限があります。Pure のレコードはそれよりはるかに強力です。レコードには任意の Pure 値を保存することができるので、 Pure の式リファレンスを使えば、 mutable なレコードを使うこともできることを忘れないで下さい。もちろんレコードはネストすることもできます::

  > let r = {a => {b=>1,c=>2}, b => 2};
  > r!a, r!b, r!a!b;
  {b=>1,c=>2},2,1

.. _Expression References: purelib.html#expression-references

Macros
======

マクロ

Macros are a special type of functions to be executed as a kind of
"preprocessing stage" at compile time. In Pure these are typically used to
define custom special forms and to perform inlining of function calls and
other simple kinds of source-level optimizations.

マクロは特別なタイプの関数であり、コンパイル時の一種のプリプロセス段階〔"preprocessing stage"〕で実行されます。 Pure においてこれらは典型的に、カスタム特別形を定義するためや、関数呼び出しの直列化〔inlining〕を実行するため、あるいは単純な類のソースレベルでの最適化を行うために使われます。

Whereas the macro facilities of most programming languages simply provide a
kind of textual substitution mechanism, Pure macros operate on symbolic
expressions and are implemented by the same kind of rewriting rules that are
also used to define ordinary functions in Pure. In difference to these, macro
rules start out with the keyword ``def``, and only simple kinds of rules
without any guards or multiple left-hand and right-hand sides are permitted.

ほとんどのプログラミング言語において、マクロは、テキスト的な代替物を提供する仕組みとして便利であるのに対して、 Pure のマクロは記号式の上で作動し、通常の関数を定義する際に使われるのと同じく書き替えルールとして定義されています。通常の書き替えルールと異なるのは、マクロのルールは ``def`` キーワードを先頭に書き始める点と、シンプルなルールだけが許され、ガードや複数の左辺・右辺は許されていないという点です。

Syntactically, a macro definition looks just like a variable or constant
definition, using ``def`` in lieu of ``let`` or ``const``, but they are
processed in a different way. Macros are substituted into the right-hand sides
of function, constant and variable definitions. All macro substitution happens
before constant substitutions and the actual compilation step. Macros can be
defined in terms of other macros (also recursively), and are evaluated using
call by value (i.e., macro calls in macro arguments are expanded before the
macro gets applied to its parameters).

統語的には、マクロ定義は変数や定数の定義とよく似ており、 ``let`` や ``const`` の代わりに ``def`` を使いますが、それぞれが処理される方法は異なります。マクロは右辺にある関数、定数、変数の定義の代わりとなります。全マクロの置換は、定数の置換や実際のコンパイルステップよりも前に実行されます。マクロは他のマクロを使って定義することもできます（再帰的にもできます）。また、値呼び出しで評価されます（つまり、マクロ引数内でのマクロ呼び出しはマクロがパラメータへ適用される前に展開されます）。

Optimization Rules
------------------

最適化ルール

Here is a simple example, showing a rule which expands saturated calls of the
``succ`` function (defined in the prelude) at compile time:

次のシンプルな例は ``succ`` 関数（prelude 内で定義されている）の過剰な呼び出しをコンパイル時に展開するルールを示しています::

  > def succ x = x+1;
  > foo x::int = succ (succ x);
  > show foo
  foo x::int = x+1+1;

Rules like these can be useful to help the compiler generate better code. Note
that a macro may have the same name as an ordinary Pure function, which is
essential if you want to optimize calls to an existing function, as in the
previous example. (Just like ordinary functions, the number of parameters in
each rule for a given macro must be the same, but a macro may have a different
number of arguments than the corresponding function.)

このようなルールはコンパイラがより良いコードを生成する助けとなりうるものです。マクロが Pure の一般的な関数と同じ名前を持つことを許されていることを覚えておいて下さい。このことは、（上の例のように）すでに存在する関数の呼び出しを最適化したい場合にきわめて重要です（一般的な関数とちょうど同じように、あるマクロに対するルールそれぞれが取るパラメータの数は同じでなければいけません。しかし、マクロは、対応する関数とは異なる数のパラメータを取ることが許されています）。

A somewhat more practical example is the following rule from the prelude,
which eliminates saturated instances of the right-associative function
application operator:

prelude から取ってきた次の例はいくらか実践的です。この例では、右結合の関数適用演算子の過剰なインスタンスを排除します::

  def f $ x = f x;

Like in Haskell, this low-priority operator is handy to write cascading
function calls. With the above macro rule, these will be "inlined" as ordinary
function applications automatically. Example:

Haskell で使うのと同じように、この優先度の低い演算子は、段になって流れ落ちる〔cascading〕関数呼び出しを書くのに便利です。上のマクロルールと合わせると、これらを通常の関数適用と同じようなものとして自動的に「インライン化」できます。具体例::

  > foo x = bar $ bar $ 2*x;
  > show foo
  foo x = bar (bar (2*x));

Here are two slightly more tricky rules from the prelude, which optimize the
case of "throwaway" list comprehensions. This is useful if a list
comprehension is evaluated solely for its side effects:

次は prelude からもう少しトリッキーなルールを2つ。これらはリスト内包を「使い捨て」〔"throwaway"〕するケースを最適化します。副作用を利用したいためだけにリスト内包が評価される場合に役立ちます。

  def void (catmap f x) = do f x;
  def void (listmap f x) = do f x;

Note that the ``void`` function simply throws away its argument and returns
``()`` instead. The ``do`` function applies a function to every member of a
list (like ``map``), but throws away all intermediate results and just returns
``()``, which is much more efficient if you don't need those results
anyway. These are both defined in the prelude.

``void`` 関数は、与えられた引数を単純に捨て、代わりに ``()`` を返す関数であることを覚えておいて下さい。 ``do`` 関数は、与えられた関数をリストの各メンバーに（ ``map`` のように）適用しますが、中途段階で生じる返値をすべて捨て、ただ ``()`` を返します。中途段階の返値が必要ない場合にはとても効率的です。両館数は prelude で定義されます。

Before we delve into this example, a few remarks are in order about the way
list comprehensions are implemented in Pure. As already mentioned, list
comprehensions are just syntactic sugar; the compiler immediately transforms
them to an equivalent expression involving only lambdas and a few other list
operations. Note that list comprehensions are essentially equivalent to piles
of nested lambdas, filters and maps, but for various reasons they are actually
implemented using two special helper operations, ``catmap`` and ``listmap``.

この例を掘り下げる前に、 Pure におけるリスト内包の実装方法について手短に整理しておきましょう。すでに述べた通り、リスト内包は糖衣構文に過ぎません。コンパイラはすぐにそれを、ラムダといくつかのリスト演算で構成される等価な式へ変形します。リスト内包はネストされたラムダ、フィルター、マップを積み重ねたものと本質的に等価であると覚えておいて下さい。しかし様々な理由から、それらは実際には ``catmap`` と ``listmap`` という特別なヘルパー処理を使って実装されています。

The ``catmap`` operation combines ``map`` and ``cat``; this is needed, in
particular, to accumulate the results of nested generators, such as ``[i,j | i
= 1..n; j = 1..m]``. The same operation is also used to implement filter
clauses, you can see this below in the examples. However, for efficiency
simple generators like ``[2*i | i = 1..n]`` are translated to a ``listmap``
instead (which is basically just ``map``, but works with different aggregate
types, so that list comprehensions can draw values from aggregates other than
lists, such as matrices).

``catmap`` 処理は ``map`` と ``cat`` を組み合わせたものです。これは、例えば ``[i,j | i = 1..n; j = 1..m]`` といったように、ネストされたジェネレータの結果を蓄積するために特に必要です。フィルター節の実装も同じ処理を使って実装しています。下の例でその例を見ることができます。しかし、効率化のため、 ``[2*i | i = 1..n]`` のようなシンプルなジェネレータは ``listmap`` へと変換されます（これは単なる ``map`` ですが、異なる型の集合をも扱うことができます。その結果、リスト内包は、マトリクスのようなリスト以外の集合からも値を引き出すことができるのです）。

Now let's see how the rules above transform a list comprehension if we
"voidify" it:

さあ、私たちがリスト内包を "voidfy" したとき、上のルールがどのようにそれを変形するか見てみましょう::

  > using system;
  > f = [printf "%g\n" (2^x+1) | x=1..5; x mod 2];
  > g = void [printf "%g\n" (2^x+1) | x=1..5; x mod 2];
  > show f g
  f = catmap (\x -> if x mod 2 then [printf "%g\n" (2^x+1)] else []) (1..5);
  g = do (\x -> if x mod 2 then [printf "%g\n" (2^x+1)] else []) (1..5);

Ok, so the ``catmap`` got replaced with a ``do`` which is just what we need to
make this code go essentially as fast as a ``for`` loop in conventional
programming languages (up to constant factors, of course). Here's how it looks
like when we run the ``g`` function:

OK、 ``catmap`` が ``do`` に置き換えられました。よくあるプログラミング言語の ``for`` ループと本質的に同じくらいこのコードを速くする（up to constant factors, of course）のに必要なのは、まさにこれなんです。 ``g`` 関数を実行するとこんな風に見えます::

  > g;
  3
  9
  33
  ()

It's not all roses, however, since the above macro rules will only get rid of
the outermost ``catmap`` if the list comprehension binds multiple variables:

It's not all roses, however, なぜならリスト内包が複数の変数を束縛している場合、上のマクロルールは最も外側の ``catmap`` を取り除くだけだからです::

  > u = void [puts $ str (x,y) | x=1..2; y=1..3];
  > show u
  u = do (\x -> listmap (\y -> puts (str (x,y))) (1..3)) (1..2);

If you're bothered by this, you'll have to apply ``void`` recursively,
creating a nested list comprehension which expands to a nested ``do``:

これにお悩みならば、 ``void`` を再帰的に適用すればよいのです。ネストされた ``do`` へと拡大されたリスト内包を作ります::

  > v = void [void [puts $ str (x,y) | y=1..3] | x=1..2];
  > show v
  v = do (\x -> do (\y -> puts (str (x,y))) (1..3)) (1..2);

(It would be nice to have this handled automatically, but the left-hand side
of a macro definition must be a simple expression, and thus it's not possible
to write a macro which descends recursively into the lambda argument of
``catmap``.)

（これが自動的に扱われるととても良いのですが、しかしマクロ定義の左辺はシンプルな式である必要があります。そのため ``catmap`` のラムダ引数へと再帰的に降りていくマクロを書くことはできません）

Recursive Macros
----------------

再帰マクロ

Macros can also be recursive, in which case they usually consist of multiple
rules and make use of pattern-matching like ordinary function definitions. As
a simple example, let's implement a Pure version of Lisp's quasiquote which
allows you to create a quoted expression from a "template" while substituting
variable parts of the template. (For the sake of brevity, our definition is
somewhat simplified and does not cover some corner cases. See the Pure
distribution for a full version of this example.)

マクロは再帰的であることもできます。この場合、マクロは複数のルールで構成されることが多く、通常の関数と同じようにパターンマッチングを使うこともできます。シンプルな例として、 Lisp の準引用〔quasiquote〕を実装してみましょう。準引用は、「テンプレート」からクォートされた式を作り出し、それと同時にテンプレートの変数部分の代わりとなるものです（簡潔にするため、ここでの定義はいくらか単純化してあり、やっかいなケースをカバーしきれない部分があります。この例の完全版は Pure の配布パッケージを参照して下さい）。

::

  def quasiquote (unquote x)      = x;
  def quasiquote (f@_ (splice x)) = foldl ($) (quasiquote f) x;
  def quasiquote (f@_ x)          = quasiquote f (quasiquote x);
  def quasiquote x                = quote x;

(Note the ``f@_``, which is an anonymous "as" pattern forcing the compiler to
recognize ``f`` as a function variable, rather than a literal function
symbol. See `Head = Function`_ in the `Caveats and Notes`_ section for an
explanation of this trick.)

（ ``f@_`` の部分に注意して下さい。これは匿名の "as" パターンで、コンパイラが ``f`` を、リテラルな関数シンボルではなく function variable と解釈するよう強制します。このトリックの説明は `Caveats and Notes`_ セクション内の `Head = Function`_ を参照して下さい）

The first rule above takes care of "unquoting" embedded subterms. The second
rule "splices" an argument list into an enclosing function application. The
third rule recurses into subterms of a function application, and the fourth
and last rule takes care of quoting the "atomic" subterms. Note that
``unquote`` and ``splice`` themselves are just passive constructor symbols,
the real work is done by ``quasiquote``, using ``foldl`` at runtime to
actually perform the splicing. (Putting off the splicing until runtime makes
it possible to splice argument lists computed at runtime.)

上の例の最初のルールは "unquoting" embedded subterms に配慮したものです。2番目のルールは引数リストを enclosing function application へと "splice" します。3番目のルールは function application の下位項へ再帰します。そして最後となる4番目のルールは "atomic" な下位項をクオートする面倒を見ます。 ``unquote`` と ``splice`` が実のところ消極的なコンストラクタシンボルにすぎないことを覚えておいて下さい。実際の仕事は ``quasiquote`` によって行われます。 ``quasiquote`` は runtime に ``foldl`` を使って splicing を実施します（runtimeまでsplicingをputting off することで、実行時に計算される引数リストをspliceすることが可能になります）。

If we want, we can also add some syntactic sugar for Lisp weenies. (Note that
we cannot have '``,``' for unquoting, so we use '``,$``' instead.)

お望みなら Lisp weenies に糖衣構文を追加することもできます（ Pure には unquote 用の '``,``' が存在しないので、代わりに '``$``' を使います）。

::

  prefix 9 ` ,$ ,@ ;
  def `x = quasiquote x; def ,$x = unquote x; def ,@x = splice x;

Examples:

具体例::

  > `(2*42+2^12);
  2*42+2^12
  > `(2*42+,$(2^12));
  2*42+4096.0
  > `foo 1 2 (,@'[2/3,3/4]) (5/6);
  foo 1 2 (2/3) (3/4) (5/6)
  > `foo 1 2 (,@'args) (5/6) when args = '[2/3,3/4] end;
  foo 1 2 (2/3) (3/4) (5/6)

We mention in passing here that, technically, Pure macros are just as powerful
as (unconditional) term rewriting systems and thus they are
Turing-complete. This implies that a badly written macro may well send the
Pure compiler into an infinite recursion, which results in a stack overflow at
compile time. See the `Caveats and Notes`_ section for information on how to
deal with these by setting the PURE_STACK environment variable.

ちなみに、技術的に言えば Pure のマクロは (unconditional) term rewriting systemと同じくらい強力であり、したがってチューリング完全です。つまり、ダメなマクロを書いてしまうと Pure コンパイラを無限再帰に陥れることにもなり得ます。この場合、コンパイル中にスタックオーバーフローという結果になります。 PURE_STACK 環境変数を設定してこのエラーを取り扱う方法については `Caveats and Notes`_ セクションを参照して下さい。

User-Defined Special Forms
--------------------------

ユーザ定義の特別形

The ``quasiquote`` macro in the preceding subsection also provides an example
of how you can use macros to define your own special forms. This works because
the actual evaluation of macro arguments is put off until runtime, and thus we
can safely pass them to built-in special forms and other constructs which
defer their evaluation at *runtime*. In fact, the right-hand side of a macro
rule may be an arbitrary Pure expression involving conditional expressions,
lambdas, binding clauses, etc. These are never evaluated during macro
substitution, they just become part of the macro expansion (after substituting
the macro parameters).

前節で示した ``quasiquote`` マクロは、あなた独自の特別形を定義するためにマクロを使う方法の例ともなっています。これが機能するのは、マクロの引数に対する評価が実行時まで遅延されるからです。したがって、私たちはマクロの引数を組み込み特別形や他の構造体へと安全に渡すことができ、which defer their evaluation at *runtime*. 実際、マクロルールの右辺は任意の Pure 式であり、条件式、ラムダ、束縛節〔binding clauses〕等々もここに含まれます。これらはマクロの代入まで決して評価されることはなく、単にマクロ展開の一部となります（マクロのパラメータを代入した後に）。

Here is another useful example of a user-defined special form, the macro
``timex`` which employs the system function ``clock`` to report the cpu time
in seconds needed to evaluate a given expression, along with the computed
result:

ここで、ユーザ定義特別形の便利な例をもう一つ示します。 ``timex`` マクロは、システム関数 ``clock`` を使い、与えられた式の評価に必要な CPU タイム（秒）を、計算された結果に沿ってレポートします::

  > using system;
  > def timex x = (clock-t0)/CLOCKS_PER_SEC,y when t0 = clock; y = x end;
  > sum = foldl (+) 0L;
  > timex $ sum (1L..100000L);
  0.43,5000050000L

Note that the above definition of ``timex`` wouldn't work as an ordinary
function definition, since by virtue of Pure's basic eager evaluation strategy
the ``x`` parameter would have been evaluated already before it is passed to
``timex``, making ``timex`` always return a zero time value. Try it!

上の定義では ``timex`` の定義が通常の関数定義として機能しないことに注意して下さい。 Pure の基本的な先行評価ストラテジーの美徳により、 ``x`` パラメータが ``timex`` に渡される前に評価されることはなく、 ``timex`` は常にゼロ時間の値を返します。試してみて！

Here's yet another example, which is handy if you need to trace function
calls. (As of Pure 0.22, the interpreter now has its own built-in debugging
facility, see Debugging_. However, the following macro allows you to trace
functions using your own custom output format, and may thus be useful in
situations where the built-in debugger is not appropriate.)

ここでもう一つ例を。 trace function calls が必要な場合に便利なものです（Pure 0.22 現在、インタープリタは組み込みのデバッグ機能を持つに至っています。 Debugging_ を参照して下さい。しかし、次のマクロを使えば、あなた独自の出力フォーマットを使って関数をトレースすることができるようになります。組み込みデバッガではうまくいかない場面で役に立つかもしれません）。

::

  using system;
  def trace f x y = printf "** exit %s: %s -> %s\n" (str f,str x,str y) $$ y
  when y = printf "** call %s: %s\n: " (str f,str x) $$ gets $$ y end;

This macro is invoked with the function to be traced, the arguments (or
whatever you want to be printed as additional debugging information) and the
actual function call as parameters. (This is a rather simplistic version,
which just prints a prompt on function entry and the final reduction after the
call. You can easily make this as elaborate as you like. E.g., you might want
to keep track of recursive levels and profiling information, add various
interactive commands to selectively enable and disable tracing during the
evaluation, etc.)

このマクロはトレースされる関数、引数（または、あなたが表示したい追加デバッグ情報）、パラメータとなる実際の関数呼び出しを引数として呼び出されます（これはシンプル版であり、関数へのエントリー時にプロンプトを表示し、関数呼び出しの後で the final reduction を表示するだけです。あなたが望むだけ精密なものを作るのも簡単です。例えば、あなたは再帰の深さとプロファイリング情報を記録したいと思ったり、様々な対話型コマンドを追加して、評価中にトレース動作の有効・無効を切り替えられるようにしたいと思うこともあるでしょう）。

We can still make this a bit more convenient by introducing the following
ordinary function definition:

次の通常の関数定義を導入して、これをもう少しだけ便利にすることもできます::

  trace f x = trace f x (f x);

This lets us patch up a call to trace a given function, as shown below,
without having to change the definition of the function at all. This trick
only works with global functions; for local functions you'll have to add an
explicit call of the ``trace`` macro to the local definition yourself. Also
note that the definition above only works with functions taking a single
parameter; see the trace.pure example in the distribution for the full version
which can deal with any number of arguments.

こうすることで、次に示す通り、与えられた関数をトレースするために呼び出しを patch up することができます。関数定義に手を加える必要はありません。このトリックはグローバル変数に対してのみ動作します。ローカル変数をトレースするためには、明確な ``trace`` マクロ呼び出しをローカル定義に追加してやる必要があります。また、上の定義が機能するのはパラメータを1つ取る関数に対してだけであることにも注意して下さい。配布パッケージ内の trace.pure の例には、あらゆる数の引数を扱える完全版がありますので、参照して下さい。

::

  // Uncomment this line to trace calls to the 'fact' function.
  def fact n = trace fact n;
  // Sample function to be traced.
  fact n = if n>0 then n*fact(n-1) else 1;

Here's a trace of the ``fact`` function obtained in this fashion (hit carriage
return after each '``:``' prompt to proceed with the computation):

この方法で取得した ``trace`` 関数のトレースをここで示します（ '``:``' プロンプトが表示されたら、計算を進めるためにリターンキーを押して下さい）::

  > fact 2;
  ** call fact: 2
  : 
  ** call fact: 1
  : 
  ** call fact: 0
  : 
  ** exit fact: 0 -> 1
  ** exit fact: 1 -> 1
  ** exit fact: 2 -> 2
  2

Note that by just removing the macro definition for ``fact`` above, you can
make the function run untraced as usual again. This scheme is quite flexible,
the only real drawback is that you have to explicitly add some code for each
function you want to trace.

``fact`` のためのマクロ定義をただ除去するだけで、トレースを行わず普段通りの状態で再び関数を実行させることができるようになります。このスキームはとてもフレキシブルですが、ただ一つ本当に難点なのは、トレースしたいと思う関数に対していくらかのコードを明確に追加しなければならないところです。

Macro Hygiene
-------------

マクロの衛生学

Pure macros are lexically scoped, i.e., the binding of symbols in the
right-hand-side of a macro definition is determined statically by the text of
the definition, and macro parameter substitution also takes into account
binding constructs, such as ``with`` and ``when`` clauses, in the right-hand
side of the definition. Macro facilities with these pleasant properties are
also known as `hygienic macros`. They are not susceptible to so-called "name
capture," which makes macros in less sophisticated languages bug-ridden and
hard to use. (This is explained in more detail in the `Hygienic Macros`_
section.)

Pure のマクロはレキシカルスコープです。すなわち、マクロ定義の右辺にあるシンボルの束縛は定義のテキストによって静的に決定されます。そしてマクロパラメータの代入もまた、定義右辺にある束縛構造（ ``with`` や ``when`` 節など）を考慮に入れます。これら pleasant properties によるマクロのfacilitiesは `hygienic macros` としても知られています。Theyは、いわゆる "name capture" に感染することがありません。 "name capture" は、あまり洗練されていない言語のマクロを、バグを含みやすく、扱いづらいものにします（ `Hygienic Macros`_ セクションではもっと細かく説明しています）。

Pure macros also have their limitations. Specifically, the left-hand side of a
macro rule must be a simple expression, just like in ordinary function
definitions. This restricts the kinds of expressions which can be rewritten by
a macro. But Pure macros are certainly powerful enough for most common
preprocessing purposes, while still being robust and easy to use.

Pure のマクロもその制限を持っています。特に、通常の関数定義と同じく、マクロルールの左辺はシンプルな式でなければなりません。このことにより、マクロが書き換えることのできる式の種類は限定されます。しかしそれでも Pure のマクロは普通の処理を書くために充分に強力であり、しかも強靱で使いやすいものです。

Declarations
============

宣言

Pure is a very terse language by design. Usually you don't declare much stuff,
you just define it and be done with it. However, there are a few toplevel
constructs which let you declare symbols with special attributes and manage
programs consisting of several source modules:

Pure は設計から非常に簡潔な言語です。たいてい、たくさんの宣言を行うことはなく、ただ宣言してそれを使うだけです。しかし、あなたが特別な属性を持つシンボルを宣言することを許し、複数のソースモジュールから構成されるプログラムを管理する、いくつかのトップレベル構造があります。

* symbol declarations determine "scope" and "fixity" of a symbol;

* シンボル宣言はシンボルの「スコープ」と "fixity" を決定します。

* ``extern`` declarations specify external C functions (described in the
  `C Interface`_ section);

* ``extern`` 宣言は外部C関数を定義します（`C Interface`_ セクションを参照）。

* ``using`` clauses let you include other scripts in a Pure script;

* ``using`` 節で、ある Pure スクリプト内から別のスクリプトをインクルードできます。

* ``namespace`` declarations let you avoid name clashes and thereby make it
  easier to manage large programs consisting of many separate modules.

* ``namespace`` 宣言により名前の衝突を避けることができ、これによってたくさんのモジュールからなる大きなプログラムを容易に管理できます。

Symbol Declarations
-------------------

シンボル宣言

Scope declarations take the following form:

スコープ宣言は次のような形式をとります::

  public symbol ...;
  private symbol ...;

This declares the listed symbols as public or private, respectively. Each
symbol must either be an identifier or a sequence of punctuation characters.
The latter kind of symbols *must* always be declared before use, whereas
ordinary identifiers can be used without a prior declaration in which case
they are declared implicitly and default to public scope, meaning that they
are visible everywhere in a program. An explicit public declaration of
ordinary identifiers is thus rarely needed (unless you want to declare symbols
as members of a specific namespace, see `Namespaces`_ below). Symbols can also
be declared private, meaning that the symbol is visible only in the namespace
it belongs to. This is explained in more detail under `Private Symbols`_ in
the Namespaces_ section below.

これはリストされたシンボルを public または private なものとしてそれぞれ宣言しています。各シンボルは、識別子であるか、ひとつながりの句読点文字である必要があります。後者は使用前に *必ず* 宣言されなければ *なりません* 。それに対して、普通の識別子は前もって宣言する必要はなく、その場合は暗黙のうちに宣言され、デフォルトで public スコープとなり、プログラム内のどこからでも見えるものとなります。そのため、通常の識別子を明示的に public 宣言する必要はほとんどありません（特定の名前空間のメンバーとして変数を宣言したい場合は別です。下部 `Namespaces`_ を参照して下さい）。また、シンボルを private として宣言することもできます。このシンボルは属する名前空間の中からしか見えません。これに関して下部 Namespaces_ セクション内 `Private Symbols`_ で詳細に説明されています。

Note that to declare several symbols in a single declaration, you can list
them all with whitespace in between. The same syntax applies to the other
types of symbol declarations discussed below. (Commas are *not* allowed as
delimiters here, as they may occur as legal symbol constituents in the list of
symbols.) The ``public`` and ``private`` keywords can also be used as a prefix
in any of the special symbol declarations discussed below, to specify the
scope of the declared symbols (if the scope prefix is omitted, it defaults to
``public``).

ホワイトスペースを間に入れてシンボルを並べると、一つの宣言文内で複数のシンボルを宣言できることを覚えておいて下さい。同じ文法は、以下で議論される別種のシンボル宣言にも適用されます（ここでカンマは区切り文字として許され *ません* 。シンボルを構成する合法な要素としてカンマがシンボルリスト内に表れる可能性があるからです）。また ``public`` と ``private`` キーワードは、以下で議論される特別シンボル宣言のプレフィクスとして使うこともでき、宣言されるシンボルのスコープを決定します（スコーププレフィクスが省略された場合は ``public`` がデフォルトとなります）。

The following "fixity" declarations are available for introducing special
operator and constant symbols. This changes the way that these symbols are
parsed and thus provides you with a limited means to extend the Pure language
at the lexical and syntactical level.

次の "fixity" 宣言は、特別な演算子シンボルや定数シンボルを導入するためのものです。これはシンボルが解析される方法を変え、 Pure 言語をlexicalおよびsyntacticalなレベルにおいて拡張するための限定された手段を提供します。

Operator declarations: ``infix level symbol ...;``
    Pure provides you with a theoretically unlimited number of different
    precedence levels for user-defined infix, prefix and postfix operators.
    Precedence levels are numbered starting at 0; larger numbers indicate
    higher precedence. (For practical reasons, the current implementation does
    require that precedence numbers can be encoded as 24 bit unsigned machine
    integers, giving you a range from 0 to 16777215, but this should be large
    enough to incur no real limitations on applications. Also, the operator
    declarations in the prelude have been set up to leave enough "space"
    between the "standard" levels so that you can easily sneak in new operator
    symbols at low, high or intermediate precedences.)

演算子宣言: ``infix level symbol ...;``
    Pure は理論的には無数の異なる優先レベルを、挿入・前置・後置演算子に対して提供します。優先レベルは 0 から始まり、大きい数値ほど優先度が高いことを示します（実用上の理由から、現在の実装では優先度の数値は 24 ビット符号なし machine integer でエンコードされ、 0 から 16777215 までの範囲を使うことができます。しかしアプリケーションにおいて事実上制限なく使えるほどの大きさではあるでしょう。また、 prelude における演算子宣言は「標準」レベル同士の間に十分な「余地」を残して行われます。そのため、優先度が低・高・中間のどのレベルにおいても新しい演算子を〔「標準」演算子の隙間に〕簡単にすべり込ませることができます）。

    On each precedence level, you can declare (in order of increasing
    precedence) ``infix`` (binary non-associative), ``infixl`` (binary
    left-associative), ``infixr`` (binary right-associative), ``prefix``
    (unary prefix) and ``postfix`` (unary postfix) operators. For instance,
    here is a typical excerpt from the prelude (the full table can be found in
    the Prelude_ section of the `Pure Library Manual`_):

    各優先レベルにおいて、あなたは（優先度昇順に） ``infix`` （二項、結合なし）、 ``infixl`` （二項、左結合）、 ``infixr`` （二項、右結合）、 ``prefix`` （一項、前置）、 ``postfix`` （一項、後置） 演算子を宣言できます。例えば、これは prelude から抜粋した典型的な例です（完全なテーブルは `Pure Library Manual`_ の Prelude_ セクションにあります）::

      infix  1700 < > <= >= == ~= ;
      infixl 2100 + - ;
      infixl 2200 * / div mod ;
      infixr 2400 ^ ;
      prefix 2500 # ;

    .. _Prelude: purelib.html#prelude

    Instead of denoting the precedence by an explicit integer value, you can
    also specify an existing operator symbol enclosed in parentheses. Thus the
    following declaration gives the ``++`` operator the same precedence as
    ``+``:

    整数で優先度を明示する代わりに、すでに存在する演算子シンボルを丸括弧で囲ったものを指定に使うこともできます。したがって次の宣言では、 ``++`` 演算子に ``+`` と同じ優先度を与えています::

      infixl (+) ++ ;

    The given symbol may be of a different fixity than the declaration, but it
    must have a proper precedence level (i.e., it must be an infix, prefix or
    postfix symbol). E.g., the following declaration gives ``^^`` the same
    precedence level as the infix ``^`` symbol, but turns it into a postfix
    operator:

    与えられたシンボルが宣言と異なる fixity となることも可能ですが、しかしそれでも適切な優先度レベル〔a proper precedence level〕を持たなければなりません（つまり infix か prefix か postfix のどれかでなければなりません）。例えば、次の宣言では ``^^`` に挿入演算子シンボル ``^`` と同じ優先度を与えていますが、 ``^^`` を後置演算子に変えています::

      postfix (^) ^^ ;

Outfix symbol declarations: ``outfix left right ...;``
    Pure also provides unary outfix operators, which work like in Wm Leler's
    constraint programming language Bertrand_. Outfix operators let you define
    your own bracket structures. The operators must be given as pairs of
    matching left and right symbols (which must be distinct). For instance:

アウトフィクスシンボル宣言: ``outfix left right ...;``
    Pure は単項のアウトフィクス演算子〔unary outfix operators〕を定義する機能も提供します。これは Wm Leler のconstraint programming language Bertrand_ に似た動作を行います。あなたはアウトフィクス演算子を使って独自のブラケット構造を定義できます。演算子は、左右対応する記号のペア（それぞれ別の記号でなければならない）として与えられる必要があります。例えば::

      outfix |: :| BEGIN END;

    After this declaration you can write bracketed expressions like ``|:x:|``
    or ``BEGIN foo, bar END``. These are always at the highest precedence
    level (i.e., syntactically they work like parenthesized expressions). Just
    like other operators, you can turn outfix symbols into ordinary functions
    by enclosing them in parentheses, but you have to specify the symbols in
    matching pairs, such as ``(BEGIN END)``.

    この宣言の後、あなたは ``|:x:|`` や ``BEGIN foo, bar END`` のように括弧型の演算子を書くことができます。これらは常に最高の優先レベルとなります（すなわち、統語的には丸括弧で囲われた式のように動作します）。他の演算子と同じように、アウトフィクス演算子を丸括弧で囲うと、それを通常の関数へと変えることができますが、このときのシンボルは ``(BEGIN END)`` のようにペアを対応させて書かなければいけません。

Constant symbol declarations: ``nonfix symbol ...;``
    Pure also has a notation for "nullary" operators, i.e., "operators without
    operands", which are used to denote special constants. These are
    introduced using a ``nonfix`` declaration, e.g.:

定数シンボル宣言: ``nonfix symbol ...;``
    Pure はまた「無項」演算子〔"nullary" operators〕を持っています。すなわち「オペランドのない演算子」であり、特別な定数を表すのに使われます。これらは ``nonfix`` 宣言を使って導入されます。例えば::

      nonfix red green blue;

    Syntactically, these work just like ordinary identifiers, so they may
    stand whereever an identifier is allowed (no parentheses are required to
    "escape" them). The difference to ordinary identifiers is that nonfix
    symbols are always interpreted as literals, even if they occur in a
    variable position on the left-hand side of a rule. So, with the above
    declaration, you can write something like:

    統語上は、これらは通常の演算子と同じように動作します。なので、通常の識別子を置ける場所ならどこにでも置けます（「エスケープ」するのに丸括弧は必要ありません）。通常の識別子との違いは、ノンフィクスシンボルが常にリテラルとして解釈され、たとえルール左辺の変数の位置に表れてもそう解釈されるという点です。なので、上の宣言を行うとこんな風に書けます::

      > foo x = case x of red = green; green = blue; blue = red end;
      > map foo [red,green,blue];
      [green,blue,red]

    Thus nonfix symbols are pretty much like nullary constructor symbols in
    languages like Haskell. Non-fixity is just a syntactic attribute,
    however. Pure doesn't enforce that such values are really "constant", so
    you can still write a "constructor equation" like the following:

    したがってノンフィクスシンボルは、 Haskell のような言語における無項コンストラクタシンボルとかなり似たものです。しかし Non-fixity は単に統語上の属性です。 Pure はそうした値が本当に "constant" なものであることを強制しません。なので、あなたはまだ "constructor equation" を次のように書くことができます::

      > red = blue;
      > map foo [red,green,blue];
      [blue,blue,blue]

Examples for all types of symbol declarations can be found in the prelude
which declares a bunch of standard (arithmetic, relational, logical) operator
symbols as well as the list and pair constructors '``:``' and '``,``', and a
few nonfix symbols (mostly for denoting different kinds of exceptions).

全タイプのシンボル宣言の例を prelude 内で見つけることができます。 prelude では一連の標準（算術／関係／論理）演算子や、リストコンストラクタ '``:``' 、 ペアコンストラクタ '``,``' 、さらにいくつかのノンフィクスシンボルが（たいていは異なる種類の例外を示すために）定義されています。

One final thing worth noting here is that unary minus plays a special role in
the syntax. Like in Haskell and following mathematical tradition, unary minus
is the only prefix operator symbol which is also used as an infix operator,
and is always on the same precedence level as binary minus, whose precedence
may be chosen freely in the prelude. (The minus operator is the only symbol
which gets that special treatment; all other operators must have distinct
lexical representations.) Thus, with the standard prelude, ``-x+y`` will be
parsed as ``(-x)+y``, whereas ``-x*y`` is the same as ``-(x*y)``. Also note
that the notation ``(-)`` always denotes the binary minus operator; the unary
minus operation can be denoted using the built-in ``neg`` function.

ここに書いておくべき最後の一つは、単項のマイナスが文法上持つ特別な意味についてです。 Haskell と同じように、また数学の伝統を踏襲して、単項のマイナスは挿入演算子としても使われる唯一の前置演算子であり、二項のマイナスと常に同じ優先レベルとなります。二項マイナス演算子の優先度は prelude 内で自由に選ぶことができます（この特別扱いを受けるのはマイナス演算子だけです。他の全演算子は異なるlexical representationsを持たなければなりません）。したがって、標準 prelude を使う場合、 ``-x+y`` は ``(-x)+y`` として解析されます。それに対して ``-x*y`` は ``-(x*y)`` と同じです。また ``(-)`` が常に二項演算子を表すことも覚えておいて下さい。単項マイナス演算は組み込み関数 ``neg`` を使って表すことができます。

Modules and Imports
-------------------

モジュールとインポート

While Pure doesn't offer separate compilation, the ``using`` declaration
provides a simple but effective way to assemble a Pure program from several
source modules. It takes the following form (note that in contrast to symbol
declarations, the comma is used as a delimiter symbol here):

Pure は分割コンパイルを提供していませんが、 ``using`` 宣言は複数のソースモジュールを一つのプログラムへまとめ上げるシンプルかつ効果的な方法を提供します。 ``using`` 宣言は次のような形式をとります（シンボル宣言とは対照的に、ここではカンマを区切り文字として使うことに注意して下さい）::

  using name, ...;

This causes each given script to be included in the Pure program at the given
point (if it wasn't already included before), which makes available all the
definitions of the included script in your program. Note that each included
script is loaded only *once*, when the first ``using`` clause for the script
is encountered. Nested imports are allowed, i.e., an imported module may
itself import other modules, etc. A Pure program then basically is the
concatenation of all the source modules given as command line arguments, with
other modules listed in ``using`` clauses inserted at the corresponding source
locations.

この節は、与えられた各スクリプトを、そのプログラムの宣言が置かれた位置にインクルードします（その前ですでに組み込まれていない場合）。これにより、インクルードされたスクリプトの全定義をあなたのプログラム内で使用できるようになります。インクルードされる各スクリプトは、そのスクリプトが指定された ``using`` 節が初めて現れたときの *一度だけ* しか読み込まれない [#]_ ことを忘れないで下さい。ネストされたインポートを使うこともできます。すなわち、インポートされたモジュールが内部で別のモジュールをインポートすることなどが可能です。そして Pure プログラムは基本的に、コマンドライン引数で与えられたソースモジュールがすべて連結され、 ``using`` 節にリストされた他のモジュールがソース内の指定された位置に挿入されたもの、ということになります。

.. [#] 訳注：同じスクリプトを複数回 using しようとしても、読み込まれるのは最初の一度だけ。

(The ``using`` clause also has an alternative form which allows dynamic
libraries to be loaded, this will be discussed in the `C Interface`_ section.)

（ ``using`` 節は、動的ライブラリを読み込むための形式も持っています。これについては `C Interface`_ セクションで詳しく議論されています）

For instance, the following declaration causes the math.pure script from the
standard library to be included in your program:

例えば、次の宣言節は math.pure スクリプトを標準ライブラリからあなたのスクリプトへインクルードします::

  using math;

You can also import multiple scripts in one go:

一度に複数のモジュールスクリプトをインポートすることもできます::

  using array, dict, set;

Moreover, Pure provides a notation for qualified module names which can be
used to denote scripts located in specific package directories, e.g.:

さらに、 Pure は修飾されたモジュール名を指定する機能も提供しています。これは、特定のパッケージディレクトリ内に置かれたスクリプトを指定するために使うものです。例えば::

  using examples::libor::bits;

In fact this is equivalent to the following ``using`` clause which spells out
the real filename of the script between double quotes (the ``.pure`` suffix
can also be omitted in which case it is added automatically):

実のところ、この指定は次の ``using`` 節と等価です。次の ``using`` 節では、ダブルクォートの間に実際のスクリプトファイル名を正確に書き記しています（ ``.pure`` サフィックスは省略することができます。省略時は自動的に付加されます）::

  using "examples/libor/bits.pure";

Both notations can be used interchangeably; the former is usually more
convenient, but the latter allows you to denote scripts whose names aren't
valid Pure identifiers.

両記法の間には互換性があります。普段使うには前者のほうが便利ですが、後者の場合は、有効な Pure 識別子ではない名前 [#]_ を持っているスクリプトを指定することができます。

.. [#] ".pure" で終わっていないファイル名ということだろう。

Script identifiers are translated to the corresponding filenames by replacing
the '``::``' symbol with the pathname separator '``/``' and tacking on the
'``.pure``' suffix. The following table illustrates this with a few examples.

スクリプト識別子は、それに対応するファイル名へと変換されます。その際は '``::``' 記号をパスセパレータ '``/``' に置換し、末尾に '``.pure``' サフィックスを付加します。次の表でいくつかの例を示します。

===========================  ===============================
Script identifier            Filename
===========================  ===============================
``math``                     ``"math.pure"``
``examples::libor::bits``    ``"examples/libor/bits.pure"``
``::pure::examples::hello``  ``"/pure/examples/hello.pure"``
===========================  ===============================

Note the last example, which shows how an absolute pathname can be denoted
using a qualifier starting with '``::``'.

最後の例では、 '``::``' から始まる修飾子を使って絶対パス名を指定する方法を示しています。

Unless an absolute pathname is given, the interpreter performs a search to
locate the script. The search algorithm considers the following directories in
the given order:

絶対パス名が指定された場合を除き、インタープリタはスクリプトが置かれている位置で検索を行います。検索アルゴリズムは次のディレクトリを、以下に並ぶ順に考慮します:

* the directory of the current script, which is the directory of the script
  containing the ``using`` clause, or the current working directory if the
  clause was read from standard input (as is the case, e.g., in an interactive
  session);

* 現在のスクリプトがあるディレクトリ。これには ``using`` 節で指定されたディレクトリを含む。 ``using`` 節が標準入力から読み込まれた場合にはカレントワーキングディレクトリを含む（as is the case, 例えば対話セッションにおいて）。

* the directories named in -I options on the command line (in the given
  order);

* コマンドラインの -I オプションで指定されたディレクトリ（与えられた順に検索）。

* the colon-separated list of directories in the PURE_INCLUDE environment
  variable (in the given order);

* 環境変数 PURE_INCLUDE 内で指定された、コロン区切りのディレクトリリスト（与えられた順に検索）。

* finally the directory named by the PURELIB environment variable.

* 最後に、環境変数 PURELIB で指定されたディレクトリ。

Note that the current working directory is not searched by default (unless the
``using`` clause is read from standard input), but of course you can force
this by adding the option -I. to the command line, or by including '.' in the
PURE_INCLUDE variable.

カレントワーキングディレクトリはデフォルトでは検索されないことに注意して下さい（ただし ``using`` 節が標準入力から読まれた場合は別）。しかし -I. オプションをコマンドラインで指定した場合は、もちろん検索を強制することができます。

The directory of the current script (the first item above) can be skipped by
specifying the script to be loaded as a filename in double quotes, prefixed
with the special ``sys:`` tag. The search then starts with the "system"
directories (-I, PURE_INCLUDE and PURELIB) instead. This is useful, e.g., if
you want to provide your own custom version of a standard library script which
in turn imports that library script. For instance, a custom version of
math.pure might employ the following ``using`` clause to load the math.pure
script from the Pure library:

カレントスクリプトのディレクトリ（上のリストの最初のもの）読み込みをスキップすることも可能です。そのスクリプトのファイル名に特別タグ ``sys:`` をプレフィクスとして付加し、ダブルクォートで囲って指定するようにします。すると、検索が "system" ディレクトリ（ -I 、 PURE_INCLUDE 、 PURELIB ）から開始されます。この動作は、例えば、あなたが独自カスタム版の標準ライブラリスクリプトを提供したいと思い、そのライブラリ内で標準ライブラリスクリプトをインポートしたい場合に便利です。具体例として、カスタム版の math.pure は次の ``using`` 節を使い、 Pure ライブラリから math.pure を読み込みます::

  using "sys:math";
  // custom definitions go here
  log2 x = ln x/ln 2;

The interpreter compares script names (to determine whether two scripts are
actually the same) by using the *canonicalized* full pathname of the script,
following symbolic links to the destination file (albeit only one level). Thus
different scripts with the same basename, such as foo/utils.pure and
bar/utils.pure can both be included in the same program (unless they link to
the same file).

インタープリタはスクリプト名を（2つのスクリプトがまったく同じかどうか判断するため）比較します。その際は、シンボリックリンクを追って（ただし1段階のみ）対象ファイル名を探し、スクリプトの *正規化された* フルパス名〔canonicalized full pathname of the script〕を使って判断します。したがって、同じbasenameを持った異なるスクリプト（例えば foo/utils.pure と bar/utils.pure ）の両者を、同じプログラムにインクルードすることができます（両者が同じファイルへとリンクされていれば別です）。

More precisely, canonicalizing a pathname involves the following steps:

もっと正確に言うと、パス名を正規化する過程は以下のステップを含んでいます:

* relative pathnames are expanded to absolute ones, using the search rules
  discussed above;

* 相対パスを絶対パスへ展開する。その際は上で議論したルールが使われる。

* the directory part of the pathname is normalized to the form returned by the
  ``getcwd`` system call;

* パス名の一部となるディレクトリは ``getcwd`` システムコールが返す形式へと正規化される。

* the ".pure" suffix is added if needed;

* 必要ならば ".pure" サフィックスが付加される。

* if the resulting script name is actually a symbolic link, the interpreter
  follows that link to its destination, albeit only one level. (This is only
  done on Unix-like systems.)

* 結果として得られたスクリプト名がシンボリックリンクであれば、インタープリタはそのリンクを追って対象ファイル名を得る。ただし1段階しか追わない。（これは Unix-like なシステムでのみ行われる）

The directory of the canonicalized pathname is also used when searching other
scripts included in a script. This makes it possible to have an executable
script with a shebang line in its own directory, which is then executed via a
symbolic link placed on the system PATH. In this case the script search
performed in ``using`` clauses will use the real script directory and thus
other required scripts can be located there. This is the recommended practice
for installing standalone Pure applications in source form which are to be run
directly from the shell.

正規化されたパス名のディレクトリは、あるスクリプト内でインクルードされる他のスクリプトを検索する際にも使われます。これにより、 shebang 行を持つ実行可能なスクリプトを its own directory に置いておき、システムの PATH に置かれたシンボリックリンクを通じてそのファイルを実行することも可能になります。この場合、 ``using`` 節で行われるスクリプト検索は実際にスクリプトが置かれているディレクトリを使うようになり、したがって必要な他のスクリプトも同じ場所に置くことができます。これは、ソースのままシェルから実行されるスタンドアローンの Pure アプリケーションをインストールする場合に推奨されるプラクティスです。

Namespaces
----------

名前空間

To facilitate modular development, Pure also provides namespaces as a means to
avoid name clashes between symbols, and to keep the global namespace tidy and
clean. Namespaces serve as containers holding groups of related identifiers
and other symbols. Inside each namespace, symbols must be unique, but the same
symbol may be used to denote different objects (variables, functions, etc.) in
different namespaces. (Pure's namespace system was heavily inspired by C++ and
works in a very similar fashion. So if you know C++ you should feel right at
home and skimming this section to pick up Pure's syntax of the namespace
constructs should be enough to start using it.)

モジュールを使った開発を容易にするため、 Pure は名前空間を提供し、シンボル同士の名前衝突を避け、グローバル名前空間を整頓されていて汚れもない状態に保つ手段としています。名前空間は、関連する識別子や他のシンボルのグループを保持するコンテナとして働きます。各名前空間内では、シンボルは一意でなければなりませんが、名前空間が異なれば、同じシンボルで異なるオブジェクト（変数や関数など）を指し示すことが可能です（ Pure の名前空間システムは C++ から非常に強く影響を受けており、かなり同じように動作します。なので、あなたが C++ を知っているなら、ここではリラックスして、このセクションを軽く眺めながら Pure の名前空間構造の文法を拾い読みするだけで、充分使い始めることができるでしょう）。

The global namespace is always available. By default, new symbols are created
in this namespace, which is also called the `default namespace`. Additional
namespaces can be created with the ``namespace`` declaration, which also
switches to the given namespace (makes it the *current* namespace), so that
new symbols are then created in that namespace rather than the default
one. The current namespace also applies to all kinds of symbol declarations,
including operator and constant symbol declarations, as well as ``extern``
declarations (the latter are described in the `C Interface`_ section).

グローバル名前空間は常に利用可能です。デフォルトでは、新しいシンボルはこの名前空間の中に作られます。この名前空間は別名 `default namespace` とも呼ばれます。追加の名前空間は ``namespace`` 宣言で作ることができます。このとき与えられた名前空間への変更が行われ（それを *カレント* 名前空間として）、以後作られる新しいシンボルはその名前空間内に作られることとなり、デフォルト名前空間内ではなくなります。カレント名前空間は全種類のシンボル宣言に対して適用されます。演算子シンボルや定数シンボルの宣言だけでなく、 ``extern`` 宣言も含まれます（ extern 宣言は `C Interface`_ セクションに説明があります）。

The basic form of the ``namespace`` declaration has the following syntax
(there's also a "scoped" form of the ``namespace`` declaration which will be
discussed in `Scoped Namespaces`_ at the end of this section):

``namespace`` 宣言の基本的な形式は次のような文法を持っています（ "scoped" な形式の ``namespace`` 宣言もありますが、それについてはこのセクションの最後 `Scoped Namespaces`_ で議論されます）::

  namespace name;
  // declarations and definitions in namespace 'name'
  // 'name' 名前空間内での宣言と定義
  namespace;

The second form switches back to the default namespace. For instance, in order
to define two symbols with the same print name ``foo`` in two different
namespaces ``foo`` and ``bar``, you can write:

2番目の形式では、デフォルト名前空間へ復帰しています。例えば、同じ ``foo`` という名前を持つシンボル2つを、異なる名前空間 ``foo`` と ``bar`` で宣言するには、次のように書けます::

  namespace foo;
  foo x = x+1;
  namespace bar;
  foo x = x-1;
  namespace;

We can now refer to the symbols we just defined using `qualified symbols` of
the form ``namespace::symbol``:

``namespace::symbol`` という形式をもつ `修飾子つきシンボル` を使って、今まさに宣言を行いましたが、これで私たちはこれらのシンボルを参照できます::

  > foo::foo 99;
  100
  > bar::foo 99;
  98

This avoids any potential name clashes, since the qualified identifier
notation always makes it clear which namespace the given identifier belongs
to.

これにより、あらゆる潜在的な名前衝突を避けられます。修飾子つき識別子の記法により、与えられた識別子がどの名前空間に属すのか、常に明確になるわけです。

A namespace can be "reopened" at any time to add new symbols and definitions
to it. This allows namespaces to be created that span several source
modules. You can also create several different namespaces in the same module.

名前空間はいつでも「再開」して新しいシンボルや定義を追加することができます。なので、名前空間は複数のソースモジュールをまたいで作ることができます。また、一つのモジュールに複数の異なる名前空間を作ることも可能です。

Similar to the ``using`` declaration, a ``namespace`` declaration accepts
either identifiers or double-quoted strings as namespace names. E.g., the
following two declarations are equivalent:

``using`` 宣言と同じように、 ``namespace`` 宣言も、識別子とダブルクォートに挟まれた文字列の両方を名前空間名として受け入れます。例えば、次の二つの宣言は等価です::

  namespace foo;
  namespace "foo";

The latter form also allows more descriptive labels which aren't identifiers,
e.g.:

後者の形式では、もっと説明的なラベルを使うこともできます。これは識別子にはなりません::

  namespace "Private stuff, keep out!";

Note that the namespace prefix in a qualified identifier must be a legal
identifier, so it isn't possible to access symbols in namespaces with such
descriptive labels in a direct fashion. The only way to get at the symbols in
this case is to use a ``namespace`` or ``using namespace`` declaration (for
the latter see `Using Namespaces`_ below).

修飾子つき識別子の前部分に置かれる名前空間プレフィクスは合法の識別子でなければなりません。なので、このように説明的なラベルを持つ名前空間内のシンボルに直接的なやり方でアクセスすることはできません。このような場合にそのシンボルへ到達する唯一の方法は、 ``namespace`` または ``using namespace`` 宣言を行うことです（後者については下の `Using Namespaces`_ を参照）。

Using Namespaces
~~~~~~~~~~~~~~~~

Using Namespaces

Since it is rather inconvenient if you always have to write identifiers in
their qualified form outside of their "home" namespace, Pure allows you to
specify a list of *search* namespaces which are used to look up symbols not in
the default or the current namespace. This is done with the ``using
namespace`` declaration, which takes the following form:

ある識別子を、それが「ホーム」としている名前空間の外で書くとき、いつも修飾子つきの形式で書かなければならないとしたら、いささか不便です。 Pure では *検索用* 名前空間のリストを定義することができ、デフォルト名前空間やカレント名前空間内に存在しないシンボルを探すために使われます。これを設定するには ``using namespace`` 宣言を行うのですが、次のような形式です::

  using namespace name1, name2, ...;
  // ...
  using namespace;

(As with ``namespace`` declarations, the second form without any namespace
arguments gets you back to the default empty list of search namespaces.)

（ ``namespace`` 宣言のときと同じように、2つめの形式には名前空間引数が一つもありませんが、これにより検索用名前空間のリストを空にし、デフォルトの状態へ戻しています）

For instance, consider this example:

例えば、この例を考えてみて下さい::

  namespace foo;
  foo x = x+1;
  namespace bar;
  foo x = x-1;
  bar x = x+1;
  namespace;

The symbols in these namespaces can be accessed unqualified as follows:

これらの名前空間内のシンボルは、次のように修飾子なしでアクセスできます::

  > using namespace foo;
  > foo 99;
  100
  > using namespace bar;
  > foo 99;
  98
  > bar 99;
  100

This method is often to be preferred over opening a namespace with the
``namespace`` declaration, since ``using namespace`` only gives you "read
access" to the imported symbols, so you can't accidentally mess up the
definitions of the namespace you're using. Another advantage is that the
``using namespace`` declaration also lets you search multiple namespaces at
once:

この方法はしばしば、 ``namespace`` 宣言を使って名前空間を開始した上で実行されます。なぜなら ``using namespace`` は、インポートされたシンボルに対する「読み込み専用アクセス権」だけをあなたに与えるからです。なので、現在使っている〔using している〕名前空間の定義を、あなたが誤ってめちゃくちゃにしてしまうことはあり得ません。もう一つの利点は、 ``using namespace`` 宣言で複数の名前空間を同時に検索対象とすることが可能になる点です::

  using namespace foo, bar;

Be warned, however, that this brings up the very same issue of name clashes
again:

しかし、これにより名前衝突とほとんど同じ問題が再び起きうることも忘れないで下さい::

  > using namespace foo, bar;
  > foo 99;
  <stdin>, line 15: symbol 'foo' is ambiguous here

In such a case you'll have to resort to using namespace qualifiers again, in
order to resolve the name clash:

このような場合には、再び名前空間修飾子を使い、名前衝突を解決しなければなりません::

  > foo::foo 99;
  100

To avoid this kind of mishap, you can also selectively import just a few
symbols from a namespace instead. This can be done with a declaration of the
following form:

このような災難を避けるため、これまでの方法の代わりに、名前空間から少数のシンボルだけを選んでインポートすることもできます。次のような形式の宣言で行います::

  using namespace name1 ( sym1 sym2 ... ), name2 ... ;

As indicated, the symbols to be imported can optionally be placed as a
whitespace-delimited list inside parentheses, following the corresponding
namespace name. For instance:

これが示す通り、名前空間名の後に、インポートされるべきシンボルのリストを、丸括弧の間にホワイトスペースで区切って書くことで、選択的にインポートできます。例えば::

  > using namespace foo, bar (bar);
  > foo 99;
  100
  > bar 99;
  100
  > bar::foo 99;
  98

Note that now we have no clash on the ``foo`` symbol any more, because we
restricted the import from the ``bar`` namespace to the ``bar`` symbol, so
that ``bar::foo`` has to be denoted with a qualified symbol now.

もはや ``foo`` シンボルの衝突は起こらなくなりました。インポート対象を ``bar`` 名前空間ではなくし、その中の ``bar`` シンボルだけに限定したからです。その結果、ここで ``bar::foo`` を指示するため修飾子つきシンボルを使う必要も生じています。

Symbol Lookup and Creation
~~~~~~~~~~~~~~~~~~~~~~~~~~

シンボル検索と作成

Pure's rules for looking up and creating symbols are fairly straightforward
and akin to those in other languages featuring namespaces. However, there are
some intricacies involved, because the rewriting rule format of definitions
allows "referential" use of symbols not only in the "body" (right-hand side)
of a definition, but also in the left-hand side patterns. We discuss this in
detail below.

Pure がシンボルを検索・作成するルールはとても素直なもので、名前空間を備える他の言語とも似ています。しかし、いくらか複雑な部分もあります。というのは、定義における書き替えルールのフォーマットはシンボルを "referential" に使うことができ、それは定義の "body" （右辺）内だけでなく、左辺のパターン内でも同じだからです。この点を以下で詳しく議論します。

The compiler searches for symbols first in the current namespace (if any),
then in the currently active search namespaces (if any), and finally in the
default (i.e., the global) namespace, in that order. This automatic lookup can
be bypassed by using an *absolute* namespace qualifier of the form
``::foo::bar``. In particular, ``::bar`` always denotes the symbol ``bar`` in
the default namespace, while ``::foo::bar`` denotes the symbol ``bar`` in the
``foo`` namespace. (Normally, the latter kind of notation is only needed if
you have to deal with nested namespaces, see `Hierarchical Namespaces`_
below.)

コンパイラはまず（もしあるなら）カレント名前空間のシンボルを探します。その後、（もしあるなら）現在アクティブな名前空間を探します。最後に、デフォルト名前空間（＝グローバル名前空間）を探します。この自動探索は ``::foo::bar`` 形式の *絶対* 名前空間修飾子を使ってバイパスすることができます。特に ``::bar`` は常にデフォルト名前空間のシンボル ``bar`` を示し、 ``::foo::bar`` は ``foo`` 名前空間内の ``bar`` を示します（通常、後者の記法はネストされた名前空間を扱う場合のみ必要となるものです。詳しくは下部 Namespaces_ を参照）。

If no existing symbol is found, a new symbol is created automatically, by
implicitly declaring a public symbol with default attributes. New
*unqualified* symbols are always created in the current namespace, while new
*qualified* symbols are created in the namespace given by the namespace prefix
of the symbol. However, note that in the latter case the compiler always
checks that the given namespace prefix matches the current namespace:

もしシンボルが存在しなかったら、新しいシンボルが自動的に作られます。このとき、デフォルトの属性を持つ public なシンボルが暗黙のうちに宣言されます。 *修飾子なしの* 新しいシンボルは常にカレント名前空間に作られ、 *修飾子つきの* 新しいシンボルはシンボルの名前空間プレフィクスで与えられた名前空間に作られます。しかし後者の場合、コンパイラは、与えられた名前空間がカレント名前空間にマッチするかどうか常にチェックするということを覚えておいて下さい::

  > namespace foo;
  > namespace;
  > foo::bar x = 1/x;
  <stdin>, line 3: undeclared symbol 'foo::bar'

Thus it's only possible to introduce a new symbol in a given namespace if that
namespace is the current one. These error messages are somewhat annoying, but
they provide at least some protection against typos and other silly mistakes
and prevent you from accidentally clobbering the contents of other
namespaces. To make these errors go away it's enough to just declare the
symbols in their proper namespaces.

したがって、与えられた名前空間に新しいシンボルを導入することができるのは、その名前空間がカレント名前空間である場合だけだということです。この種のラーメッセージはいささかわずらわしいですが、少なくともミスタイプなどのバカバカしい間違いや、他の名前空間の中身を意図せずぶん殴ってしまうことを防いでくれます。このエラーを遠ざけるには、そのシンボルにとって適切な名前空間をきちんと宣言するだけで充分なのです。

New symbols are also created if a global unqualified (and yet undeclared)
symbol is being "defined" in a rewriting rule or ``let``/``const`` definition,
even if a symbol with the same print name from another namespace is already
visible in the current scope. To distinguish "defining" from "referring" uses
of a global symbol, Pure uses the following (purely syntactic) notions:

また、修飾子なしのグローバルな（かつ未宣言の）シンボルが、書き替えルール内や ``let``/``const`` 定義内で「定義され」ている場合、新しいシンボルが作られます。他の名前空間に属しながら同じ表示名を持つシンボルが現在のスコープ内でvisibleであったとしても、作られます。グローバルシンボルの「定義する」ことと「参照する」ことを区別するため、 Pure では次のような（純粋に統語的な）記法を使います:

* A `defining occurrence` of a global *function* or *macro symbol* is any
  occurrence of the symbol as the *head symbol* on the left-hand side of a
  rewriting rule.

* グローバルな *関数* またはグローバルな *マクロシンボル* の `定義の出現` 〔 `defining occurrence` 〕は、書き替えルール左辺において、シンボルが *先頭シンボル* 〔 *head symbol* 〕として出現することである。

* A `defining occurrence` of a global *variable* or *constant symbol* is any
  occurrence of the symbol in a *variable position* (as given by the "head =
  function" rule, cf. `Parameters in Equations`_) on the left-hand side of a
  ``let`` or ``const`` definition.

* グローバル *変数* またはグローバル *定数シンボル* の `定義の出現` は、 ``let`` または ``const`` 定義の左辺において、シンボルが *変数の位置* に現れることである（「先頭＝関数」ルールに従っている。 cf. `Parameters in Equations`_ ）。

* All other occurrences of global symbols on the left-hand side, as well as
  *all* symbol occurrences on the right-hand side of a definition are
  `referring occurrences`.

* 定義左辺における他のあらゆるグローバルシンボルの出現、および定義右辺における *あらゆる* シンボルの発生は、 `参照的な出現` である。

The following example illustrates these notions:

次の例がこれらの記法を説明してくれます::

  namespace foo;
  bar (bar x) = bar x;
  let x,y = 1,2;
  namespace;

Here, the first occurrence of ``bar`` on the left-hand side ``bar (bar x)`` of
the first rule is a *defining* occurrence, as are the occurrences of ``x`` and
``y`` on the left-hand side of the ``let`` definition. Hence these symbols are
created as new symbols in the namespace ``foo``. On the other hand, the other
occurrences of ``bar`` in the first rule, as well as the '\ ``,``\ ' symbol on
the left-hand side of the ``let`` definition are *referring* occurrences. In
the former case, ``bar`` refers to the ``bar`` symbol defined by the rule,
while in the latter case the '\ ``,``\ ' operator is actually declared in the
prelude and thus imported from the global namespace.

この場合、最初のルールの左辺 ``bar (bar x)`` 内にある最初の ``bar`` は *定義的な* 出現であり、 ``let`` 定義内にある ``x`` と ``y`` も同様です。したがって、これらのシンボルは新たなシンボルとして名前空間 ``foo`` 内に作られます。それに対して、最初のシンボルで現れているもう一つの ``bar`` は、 ``let`` 定義の左辺にある '\ ``,``\ ' と同様、 *参照的な* 出現です。前者 [#]_ の場合、 ``bar`` はそのルールによって定義された ``bar`` シンボルを指示しています。後者の場合、 '\ ``,``\ ' 演算子が実際に定義されているのは prelude 内であり、グローバル名前空間からインポートされています。

.. [#] 最初のルール左辺にある3つの bar のうち2番目の（＝丸括弧内にある） ``bar`` のこと。

Note that special operator (and nonfix) symbols *always* require an explicit
declaration. This works as already discussed in the `Symbol Declarations`_
section, except that you first switch to the appropriate namespace before
declaring the symbols. For instance, here is how you can create a new ``+``
operation which multiplies its operands rather than adding them:

特別な演算子の（およびノンフィクスの）シンボルは *常に* 明示的な宣言を必要とすることを忘れないで下さい。この動作については `Symbol Declarations`_ セクションですでに述べた通りですが、シンボル宣言を行う前にまずappropriateな名前空間へと変更を行った場合は話が別です。例として、新しく ``+`` 演算を作り、それが加算でなく乗算を行うようにする方法を示します::

  > namespace my;
  > infixl 2100 +;
  > x+y = x*y;
  > 5+7;
  35

Note that the new ``+`` operation really belongs to the namespace we
created. The ``+`` operation in the default namespace works as before, and in
fact you can use qualified symbols to pick the version that you need:

この新しい ``+`` 演算が、私たちの作った名前空間に所属していることに注意を向けて下さい。デフォルト名前空間に属する ``+`` 演算も今まで通り動作するので、修飾子つきシンボルを使えば、実際にあなたの求めに応じたバージョンの ``+`` 演算を使い分けることができます::

  > namespace;
  > 5+7;
  12
  > 5 ::+ 7;
  12
  > 5 my::+ 7;
  35

Here's what you get if you happen to forget the declaration of the ``+``
operator:

``+`` 演算子を定義し忘れてしまったら、こういうことになります::

  > namespace my;
  > x+y = x*y;
  <stdin>, line 2: infixl symbol '+' was not declared in this namespace

Thus the compiler will never create a new instance of an operator symbol on
the fly, an explicit declaration is always needed in such cases.

このように、コンパイラが演算子シンボルの新しいインスタンスをオン・ザ・フライで作成することは決してありません。こうした場合には明示的な宣言が必要なのです。

Note that if you *really* wanted to redefine the global ``+`` operator, you
can do this even while the ``my`` namespace is current. You just have to use a
qualified identifier in this case, as follows:

もしグローバルな ``+`` 演算子を再定義することが *本当に* 必要なら、可能ではあります。 ``my`` 名前空間がカレントであるときでさえも、です。このような場合、修飾子つき識別子を使う必要があります。次のように::

  > namespace my;
  > x ::+ y = x*y;
  > a+b;
  a*b

This should rarely be necessary (in the above example you might just as well
enter this rule while in the global namespace), but it can be useful in some
circumstances.  Specifically, you might want to "overload" a global function
or operator with a definition that makes use of private symbols of a namespace
(which are only visible inside that namespace; see `Private Symbols`_
below). For instance:

これが必要になることはほとんどないでしょう（上の例を実際に使うなら、グローバル名前空間内でこのルールを入力するほうがよいでしょう）が、時と場合によっては便利でもあります。特に、グローバル関数やグローバル演算子を「オーバーロード」し、ある名前空間内のプライベートなシンボルとして使うのに役立てたいと思うことはあるかもしれません（その演算子はその名前空間内だけで見えるものです。下部 `Private Symbols`_ 参照）。例えば::

  > namespace my;
  > private bar;
  > bar x y = x*y;
  > x ::+ y = bar x y;
  > a+b;
  a*b

(The above is a rather contrived example, since the very same functionality
can be accomplished much easier, but there are some situations where this
approach is necessary.)

（上の例はやや不自然です。なぜなら、ほぼ同じ機能をもっと簡単に実現できるからです。しかし、このようなアプローチが必要となる状況もあります）

Private Symbols
~~~~~~~~~~~~~~~

Pure also allows you to have private symbols, as a means to hide away internal
operations which shouldn't be accessed directly outside the namespace in which
they are declared. The scope of a private symbol is confined to its namespace,
i.e., the symbol is only visible when its "home" namespace is current. Symbols
are declared private by using the ``private`` keyword in the symbol
declaration:

Pure ではプライベートなシンボルを持つことも許されます。シンボルが属する名前空間の外から直接アクセスされてはいけない処理を隠す手段となっています。プライベートシンボルのスコープは、それが属す名前空間内に限定されます。すなわち、そのシンボルの「ホーム」名前空間がカレント状態であるときだけ可視となります。シンボルをプライベートなものとして宣言するには、宣言時に ``private`` キーワードを使います::

  > namespace secret;
  > private baz;
  > // 'baz' is a private symbol in namespace 'secret' here
  > baz x = 2*x;
  > // you can use 'baz' just like any other symbol here
  > baz 99;
  198
  > namespace;

Note that, at this point, ``secret::baz`` is now invisible, even if you have
``secret`` in the search namespace list:

この段階で、 ``secret::baz`` は不可視の状態です。たとえ ``secret`` が検索対象の名前空間リストに入っていても、見えません::

  > using namespace secret;
  > // this actually creates a 'baz' symbol in the default namespace:
  > baz 99;
  baz 99
  > secret::baz 99;
  <stdin>, line 27: symbol 'secret::baz' is private here

The only way to bring the symbol back into scope is to make the ``secret``
namespace current again:

このシンボルをスコープ内へと戻すには、 ``secret`` 名前空間を再びカレントにするしかありません::

  > namespace secret;
  > baz 99;
  198
  > secret::baz 99;
  198

Hierarchical Namespaces
~~~~~~~~~~~~~~~~~~~~~~~

階層状の名前空間

Namespace identifiers can themselves be qualified identifiers in Pure, which
enables you to introduce a hierarchy of namespaces. This is useful, e.g., to
group related namespaces together under a common "umbrella" namespace:

Pure では、名前空間識別子は、それ自身が修飾子つき識別子であることも可能です。これにより、名前空間の階層を導入することができるようになっています。これが便利なのは、例えば、関連する複数の名前空間を、共通の "umbrella" 名前空間の下にまとめる場合です::

  namespace my;
  namespace my::old;
  foo x = x+1;
  namespace my::new;
  foo x = x-1;

Note that the namespace ``my``, which serves as the parent namespace, must be
created before the ``my::old`` and ``my::new`` namespaces, even if it does not
contain any symbols of its own. After these declarations, the ``my::old`` and
``my::new`` namespaces are part of the ``my`` namespace and will be considered
in name lookup accordingly, so that you can write:

名前空間 ``my`` は、親の名前空間となっていますが、 ``my::old`` や ``my::new`` よりも前に作成されなければならないことを忘れないで下さい。親となる名前空間がシンボルを一つも持っていない場合でもです。これらの宣言の後、 ``my::old`` と ``my::new`` 名前空間は ``my`` 名前空間の一部となり、名前探索の際にもそれに応じた考慮が行われます。なので、次のように書くことができます::

  > using namespace my;
  > old::foo 99;
  100
  > new::foo 99;
  98

This works pretty much like a hierarchy of directories and files, where the
namespaces play the role of the directories (with the default namespace as the
root directory), the symbols in each namespace correspond to the files in a
directory, and the ``using namespace`` declaration functions similar to the
shell's ``PATH`` variable.

この動作は、ディレクトリやファイルの階層構造ととてもよく似ています。この場合、各名前空間はディレクトリ（デフォルト名前空間をルートディレクトリとする）の役割を果たし、名前空間内の各シンボルはディレクトリ内のファイルに対応します。 ``using namespace`` 宣言はシェルの ``PATH`` 変数と同じように機能します。

Sometimes it is necessary to tell the compiler to use a symbol in a specific
namespace, bypassing the usual symbol lookup mechanism. For instance, suppose
that we introduce another *global* ``old`` namespace and define yet another
version of ``foo`` in that namespace:

ときどき、通常のシンボル検索手順を避けて、特定の名前空間内のシンボルを使うようコンパイラに伝える必要が生じます。例えば、 *グローバルな* ``old`` 名前空間をもう一つ導入し、その名前空間内に別バージョンの ``foo`` を定義することを考えます::

  namespace old;
  foo x = 2*x;
  namespace;

Now, if we want to access that function, with ``my`` still active as the
search namespace, we cannot simply refer to the new function as ``old::foo``,
since this name will resolve to ``my::old::foo`` instead. As a remedy, the
compiler accepts an `absolute` qualified identifier of the form
``::old::foo``. This bypasses name lookup and thus always yields exactly the
symbol in the given namespace (if it exists; as mentioned previously, the
compiler will complain about an undeclared symbol otherwise):

今、この関数へアクセスしたいとして、しかも ``my`` 名前空間がまだ検索対象として有効であるとしても、単純に ``old::foo`` としただけでは新しい関数へアクセスできません。代わりに ``my::old::foo`` と解決されてしまうからです。改善策として、コンパイラは ``::old::foo`` という形式の `絶対指定` 修飾子つき識別子を受け入れます。これは名前空間検索を迂回するので、与えられた名前空間をいつでも正確にもたらしてくれます（もし存在するならば、ですが。前でも述べましたが、存在しない場合、コンパイラは未宣言のシンボルだと文句を言ってきます）::

  > old::foo 99;
  100
  > ::old::foo 99;
  198

Also note that, as a special case of the absolute qualifier notation,
``::foo`` always denotes the symbol ``foo`` in the default namespace.

また、絶対指定修飾子記法の特別ケースとして、 ``::foo`` は常にデフォルト名前空間内のシンボルを指示するものであることを覚えておいて下さい。

Scoped Namespaces
~~~~~~~~~~~~~~~~~

Pure also provides an alternative scoped ``namespace`` construct which makes
nested namespace definitions more convenient. This construct takes the
following form:

また Pure は、もう一つ別のスコープを持つ ``namespace`` 構造を提供します。これはネストされた名前空間定義を便利に行う方法です。この構造は次のような形式をとります::

  namespace name with ... end;

The part between ``with`` and ``end`` may contain arbitrary declarations and
definitions, using the same syntax as the toplevel. These are processed in the
context of the given namespace, as if you had written:

``with`` から ``end`` までの間には、任意の宣言と定義を入れてかまいません。トップレベルと同じ文法を使えます。それらは与えられた名前空間の文脈で処理され、以下のように書いた場合と同じ効果を持ちます::

  namespace name;
  ...
  namespace;

However, the scoped namespace construct always returns you to the namespace
which was active before, and thus these declarations may be nested:

しかし、スコープを持つ名前空間構造は、その直前にアクティブであった名前空間へと常に戻ります。なので、このように宣言を重箱のようにする〔＝ネストする〕ことができます::

  namespace foo with
    // declarations and definitions in namespace foo
    namespace bar with
      // declarations and definitions in namespace bar
    end;
    // more declarations and definitions in namespace foo
  end;

Note that this kind of nesting does not necessarily imply a namespace
hierarchy as discussed in `Hierarchical Namespaces`_. However, you can achieve
this by using the appropriate qualified namespace names:

この種のネスティングは、 `Hierarchical Namespaces`_ で議論したような階層状の名前空間を必ずしも伴うものではないことに注意して下さい。階層状の名前空間を実現するには適切な修飾子つき名前空間名を使います::

  namespace foo with
    // ...
    namespace foo::bar with
      // ...
    end;
    // ...
  end;

Another special feature of the scoped namespace construct is that ``using
namespace`` declarations are always local to the current namespace scope (and
other nested namespace scopes inside it). Thus the previous setting is
restored at the end of each scope:

もうひとつ、スコープを持つ名前空間構造には特色があります。 ``using namespace`` 宣言は常にカレント名前空間スコープへと（かつ、その内側に含まれる入れ子の名前空間スコープへと）ローカルであるということです。したがって、さきほどの設定は各スコープの末尾で復旧されます::

  using namespace foo;
  namespace foo with
    // still using namespace foo here
    // ここではまだ foo 名前空間を使用中
    using namespace bar;
    // now using namespace bar
    // 今は bar 名前空間を使用中
    namespace bar with
      // still using namespace bar here
      // まだ bar
      using namespace foo;
      // now using namespace foo
      // foo を使用中
    end;
    // back to using namespace bar
    // bar に戻った
  end;
  // back to using namespace foo at toplevel
  // トップレベルの foo に戻った

Finally, here's a more concrete example which shows how scoped namespaces
might be used to declare two namespaces and populate them with various
functions and operators:

最後に、もっと具体的な例を示します。この例は、スコープを持つ名前空間内を使って、2つの名前空間を宣言し、それらを様々な関数や演算子とともに住まわせる方法を示しています::

  namespace foo with
    infixr (::^) ^;
    foo x = x+1;
    bar x = x-1;
    x^y = 2*x+y;
  end;

  namespace bar with
    outfix <: :>;
    foo x = x+2;
    bar x = x-2;
  end;

  using namespace foo(^ foo), bar(bar <: :>);

  // namespace foo
  foo x;
  x^y;

  // namespace bar
  bar x;
  <: x,y :>;

Pure's namespaces can thus be used pretty much like "modules" or "packages" in
languages like Ada or Modula-2. They provide a structured way to describe
program components offering collections of related data and operations, which
can be brought into scope in a controlled way by making judicious use of
``using namespace`` declarations. They also provide an abstraction barrier,
since internal operations and data structures can be hidden away employing
private symbols.

Pure の名前空間はこのように、 Ada や Modula-2 の「モジュール」や「パッケージ」ととてもよく似た使い方ができます。それらは、複数のプログラム構成要素を構造的に記述する手段であり、関連するデータと処理をまとめた状態で提供できるようにしてくれます。 ``using namespace`` 宣言を賢明に使えば、それらを適切に管理しながらスコープ内へ導くことができます。また、 ``using namespace`` 宣言は抽象的な仕切りをも提供します。プライベートシンボルを使うことで内部処理や内部データ構造を隠蔽することができるからです。

Please note that these facilities are not Pure's main focus and thus they are
somewhat limited compared to programming languages specifically designed for
big projects and large teams of developers. Nevertheless they should be useful
if your programs grow beyond a small collection of simple source modules, and
enable you to manage most Pure projects with ease.

ただし、こうした機能は Pure の主要な焦点ではなく、そのため、大きなプロジェクトや大規模なチーム開発に特化してデザインされたプログラミング言語と比較すればいくらか制限されたものであることを、どうか忘れないで下さい。とはいっても、あなたのプログラムがシンプルなソースモジュールの小さな集まりであることを超えて育っていく際には役立つものでしょうし、たいていの Pure プロジェクトを容易に管理する助けにもなるはずです。

Exception Handling
==================

例外のハンドリング

Pure also offers a useful exception handling facility. To raise an exception,
you just invoke the built-in function ``throw`` with the value to be thrown as
the argument. To catch an exception, you use the built-in special form
``catch`` with the exception handler (a function to be applied to the
exception value) as the first and the expression to be evaluated as the second
(call-by-name) argument. For instance:

Pure は便利な例外処理機能も提供します。例外を起こすには、ただ組み込み関数 ``throw`` を、一緒にスローされる値を引数として呼び出すだけです。例外をキャッチするには、組み込み特別形 ``catch`` を呼び出します。 ``catch`` の第一引数は例外ハンドラ（例外の値に適用される関数）、第二引数は評価されるべき式（名前呼び出し）とします。例えば::

  > catch error (throw hello_world);
  error hello_world

Exceptions are also generated by the runtime system if the program runs out of
stack space, when a guard does not evaluate to a truth value, and when the
subject term fails to match the pattern in a pattern-matching lambda
abstraction, or a ``let``, ``case`` or ``when`` construct. These types of
exceptions are reported using the symbols ``stack_fault``, ``failed_cond`` and
``failed_match``, respectively, which are declared as constant symbols in the
standard prelude. You can use ``catch`` to handle these kinds of exceptions
just like any other. For instance:

例外はランタイムシステムにより生成されることもあります。プログラムがスタックスペースを使い切った場合や、ガードでの評価が真にならなかった場合、そしてsubject termが、パターンマッチを行うラムダ抽象内や、 ``let``, ``case``, ``when`` 構造内で、パターンマッチに失敗した場合です。こうした種類の例外は、それぞれ ``stack_fault`` 、 ``failed_cond`` 、 ``failed_match`` というシンボルを使ってレポートされます（標準 prelude 内で定数シンボルとして宣言されます）。この種の例外を取り扱うときも他と同じく ``catch`` を使うことができます。例えば::

  > fact n = if n>0 then n*fact(n-1) else 1;
  > catch error (fact foo);
  error failed_cond
  > catch error (fact 100000);
  error stack_fault

(You'll only get the latter kind of exception if the interpreter does stack
checks, see the discussion of the PURE_STACK environment variable in the
`Caveats and Notes`_ section.)

（後者の例外を受け取るのは、インタープリタがスタックチェックを行う場合だけです。詳しくは `Caveats and Notes`_ セクション内の PURE_STACK 環境変数に関する議論を参照して下さい）

Note that unhandled exceptions are reported by the interpreter with a
corresponding error message:

ハンドルされない例外は、対応するメッセージとともにインタープリタがレポートしてきます::

  > fact foo;
  <stdin>, line 2: unhandled exception 'failed_cond' while evaluating 'fact foo'

Exceptions also provide a way to handle asynchronous signals. Pure's system
module provides symbolic constants for common POSIX signals and also defines
the operation ``trap`` which lets you rebind any signal to a signal
exception. For instance, the following lets you handle the ``SIGQUIT``
signal:

また、例外は、非同期シグナルを取り扱う方法を提供します。 Pure のシステムモジュールは共通 POSIX シグナルの記号定数を提供し、また ``trap`` 処理を定義しています。 ``trap`` 処理では、あらゆるシグナルをシグナル例外と再び結びつけることができます。例えば、次の手順で ``SIGQUIT`` シグナルを扱うことができます::

  > using system;
  > trap SIG_TRAP SIGQUIT;

You can also use ``trap`` to just ignore a signal or revert to the system's
default handler (which might take different actions depending on the type of
signal, see signal(7) for details):

``trap`` を使ってシグナルを単純に無視したり、システムのデフォルトハンドラへ復帰することもできます（シグナル種別により異なるアクションを起こす可能性があります。詳しくは signal(7) を参照して下さい）::

  > trap SIG_IGN SIGQUIT; // signal is ignored
  > trap SIG_DFL SIGQUIT; // reinstalls the default signal handler

Note that when the interpreter runs interactively, for convenience most
standard termination signals (``SIGINT``, ``SIGTERM``, etc.) are already set
up to produce corresponding Pure exceptions of the form ``signal SIG`` where
``SIG`` is the signal number. If a script is to be run non-interactively then
you'll have to do this yourself (otherwise most signals will terminate the
program).

インタープリタが対話的に実行されているときは、便宜のため、標準的な終了シグナルのほとんど（ ``SIGINT`` や ``SIGTERM`` などなど）が、それぞれ対応する Pure 例外を引き起こすようあらかじめ設定されています。この例外は ``signal SIG`` という形式で、 ``SIG`` にはシグナル番号が入ります。もし、あるスクリプトが非対話的に実行される場合、こうした処理を自分で設定する必要があります（でなければ、ほとんどのシグナルはプログラムを終了させます）。

Last but not least, exceptions can also be used to implement non-local value
returns. For instance, here's a variation of our n queens algorithm which only
returns the first solution. Note the use of ``throw`` in the recursive search
routine to bail out with a solution as soon as we found one. The value thrown
there is caught in the main routine. Also note the use of ``void`` in the
second equation of ``search``. This effectively turns the list comprehension
into a simple loop which suppresses the normal list result and just returns
``()`` instead. Thus, if no value gets thrown then the function regularly
returns with ``()`` to indicate that there is no solution.

最後になりましたが、例外はローカルではない値を持つ返値〔non-local value returns〕を実装するためにも使えます。例えば、次に示すのは、私たちの n クイーンアルゴリズムのバリエーションで、最初に見つかった解答だけを返します。再帰検索ルーチンで ``throw`` を使い、最初の解答を見つけるとそれを持ってすぐさま脱出していることに注目して下さい。そのとき投げられる値はメインルーチンでキャッチされます。また、 ``search`` の2番目の等式での ``void`` の使い方にも注目して下さい。これはリスト内包を一回のループへと効果的に変化させるものです。これにより通常のリスト結果を抑制し、代わりに単なる ``()`` を返します。したがって、もし値が投げられなかった場合、関数は難度も ``()`` を返し、解答がないことを示します。

::

  queens n       = catch reverse (search n 1 []) with
    search n i p = throw p if i>n;
                 = void [search n (i+1) ((i,j):p) | j = 1..n; safe (i,j) p];
    safe (i,j) p = ~any (check (i,j)) p;
    check (i1,j1) (i2,j2)
                 = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
  end;

E.g., let's compute a solution for a standard 8x8 board::

  > queens 8;
  [(1,1),(2,5),(3,8),(4,6),(5,3),(6,7),(7,2),(8,4)]

C Interface
===========

C インターフェース

Accessing C functions from Pure programs is dead simple. You just need an
``extern`` declaration of the function, which is a simplified kind of C
prototype. The function can then be called in Pure just like any other. For
instance, the following commands, entered interactively in the interpreter,
let you use the ``sin`` function from the C library (of course you could just
as well put the ``extern`` declaration into a script):

Pure プログラムから C 関数へアクセスするのは全く簡単です。関数の ``extern`` 宣言だけでよいのです。これは単純化された類の C プロトタイプです。するとその関数は、他のいろいろなものと同じように、 Pure で呼び出せるようになります。例えば、次のコマンド（対話式インタープリタで入力されています）は、 C ライブラリから ``sin`` 関数を使えるようにしてくれます（もちろん、スクリプトの場合でも ``extern`` 宣言を書くことはできます）::

  > extern double sin(double);
  > sin 0.3;
  0.29552020666134

An ``extern`` declaration can also be prefixed with a ``public``/``private``
scope specifier:

``extern`` 宣言の前に ``public``/``private`` を置いてスコープを定義することもできます::

  private extern double sin(double);

Multiple prototypes can be given in one ``extern`` declaration, separating
them with commas:

カンマで分割して、 ``extern`` 宣言内で複数のプロトタイプを与えることもできます::

  extern double sin(double), double cos(double), double tan(double);

For clarity, the parameter types can also be annotated with parameter names,
e.g.:

パラメータ名に型を注記して明確にすることもできます。例えば::

  extern double sin(double x);

Parameter names in prototypes only serve informational purposes and are for
the human reader; they are effectively treated as comments by the compiler.

プロトタイプ内のパラメータ名は単に伝達目的で、人間の読者のために働くものです。実際のところ、コンパイラはコメントとして扱います。

The interpreter makes sure that the parameters in a call match; if not, the
call is treated as a normal form expression by default, which gives you the
opportunity to extend the external function with your own Pure equations (see
below). The range of supported C types is a bit limited right now (``void``,
``bool``, ``char``, ``short``, ``int``, ``long``, ``float``, ``double``, as
well as arbitrary pointer types, i.e.: ``void*``, ``char*``, etc.), but in
practice these should cover most kinds of calls that need to be done when
interfacing to C libraries.

インタープリタはパラメータが呼び出し内でマッチするかどうかを確認します。マッチしない場合、デフォルトでは、呼び出しは通常型の式として扱われます。これにより、外部関数をあなた独自の Pure 等式で拡張する機会が得られます（下部参照）。 C の型をサポートする範囲は今のところやや限られています（ ``void``, ``bool``, ``char``, ``short``, ``int``, ``long``, ``float``, ``double``, さらに任意のポインタ型: ``void*``, ``char*``, etc.）。しかし実用上、 C インターフェースとの仲介を行う際に必要な種類をほぼカバーしているでしょう。

Single precision float arguments and return values are converted from/to
Pure's double precision floating point numbers automatically.

単精度浮動小数点〔float〕型の引数と返値は Pure の倍精度浮動小数点数〔double〕型から／へと自動的に変換されます。

A variety of C integer types (``char``, ``short``, ``int``, ``long``) are
provided which are converted from/to the available Pure integer types in a
straightforward way. In addition, the synonyms ``int8``, ``int16`` and
``int32`` are provided for ``char``, ``short`` and ``int``, respectively, and
``int64`` denotes 64 bit integers (a.k.a. ISO C99 ``long long``). Note that
``long`` is equivalent to ``int32`` on 32 bit systems, whereas it is the same
as ``int64`` on most 64 bit systems. All integer parameters take both Pure
ints and bigints as actual arguments; truncation or sign extension is
performed as needed, so that the C interface behaves as if the argument was
"cast" to the C target type. Returned integers use the smallest Pure type
capable of holding the result, i.e., int for the C ``char``, ``short`` and
``int`` types, bigint for ``int64``.

C の様々な整数型（ ``char``, ``short``, ``int``, ``long`` ）は、利用可能な Pure の整数型から／へと素直な方法で変換されます。加えて、同義語の ``int8``, ``int16``, ``int32`` が、それぞれ ``char``, ``short``, ``int`` に対応するものとして提供されます。 ``int64`` は 64 ビット整数を表します（つまり ISO C99 の ``long long`` です）。32 ビットシステムにおいて ``long`` は ``int32`` と等価であり、ほとんどの 64 ビットシステムでは ``int64`` と等価だということに注意して下さい。整数型のパラメータはすべて、 Pure の int と bigint を実際の引数とすることができます。切り詰め〔truncation〕や符号拡張〔sign extension〕は必要に応じて実行されるので、 C インターフェースはあたかも引数が対象の C 型へと「キャスト」されているかのように振る舞います。返された整数は、結果を保持するのに最低限必要な Pure 型を使います。すなわち int が C の ``char``, ``short``, ``int`` 型のために、 bigint が ``int64`` 型のために使われるわけです。

To make it easier to interface to various system routines, there's also a
special ``size_t`` integer type which usually is 4 bytes on 32 bit and 8 bytes
on 64 bit systems.

様々なシステムのルーチンへのインターフェースを容易にするため、特別な ``size_t`` 整数もあります。これは通常、 32 ビットシステム上で 4 バイト、 64 ビットシステム上では 8 バイトです。

Pure considers all integers as signed quantities, but it is possible to pass
unsigned integers as well (if necessary, you can use a bigint to pass positive
values which are too big to fit into a machine int). Also note that when an
unsigned integer is returned by a C routine, which is too big to fit into the
corresponding signed integer type, it will "wrap around" and become
negative. In this case, depending on the target type, you can use the
``ubyte``, ``ushort``, ``uint``, ``ulong`` and ``uint64`` functions provided
by the prelude to convert the result back to an unsigned quantity.

Pure は全ての整数型を符号つきの量として考えます。しかし符号なし整数を渡すことも可能です（必要なら、 bitint を使って machine int には入りきらない正の数を渡すこともできます）。また、符号なし整数が C ルーチンから戻ってきたとき、その数は "wrap around" され、負の数になることを忘れないで下さい。この場合、対象の型に応じて、 prelude が提供する ``ubyte``, ``ushort``, ``uint``, ``ulong``, ``uint64`` 関数を使って符号なしの数量へ変換することができます。

Concerning the pointer types, ``char*`` is for string arguments and return
values which need translation between Pure's internal utf-8 representation and
the system encoding, while ``void*`` is for any generic kind of pointer
(including strings, which are not translated when passed/returned as
``void*``). Any other kind of pointer (except ``expr*`` and the GSL matrix
pointer types, which are discussed below) is effectively treated as ``void*``
right now, although in a future version the interpreter may keep track of the
type names for the purpose of checking parameter types.

ポインタ型に関してですが、 ``char*`` は文字列引数と文字列返値のためのもので、 Pure 内部の utf-8 表現とシステムエンコーディングとの間で翻訳が必要です。それに対して ``void*`` はあらゆるジェネリックなポインタに使えます（文字列を含みます。文字列ポインタが ``void*`` として渡され／返されたときは翻訳されません）。いかなる種類のポインタであっても（ただし ``expr*`` および GSL マトリクスポインタだけは別で、下で議論します）、いまのところ ``void*`` として実際に扱うことができますが、将来のバージョンのインタープリタではパラメータ型をチェックするために型の名前を記録する可能性があります。

The ``expr*`` pointer type is special; it indicates a Pure expression
parameter or return value which is just passed through unchanged. All other
types of values have to be "unboxed" when they are passed as arguments (i.e.,
from Pure to C) and "boxed" again when they are returned as function results
(from C to Pure). All of this is handled by the runtime system in a
transparent way, of course.

``expr*`` ポインタ型は特別なものです。これは Pure の式パラメータや返値を指し示すもので、変更されずそのまま渡されます。その他の値型は引数として（つまり、 Pure から C へ）渡される際に「箱から出す」ことが必要で、さらに関数の結果として（つまり、 C から Pure へ）再び返される際には「箱詰めする」ことが必要です。もちろん、この手順はすべてランタイムシステムにより透過的な方法で扱われます。

The matrix pointer types ``dmatrix*``, ``cmatrix*`` and ``imatrix*`` can be
used to pass double, complex double and int matrices to GSL functions taking
pointers to the corresponding GSL types (``gsl_matrix``,
``gsl_matrix_complex`` and ``gsl_matrix_int``) as arguments or returning them
as results. Note that there is no marshalling of Pure's symbolic matrix type,
as these aren't supported by GSL anyway. Also note that matrices are always
passed by reference. If you need to pass a matrix as an output parameter of a
GSL matrix routine, you can either create a zero matrix or a copy of an
existing matrix. The prelude provides various operations for that purpose (in
particular, see the ``dmatrix``, ``cmatrix``, ``imatrix`` and ``pack``
functions in matrices.pure). For instance, here is how you can quickly wrap up
GSL's double matrix addition function in a way that preserves value
semantics:

マトリクスポインタ型 ``dmatrix*``, ``cmatrix*`` および ``imatrix*`` は double, complex double および int matrices のマトリクスから GSL 関数へ渡すことができます。この関数は、それぞれ対応する GSL 型（ ``gsl_magrix``, ``gsl_magrix_complex`` および ``gls_magrix_int`` ）へのポインタを引数にとり、あるいは結果として返します。 Pure の記号マトリクス型のマーシャリングは行われないので注意して下さい。これらはいずれにせよ GSL でサポートされないからです。また、マトリクスは常に参照渡しであることも忘れないで下さい。もしマトリクスを GSL マトリクスルーチンの出力パラメータとして渡すことが必要なら、ゼロマトリクスか既存のマトリクスのコピーを作る方法があります。 prelude はこの目的に使える様々な処理を提供します（詳しくは matrices.pure 内の ``dmatrix, ``cmatrix``, ``imatrix`` および ``pack`` 関数を参照して下さい）。例えば次の例では、 GSL の double マトリクス加算関数を、 value semantics を保ったまま素早く wrap up する方法を示します::

  > using "lib:gsl";
  > extern int gsl_matrix_add(dmatrix*, dmatrix*);
  > x::matrix + y::matrix = gsl_matrix_add x y $$ x when x = pack x end;
  > let x = dmatrix {1,2,3}; let y = dmatrix {2,3,2}; x; y; x+y;
  {1.0,2.0,3.0}
  {2.0,3.0,2.0}
  {3.0,5.0,5.0}

Most GSL matrix routines can be wrapped in this fashion quite easily. A
ready-made GSL interface providing access to all of GSL's numeric functions is
in the works; please check the Pure website for details.

GSL のマトリクスルーチンのほとんどは、こんな風に手早く簡単に wrap することができます。 GSL の全数値関数へのアクセスを提供する出来合いの GSL インターフェースは、現在作成中です。詳しくは Pure のウェブサイトをチェックしてみて下さい。

For convenience, it is also possible to pass a numeric matrix for a
``short*``, ``int*``, ``float*`` or ``double*`` parameter. The required
conversions are done automatically, on the fly, and the matrix data is copied
to temporary storage in order to preserve value sematics.

便宜のため、数値マトリクスを ``short*`` や ``int*``, ``float*``, ``double*`` パラメータへ渡すことができます。必要な変換は、自動的にオン・ザ・フライで行われ、マトリクスデータは value semantics を保つため一時領域にコピーされます。

In addition, any kind of matrix (including symbolic matrices) can also be
passed for a generic ``void*`` pointer. In this case no conversions are done
and a pointer to the raw matrix data is passed, which allows the matrix to be
modified in-place. Similarly, ``void*`` also allows you to pass a bigint
argument as a raw ``mpz_t`` value. This makes it possible to call most GMP
integer routines directly from Pure.

それに加え、あらゆる種類のマトリクス（記号マトリクスを含む）を、ジェネリックな ``void*` ポインタへ渡すことができます。この場合、変換はまったく行われず、生のマトリクスデータ〔raw matrix data〕が渡されます。この場合はデータを直接書き替えることができます。同じように、 ``void*`` を使うと、 bigint 引数を生の ``mpz_t`` の値として渡すことができます。これにより、ほとんどの GMP 整数ルーチンを Pure から直接呼び出すことができるようになっています。

As already mentioned, it is possible to augment an external C function with
ordinary Pure equations, but in this case you have to make sure that the
``extern`` declaration of the function comes first. For instance, we might
want to extend our imported ``sin`` function with a rule to handle integers:

すでに述べた通り、外部 C 関数を通常の Pure 等式で増大させる〔拡張する〕ことができます。しかしこの場合、関数の ``extern`` 宣言を確実に最初に置くようにしてください。例として、インポートした ``sin`` 関数に整数型を扱うルールを拡張したいとしましょう::

  > extern double sin(double);
  > sin 0.3;
  0.29552020666134
  > sin 0;
  sin 0
  > sin x::int = sin (double x);
  > sin 0;
  0.0

Sometimes it is preferable to replace a C function with a wrapper function
written in Pure. In such a case you can specify an `alias` under which the
original C function is known to the Pure program, so that you can still call
the C function from the wrapper. An alias is introduced by terminating the
extern declaration with a clause of the form ``= alias``. For instance:

ときどき、 C 関数を Pure で書いたラッパー関数で置き換えたほうがよいこともあります。そのような場合、 `alias` を設定し、 Pure プログラム側は C 関数をその名前で使うものとします。結果、あなたは C 関数をラッパーから呼び出せるようになります。エイリアス〔＝別名〕を導入するには extern 宣言を ``= alias`` という節で終えます。例えば::

  > extern double sin(double) = c_sin;
  > sin x::double = c_sin x;
  > sin x::int = c_sin (double x);
  > sin 0.3; sin 0;
  0.29552020666134
  0.0

As an alternative, you can also declare the C function in a special namespace
(cf. Namespaces_ in the Declarations_ section):

もう一つのやり方として、特別な名前空間の内部で C 関数を宣言する方法もあります（cf. Declarations_ セクション内 Namespaces_ ）::

  > namespace c;
  > extern double sin(double);
  > c::sin 0.3;
  0.29552020666134

Note that the namespace qualification only affects the Pure side; the
underlying C function is still called under the unqualified name as usual. The
way in which such qualified externs are accessed is the same as for ordinary
qualified symbols. In particular, the ``using namespace`` declaration applies
as usual, and you can declare such symbols as ``private`` if needed. It is
also possible to combine a namespace qualifier with an alias:

ただし、名前空間の修飾部分は Pure 側にのみ影響することを忘れないで下さい。その下にある C 関数は前のまま修飾子なしの名前で呼び出されます。 修飾子つき extern 関数は通常の修飾子つきシンボルと同じ方法でアクセスされます。特に ``using namespace`` 宣言も通常通り適用され、必要ならばそうしたシンボルを ``private`` にすることもできます。名前空間修飾子をエイリアスと混在させることも可能です::

  > namespace c;
  > extern double sin(double) = mysin;
  > c::mysin 0.3;
  0.29552020666134

External C functions are resolved by the LLVM runtime, which first looks for
the symbol in the C library and Pure's runtime library (or the interpreter
executable, if the interpreter was linked statically). Thus all C library and
Pure runtime functions are readily available in Pure programs. Other functions
can be provided by adding them to the runtime, or by linking them into the
runtime or the interpreter executable. Better yet, you can just "dlopen"
shared libraries at runtime with a special form of the ``using`` clause:

外部 C 関数は LLVM ランタイムによっても解決されます。 LLVM ランタイムはまず、シンボルを C ライブラリと Pure ランタイムライブラリから探します（あるいは Pure インタープリタが静的にリンクされていた場合、インタープリタ実行ファイルから探します）。したがって、全ての C ライブラリと Pure ランタイム関数は Pure プログラム内で簡単に利用可能なのです。他の関数を提供することも、ランタイムにそれを追加したり、ランタイムやインタープリタ実行ファイルにそれをリンクしたりすることで可能です。もっとよい方法は、ランタイムの共有ライブラリを "dlopen" することです。これには特別な形式の ``using`` 節を使います::

  using "lib:libname[.ext]";

For instance, if you want to call the functions from library libxyz directly
from Pure:

例えば、ライブラリ libxyz 内の関数を Pure から直接呼び出したいなら::

  using "lib:libxyz";

After this declaration the functions from the given library will be ready to
be imported into your Pure program by means of corresponding ``extern``
declarations.

この宣言の後、指定されたライブラリ内の関数は Pure プログラムへインポートされる準備が整った状態となります。インポートの際は適切な ``extern`` 宣言を行います。

Shared libraries opened with using clauses are searched for in the same way as
source scripts (see section `Modules and Imports`_ above), using the -L option
and the PURE_LIBRARY environment variable in place of -I and PURE_INCLUDE. If
the library isn't found by these means, the interpreter will also consider
other platform-specific locations searched by the dynamic linker, such as the
system library directories and LD_LIBRARY_PATH on Linux. The necessary
filename suffix (e.g., .so on Linux or .dll on Windows) will be supplied
automatically when needed. Of course you can also specify a full pathname for
the library if you prefer that. If a library file cannot be found, or if an
``extern`` declaration names a function symbol which cannot be resolved, an
appropriate error message is printed.

using 節を使ってオープンされた共有ライブラリはソーススクリプトと同じ方法で検索されます（上部 `Modules and Imports`_ 参照）。つまり -L オプションと PURE_LIBRARY 環境変数を -I と PURE_INCLUDE の代わりに使った場合と同じ方法です。そのライブラリがこの方法で見つからなかった場合、インタープリタは、プラットフォーム固有の他の場所（動的リンカにより検索される場所）を考慮に入れます（例えば Linux 上でのシステムライブラリディレクトリと LD_LIBRARY_PATH など）。ファイル名サフィックス（例えば Linux 上での .so や Windows 上での .dll など）は必要に応じて自動的に付加されます。もちろん、お好みならばライブラリのフルパス名を指定することもできます。ライブラリファイルが見つからない場合、あるいは ``extern`` 宣言で命名された関数シンボルが解決できない場合、それぞれに対応するメッセージが出力されます。

Standard Library
================

標準ライブラリ

Pure comes with a collection of Pure library modules, which includes the
standard prelude (loaded automatically at startup time) and some other modules
which can be loaded explicitly with a ``using`` clause. The prelude offers the
necessary functions to work with the built-in types (including arithmetic and
logical operations) and to do most kind of list processing you can find in ML-
and Haskell-like languages. It also provides a collection of basic string and
matrix operations. Please refer to the `Pure Library Manual`_ for details on
the provided operations. Here is a very brief summary of some of the prelude
operations which, besides the usual arithmetic and logical operators, are
probably used most frequently:

Pure には Pure ライブラリモジュール一式が付属します。ライブラリモジュール一式には標準 prelude （起動時に自動ロードされる）と他のいくつかのモジュール（ ``using`` 節で明示的にロードする）が含まれています。 prelude が提供するのは、組み込み型を扱う際に必要となる関数（算術処理や論理処理を含む）や、 ML 的／ Haskell 的な言語が備えているようなたいていのリスト処理などです。 prelude はさらに、基本的な文字列処理とマトリクス処理の一式も提供します。詳しいことは `Pure Library Manual`_ の各項目を参照して下さい。ここでは、 prelude に含まれる処理のいくつかについて、とても簡単な要約を示します。お決まりの算術・論理演算子に加えて、おそらく最もよく使うであろう処理を紹介します:

``x+y``
    The arithmetic ``+`` operation is also used to denote list and string
    concatenation in Pure.

``x+y``
    算術 ``+`` 処理は、 Pure において、リストや文字列の結合を示すのにも使えます。

``x:y``
    This is the list-consing operation. ``x`` becomes the head of the list,
    ``y`` its tail. As '``:``' is a constructor symbol, you can use it in
    patterns on the left hand side of rewriting rules.

``x:y``
    これは「リストを cons する」処理です。 ``x`` はリストの先頭要素となり、 ``y`` は尾となります。 '``:``' はコンストラクタシンボルなので、書き換えルールの左辺パターン内で使うことができます。

``x..y``
    Constructs arithmetic sequences. ``x:y..z`` can be used to denote
    sequences with arbitrary stepsize ``y-x``. Infinite sequences can be
    constructed using an infinite bound (i.e., ``inf`` or ``-inf``). E.g.,
    ``1:3..inf`` denotes the stream of all odd integers starting at 1.

``x..y``
    等差数列を構成します。 ``x:y..z`` と書いて、任意の差〔＝ステップサイズ〕 ``y-x`` を持つ数列を示すことができます。無限長の数列を構成するには、無限大束縛（すなわち ``inf`` または ``-inf`` ）を使います。例えば ``1:3..inf`` は、 1 から始まりすべての奇数からなるストリームを示しています。

``x,y``
    This is the pair constructor, used to create tuples of arbitrary
    sizes. Tuples provide an alternative way to represent aggregate values in
    Pure. In difference to lists, tuples are always "flat", so that
    ``(x,y),z`` and ``x,(y,z)`` denote the same triple ``x,y,z``. (This is
    explained in more detail in the `Pure Overview`_ section.)

``x,y``
    これはペアコンストラクタです。任意のサイズのタプルを作成するのに使います。タプルは Pure において集合値を表現するもう一つの方法です。リストと異なり、タプルは常に「フラット」です。なので、 ``(x,y),z`` と ``x,(y,z)`` はどちらも同じく ``x,y,z`` という3要素を示しています（この点については `Pure Overview`_ セクション内で詳しく説明されています）。

``#x``
    The size (number of elements) of the list, tuple, matrix or string
    ``x``. In addition, ``dim x`` yields the dimensions (number of rows and
    columns) of a matrix.

``#x``
    リスト、タプル、マトリクス、文字列 ``x`` それぞれのサイズ（要素数）を示しています。さらに ``dim x`` はマトリクスの次元（行と列の数）をもたらします。

``x!y``
    This is Pure's indexing operation, which applies to lists, tuples,
    matrices and strings. Note that all indices in Pure are zero-based, thus
    ``x!0`` and ``x!(#x-1)`` are the first and last element of ``x``. In the
    case of matrices, the subscript may also be a pair of row and column
    indices, such as ``x!(1,2)``.

``x!y``
    これは Pure のインデックス処理で、リスト、タプル、マトリクス、文字列に適用できます。 Pure のインデックスは全てゼロから始まり、 ``x!0`` と ``x!(#x-1)`` はそれぞれ ``x`` の先頭要素と最終要素を表します。マトリクスの場合、添字は行と列のインデックスのペアとすることもできます。例えば ``x!(1,2)`` のような形式です。

``x!!ys``
    This is the "slicing" operation, which returns the list, tuple, matrix or
    string of all ``x!y`` while ``y`` runs through the (list or matrix)
    ``ys``. Thus, e.g., ``x!!(i..j)`` returns all the elements between ``i``
    and ``j`` (inclusive). Indices which fall outside the valid index range
    are quietly discarded. The index range ``ys`` may contain any number of
    indices (also duplicates), in any order. Thus ``x!![0|i=1..n]`` returns the
    first element of ``x`` ``n`` times, and, if ``ys`` is a permutation of the
    range ``0..#x-1``, then ``x!!ys`` yields the corresponding permutation of
    the elements of ``x``. In the case of matrices the index range may also
    contain two-dimensional subscripts, or the index range itself may be
    specified as a pair of row/column index lists such as ``x!!(i..j,k..l)``.

``x!!ys``
    これは「スライス」処理です。リスト、タプル、マトリクス、文字列から ``x!y`` の範囲の要素すべてを返します、 while ``y`` runs through the (list or matrix) ``ys``. したがって、例えば ``x!!(i..j)`` は ``i`` から ``j`` にかけての全要素（ ``i`` と ``j`` を含む）を返します。有効なインデックス範囲を出た分のインデックスは黙って〔エラーなどは出さず〕捨てられます。インデックス範囲 ``ys`` はいかなる数のインデックスを含んでいても（また重複があっても）かまわず、順序も問いません。したがって ``x!![0|i=1..n]`` は、最初の要素 ``x`` を ``n`` 回繰り返します。 ``ys`` が ``0..#x-1`` の順列であるとき、 ``x!!ys`` はその順列に対応する ``x`` 要素の順列を産み出します。マトリクスの場合、インデックス範囲に2次元の添字を使うこともできます。あるいは、インデクス範囲そのものを行／列のインデックスリストのペアとして指定することもできます。たとえば ``x!!(i..j,k..l)`` のような形式です。

The prelude also offers support operations for the implementation of list and
matrix comprehensions, as well as the customary list operations like ``head``,
``tail``, ``drop``, ``take``, ``filter``, ``map``, ``foldl``, ``foldr``,
``scanl``, ``scanr``, ``zip``, ``unzip``, etc., which make list programming so
much fun in modern FPLs. In Pure, these also work on strings as well as
matrices, although, for reasons of efficiency, these data structures are
internally represented as arrays.

prelude はリスト内包とマトリクス内包の実装に対する処理のサポートも提供します。もちろん、お決まりのリスト処理である ``head``, ``tail``, ``drop``, ``take``, ``filter``, ``map``, ``foldl``, ``foldr``, ``scanl``, ``scanr``, ``zip``, ``unzip`` などなど、現代的関数型プログラミング言語でのリスト処理が楽しくなるものが揃っています。 Pure では、文字列やマトリクスに対しても動作しますが、効率の面から、これらの構造は内部的に配列として表現されています。

Besides the prelude, Pure's standard library also comprises a growing number
of additional library modules which we can only mention in passing here. In
particular, the math.pure module provides additional mathematical functions as
well as Pure's complex and rational number data types. Common container data
structures like sets and dictionaries are implemented in the set.pure and
dict.pure modules, among others. Moreover, the (beginnings of a) system
interface can be found in the system.pure module. In particular, this module
also provides operations to do basic C-style I/O, including ``printf`` and
``scanf``. These are all described in much more detail in the `Pure Library
Manual`_.

prelude に加えて、 Pure の標準ライブラリには他にもたくさんの追加ライブラリモジュールが含まれており、その数は増え続けていますが、ここではざっと触れることしかできません。特に math.pure モジュールは、追加的な数学関数だけでなく、 Pure の複素数・有理数データ型をも提供します。 set や dictionary のような共通コンテナデータ構造も set.pure や dict.pure などなどで実装されています。さらには、 (beginnings of a) システムインターフェースを system.pure モジュール内で発見できます。特に、このモジュールは、 ``printf`` や ``scanf`` を含め、 C スタイルの基本的な I/O を行う処理も提供しています。これらの全ては `Pure Library Manual`_ 内でもっと詳しく説明されています。

Interactive Usage
=================

対話的に使う

In interactive mode, the interpreter reads definitions and expressions and
processes them as usual. You can use the -i option to force interactive mode
when invoking the interpreter with some script files. Additional scripts can
be loaded interactively using either a using declaration or the interactive
run command (see the description of the run command below for the differences
between these). Or you can just start typing away, entering your own
definitions and expressions to be evaluated.

対話モードにおいて、インタープリタは定義と式を読み込み、通常通りそれを処理します。 -i オプションを使うと、スクリプトファイルと同時にインタープリタを起動した際でも対話モードを強制することができます。対話モードで追加スクリプトを読み込むには、 using 宣言を使うか、対話モード用の run コマンドを使います（両者の違いについては下部 run コマンドの説明を参照して下さい）。あるいは、すぐにタイピングを始め、あなたの好きな定義や式を評価させてもかまいません。

The input language is just the same as for source scripts, and hence
individual definitions and expressions must be terminated with a semicolon
before they are processed. For instance, here is a simple interaction which
defines the factorial and then uses that definition in some evaluations. Input
lines begin with '``>``', which is the interpreter's default command prompt:

入力言語はソーススクリプトとまったく同じです。したがって個々の定義や式はセミコロンで終わっていなければ処理が行われません。例えば、次の対話サンプルでは、階乗を定義し、その定義をいくつかの評価に使っています。入力行は '``>``' で始まりますが、これがインタープリタのデフォルトコマンドプロンプトです::

  > fact 1 = 1;
  > fact n = n*fact (n-1) if n>1;
  > let x = fact 10; x;
  3628800
  > map fact (1..10);
  [1,2,6,24,120,720,5040,40320,362880,3628800]

As indicated, in interactive mode the normal forms of toplevel expressions are
printed after each expression is entered. We also call this the
`read-eval-print loop`. Normal form expressions are usually printed in the
same form as you'd enter them. However, there are a few special kinds of
objects like anonymous closures, thunks ("lazy" values to be evaluated when
needed) and pointers which don't have a textual representation in the Pure
syntax and will be printed in the format ``#<``\ object description\ ``>``
by default. It is also possible to override the print representation of any
kind of expression by means of the ``__show__`` function, see the `Caveats and
Notes`_ section for details.

上に示されているように、対話モードでは、式が入力された後、正規形のトップレベル式が出力されます。私たちはこれを `read-eval-print` ループ〔読み込み-評価-出力ループ〕とも呼んでいます。通常、正規形の式は、あなたが入力したものとまったく同じ形で出力されます。しかし特殊オブジェクトもいくつか存在しており、無名クロージャ、サンク（必要になったとき「遅延評価される」〔＝怠惰な／lazy〕値）、ポインタなどは、 Pure 文法における文字表現がありません。そのため、デフォルトでの出力は ``#<``\ object description\ ``>`` といった形式で行われます。また、 ``__show__`` 関数を使うと、いかなる式の出力表現でもオーバーライド〔上書き〕することができます。詳しくは `Caveats and Notes`_ セクションを参照して下さい。

Online Help
-----------

オンラインヘルプ

Online help is available in the interpreter with the interactive ``help``
command, see `Interactive Commands`_ below. You need to have a html browser
installed for that. By default, the ``help`` command uses w3m(1), but you can
change this by setting either the PURE_HELP or the BROWSER environment
variable accordingly.

インタープリタ内で対話コマンド ``help`` を使うとオンラインヘルプを利用できます。詳しくは下部 `Interactive Commands`_ を参照して下さい。 html ブラウザがインストールされている必要があります。デフォルトでは、 ``help`` コマンドは w3m(1) を使います。しかし環境変数 PURE_HELP または BROWSER のいずれかを使って設定を変更できます。

When invoked without arguments, the ``help`` command displays this manual:

`` help`` コマンドが引数なしで実行されると、このマニュアルが表示されます::

  > help

The ``help`` command also accepts a parameter which lets you specify a topic
to show in the accompanying Pure Library manual, e.g.:

また ``help`` コマンドは、パラメータとして Pure Library Manual に付いているトピックを受け入れます。例えば::

  > help foldl

The help files distributed with the Pure interpreter are located in the Pure
library directory (/usr/local/lib/pure by default). You can install additional
documentation in html format in this directory, and look up topics in those
help files with a command like the following:

ヘルプファイルは Pure インタープリタとともに配布されており、 Pure のライブラリディレクトリ（デフォルトでは /usr/local/lib/pure ）に置かれています。 html フォーマットの追加ドキュメントをこのディレクトリにインストールすることができ、そのヘルプファイル内のトピックをコマンドラインから、次のようにして探せます::

  > help mydoc#foo

Here ``mydoc`` is the basename of your help file (library path and .html
suffix are supplied automatically), and ``foo`` can be any link target in the
document (as specified with a ``<a name=...>`` tag or an ``id`` attribute in
the html source). To just read the mydoc.html file without specifying a
target, type the following:

ここで ``mydoc`` はヘルプファイルの基礎名（ライブラリのパスと拡張子 .html は自動的に付加されます）で、 ``foo`` はファイル内のどのリンクターゲットでもかまいません（ html ソース内 ``<a name=...>`` タグまたは ``id`` 属性での指定に従う）。ただ mydoc.html を読みたいだけでターゲットは必要ないなら、次のようにタイプします::

  > help mydoc#

Note that just ``help mydoc`` wouldn't work, since it would look for an entry
``mydoc`` in the standard library documentation.

ただ ``help mydoc`` とするだけでは動作しないことを覚えておいて下さい。その場合は標準ライブラリドキュメント内の ``mydoc`` 部分を探してしまいます。

If the basename of the help file is missing, it defaults to the library
manual, so ``help #foldl`` does the same as ``help foldl``, and just ``help
#`` is a convenient shorthand to bring up the library manual without a
specific topic. Of course, this syntax also works for looking up sections in
the Pure manual:

基礎名がヘルプファイルに見つからない場合、ライブラリマニュアルがデフォルトとなります。なので ``help #foldl`` は ``help foldl`` と同じことであり、単に ``help #`` とすると、特定トピックを指定せずライブラリマニュアルを表示する速記法となります。もちろん、この文法は Pure マニュアル内のセクションを参照する際にも機能します::

  > help pure#declarations

Note that the docutils_ tools used to generate the html source of the Pure
manual mangle the section titles so that they are in lowercase and blanks are
replaced with hyphens. So to look up the present section in this manual you'd
have to type:

Pure マニュアルの html ソースを生成するのに使われている docutils_ ツールは、セクションタイトルを切り分け、小文字化し、スペースをハイフンで置き換えます。なので、このマニュアルに存在するセクションを参照するには次のようにタイプします::

  > help pure#online-help

.. _docutils: http://docutils.sourceforge.net/

You can also point the help browser to a proper URL, either a local file or
some website (provided that your browser program can handle these). For
instance:

ヘルプブラウザに対して、ローカルファイルもしくはウェブサイトへの厳密な URL を指定することもできます（ブラウザプログラムがそれらを扱える場合）。例えば::

  > help file:mydoc.html#foo
  > help http://pure-lang.googlecode.com

Interactive Commands
--------------------

対話コマンド

When running interactively, the interpreter accepts a number of special
commands useful for interactive purposes. Here is a quick rundown of the
currently supported operations:

対話モードで実行されているとき、インタープリタは様々な目的に適したたくさんの特別コマンドを受け入れます。ここでは現在サポートされている処理を簡単にまとめます:

``! command``
    Shell escape.

    シェルエスケープ。

``break [symbol ...]``
    Sets breakpoints on the given function or operator symbols. All symbols
    must be specified in fully qualified form, see the remarks below. If
    invoked without arguments, prints all currently defined breakpoints. This
    requires that the interpreter was invoked with the -g option to enable
    debugging support. See Debugging_ below for details.

    与えられた関数または演算子シンボルに対してブレークポイントを設定します。シンボルは全て完全な修飾子つき形式で定義される必要があります。詳しくは下部を参照してください。もし引数なしで実行された場合、現在設定されているブレークポイントをすべて表示します。こうした動作には、インタープリタを -g オプション付きで起動し、デバッグサポートを有効にしておく必要があります。詳しくは下部 Debugging_ を参照して下さい。

``bt``
    Prints a full backtrace of the call sequence of the most recent evaluation,
    if that evaluation ended with an unhandled exception. This requires
    that the interpreter was invoked with the -g option to enable debugging
    support. See Debugging_ below for details.

    最も直近に行われた評価が、処理されないままの例外で終了した場合、その評価に関する呼び出しシーケンスの完全なバックトレースを出力します。この動作には、インタープリタを -g オプション付きで起動し、デバッグサポートを有効にしておく必要があります。詳しくは下部 Debugging_ を参照して下さい。

``cd dir``
    Change the current working dir.

    カレントワーキングディレクトリを変更します。

``clear [option ...] [symbol ...]``
    Purge the definitions of the given symbols (functions, macros, constants
    or global variables). All symbols must be specified in fully qualified
    form, see the remarks below. If invoked as ``clear ans``, clears the
    ``ans`` value (see `Last Result`_ below). When invoked without any
    arguments, ``clear`` purges all definitions at the current interactive
    "level" (after confirmation) and returns you to the previous level, if
    any. (It might be a good idea to first check your current definitions with
    ``show`` or back them up with ``dump`` before you do that.) The desired
    level can be specified with the -t option. See the description of the
    ``save`` command and `Definition Levels`_ below for further details. A
    description of the common options accepted by the ``clear``, ``dump`` and
    ``show`` commands can be found in `Specifying Symbol Selections`_ below.

    与えられたシンボルの定義を除去します（関数、マクロ、定数、グローバル変数）。シンボルは全て完全な修飾子つき形式で定義される必要があります。詳しくは下部の説明を参照してください。 ``clear ans`` として実行された場合、 ``ans`` 値がクリアされます（下部 `Last Result`_ 参照）。 ``clear`` が引数なしで実行された場合、現在の対話「レベル」にある全定義を（確認手続きの後に）除去します（実行前にまず ``show`` コマンドで現在の定義をチェックするか、または ``dump`` コマンドでバックアップしておくのは良い考えでしょう）。必要なレベルを設定するには -t オプションを使います。より詳しい説明は下部 ``save`` コマンド解説や `Definition Levels`_ を参照して下さい。 ``clear``, ``dump``, ``show`` コマンドが受け入れる共通オプションは下部 `Specifying Symbol Selections`_ に載っています。

``del [symbol ...]``
    Deletes breakpoints on the given function or operator symbols. All symbols
    must be specified in fully qualified form, see the remarks below. If
    invoked without arguments, clears all currently defined breakpoints (after
    confirmation). See Debugging_ below for details.

    与えられた関数または演算子シンボルに対するブレークポイントを削除します。シンボルは全て完全な修飾子つき形式で定義される必要があります。詳しくは下部を参照してください。引数なしで実行された場合、設定されている全ブレークポイントを（確認手続きの後に）除去します。詳しくは下部 Debugging_ を参照して下さい。

``dump [-n filename] [option ...] [symbol ...]``
    Dump a snapshot of the current function, macro, constant and variable
    definitions in Pure syntax to a text file. All symbols must be specified
    in fully qualified form, see the remarks below. This works similar to the
    ``show`` command (see below), but writes the definitions to a file. The
    default output file is .pure in the current directory, which is then
    reloaded automatically the next time the interpreter starts up in
    interactive mode in the same directory. This provides a quick-and-dirty
    way to save an interactive session and have it restored later, but note
    that this isn't perfect yet. In particular, declarations of ``extern``
    symbols won't be saved unless they're specified explicitly, and some
    objects like closures, thunks and pointers don't have a textual
    representation from which they could be reconstructed. To handle these,
    you'll probably have to prepare a corresponding .purerc file yourself, see
    `Interactive Startup`_ below.

    現在の関数・マクロ・定数・変数の Pure 文法での定義をスナップショットとしてテキストファイルにダンプします。シンボルは全て完全な修飾子つき形式で定義される必要があります。詳しくは下部を参照してください。これは ``show`` コマンド（下を参照）と同じように動作しますが、定義をファイルへ書き込む点が違います。デフォルトの出力ファイルはカレントディレクトリの .pure となります。このファイルは、次回インタープリタが同じディレクトリ内で対話モードとして起動された際に自動的に読み込まれます。これは対話セッションを保存し後で復旧するための quick-and-dirty な方法を提供しています。ただし、完全に保存・復旧できるわけではないことも覚えておいて下さい。特に、 ``extern`` シンボル宣言は、明示的に指定しない限り行われません。また、いくつかのオブジェクト（クロージャ、サンク、ポインタなど）はテキストでの表現手段を持たないので、そこから再構築することもできません。これらを扱うには、目的に応じて .purerc を用意しなければなりません。下部 `Interactive Startup`_ を参照して下さい。

    A different filename can be specified with the -n option, which expects
    the name of the script to be written in the next argument, e.g: ``dump -n
    myscript.pure``. You can then edit that file and use it as a starting
    point for an ordinary script or a .purerc file, or you can just run the
    file with the ``run`` command (see below) to restore the definitions in a
    subsequent interpreter session.

    異なるファイル名を定義するには -n オプションを使います。このオプションは、引数として保存するスクリプト名を想定します。例えば ``dump -n myscript.pure`` といった形です。保存した後、そのファイルを編集し、通常のスクリプト用や .purerc ファイル用のスターティングポイントとすることができます。あるいは、単に ``run`` コマンド（下を参照）を使ってファイルを実行させ、保存した定義をその後のインタープリタセッション内に復旧することもできます。

``help [target]``
    Display the Pure manual or some other bit of documentation. In particular,
    ``help foo`` looks up the symbol ``foo`` in the Pure Library manual. See
    `Online Help`_ above for details.

    Pure マニュアルや、他のドキュメントの一部を表示します。特に ``help foo`` は Pure Library Manual 内から ``foo`` シンボルを調べます。詳しくは上部 `Online Help`_ を参照して下さい。

``ls [args]``
    List files (shell ls(1) command).

    ファイルをリストします（シェルの ls(1) コマンドを利用）。

``mem``
    Print current memory usage. This reports the number of expression cells
    currently in use by the program, along with the size of the freelist (the
    number of allocated but currently unused expression cells). Note that the
    actual size of the expression storage may be somewhat larger than this,
    since the runtime always allocates expression memory in bigger chunks.
    Also, this figure does not reflect other heap-allocated memory in use by
    the program, such as strings or malloc'ed pointers.

    現在のメモリ消費量を表示します。プログラムが使用している expression cells の数をレポートします along with the size of the freelist （割り当てられてはいるが使用されていない expression cells）。 expression storage の実際のサイズはこれよりも若干大きくなります。なぜならランタイムは常に expression memory をやや大きな塊で割り当てるからです。また、この数値は、プログラムが使用している他のヒープ割り当てメモリ（文字列や malloc されているポインタなど）を反映していません。

``override``
    Enter "override" mode. This allows you to add equations "above" existing
    definitions in the source script, possibly overriding existing
    equations. See `Definition Levels`_ below for details.

    「上書き」モードに入ります。このモードでは、ソーススクリプト内の既存定義の「上に」等式を追加することができます。既存の定義を上書きする可能性があります。詳しくは下部 `Definition Levels`_ を参照して下さい。

``pwd``
    Print the current working dir (shell pwd(1) command).

    カレントワーキングディレクトリを表示します（シェルの pwd(1) を使用）。

``quit``
    Exits the interpreter.

    インタープリタを終了します。

``run script``
    Loads the given script file and adds its definitions to the current
    environment. This works more or less like a ``using`` clause, but only
    searches for the script in the current directory and places the
    definitions in the script at the current temporary level, so that
    ``clear`` can be used to remove them again. In particular, this makes it
    possible to quickly reload a script without exiting the interpreter, by
    issuing the ``clear`` command followed by ``run``. (This works best if you
    start out from a clean environment, with no scripts loaded on the command
    line.)

    スクリプトファイルを読み込み、現在の環境に定義を追加します。これは多かれ少なかれ ``using`` 節のように機能しますが、検索されるのはカレントディレクトリ内のスクリプトだけで、そのスクリプト内の定義を at the current temporary level に置きます。その結果、再び ``clear`` を使ってその定義を消去することもできます。特に、 ``clear`` を発行した後に ``run`` を実行することで、インタープリタを一度終了させなくてもスクリプトを素早く再読み込みすることができます（これは、コマンドラインで何もスクリプトを読み込ませず、きれいな状態で起動した環境では最高に機能します）。

    Also note that namespace and pragma settings of scripts loaded with
    ``run`` stick around after loading the script. This allows you to quickly
    set up your environment by just running a script containing the necessary
    namespace declarations and compiler directives. (Alternatively, you can
    also use the interpreter's startup files for that purpose, see
    `Interactive Startup`_ below.)

    また、 ``run`` コマンドで読み込まれたスクリプト内の、名前空間およびプラグマの設定は、スクリプトを読み込んだ後も付いて回ります。これにより、必要な名前空間定義ととコンパイラディレクティブを書き込んだスクリプトを実行するだけで、あなたの環境を素早く設定することができます（他にも、インタープリタのスタートアップファイルをこの目的で使うこともできます。下部 `Interactive Startup`_ を参照）。

``save``
    Begin a new level of temporary definitions. A subsequent ``clear`` command
    (see above) will purge the definitions made since the most recent ``save``
    command. See `Definition Levels`_ below for details.

    temporary definitions の新しいレベルを開始します。これに続く ``clear`` コマンド（上を参照）は、直近の ``save`` コマンド以降の定義を除去します。詳しくは下部 `Definition Levels`_ を参照して下さい。

``show [option ...] [symbol ...]``
    Show the definitions of symbols in various formats. See `The show
    Command`_ below for details. All symbols must be specified in fully
    qualified form, see the remarks below. A description of the common options
    accepted by the ``clear``, ``dump`` and ``show`` commands can be found in
    `Specifying Symbol Selections`_ below.

    シンボルの定義を様々なフォーマットで表示します。詳しくは `The show Command`_ を参照して下さい。シンボルは全て完全な修飾子つき形式で定義される必要があります。詳しくは下部を参照してください。 ``clear``, ``dump``, ``show`` コマンドが受け入れる共通オプションは下部 `Specifying Symbol Selections`_ に載っています。

``stats [-m] [on|off]``
    Enables (default) or disables "stats" mode, in which some statistics are
    printed after an expression has been evaluated. Invoking just ``stats`` or
    ``stats on`` only prints the cpu time in seconds for each evaluation. If
    the ``-m`` option is specified, memory usage is printed along with the cpu
    time, which indicates the maximum amount of expression memory (in terms of
    expression cells) used during the computation. Invoking ``stats off``
    disables stats mode, while ``stats -m off`` just disables the printing of
    the memory usage statistics.

    "stats" モードの有効・無効を切り替えます（デフォルトでは有効）。 "stats" モードでは、式が評価された後にいくつかの統計が表示されます。 ``stats`` または ``stats on`` と入力すると、各評価にかかった CPU 時間（秒）が表示されます。もし ``-m`` オプションが定義されると、 CPU 時間とともにメモリ使用量が表示されます。このメモリ使用量は、計算中に使われた expression memory （セル単位）の最大量を示します。 ``stats off`` を実行すると stats モードを無効にします。 ``stats -m off`` とした場合はメモリ使用統計の表示だけを無効にします。

``underride``
    Exits "override" mode. This returns you to the normal mode of operation,
    where new equations are added "below" previous rules of an existing
    function. See `Definition Levels`_ below for details.

    「上書き」モードを終了します。このコマンドにより通常モードの処理へ戻ります。通常モードでは新たな等式は既存関数の前のルールの「下に」追加されます■。詳しくは下部 `Definition Levels`_ を参照して下さい。

Note that these special commands are only recognized at the beginning of the
interactive command line (they are not reserved keywords of the Pure
language). Thus it's possible to "escape" identifiers looking like commands by
entering a space at the beginning of the line.

これらの特別コマンドは、対話モードプロンプト行の先頭でのみ認識されることに注意して下さい（コマンドは Pure 言語の予約語ではありません）。したがって、行の先頭にスペースを入力することで、コマンドのように見える識別子を "エスケープ" できます。

Also note that symbols (identifiers, operators etc.) must always be specified
in fully qualified form. No form of namespace lookup is performed by these
commands, so they always work the same no matter what ``namespace`` and
``using namespace`` declarations are currently in effect.

また、シンボル（識別子、演算子などなど）は常に完全な修飾子つき形式で指定されなければなりません。これらのコマンドでは名前空間検索が行われません。そのため、シンボルを引数に取るコマンドは、 ``namespace`` や ``using namespace`` 宣言が有効なときでも常に関係なく同じ動作となります。

Last Result
-----------

Another convenience for interactive usage is the ``ans`` function, which
retrieves the most recent result printed in interactive mode. For instance:

もう一つ対話モードで便利なのが ``ans`` 関数で、最も最近表示された結果を引き出します。例えば::

  > fact n = if n<=1 then 1 else n*fact (n-1);
  > map fact (1..10);
  [1,2,6,24,120,720,5040,40320,362880,3628800]
  > scanl (+) 0 ans;
  [0,1,3,9,33,153,873,5913,46233,409113,4037913]

Note that ``ans`` is just an ordinary function, defined in the prelude, not
a special command. However, there is a special ``clear ans`` command which
purges the ``ans`` value. This is useful, e.g., if you got a huge result
which you want to erase from memory before starting the next computation.

``ans`` は普通の関数の一つであり、 prelude で定義されているもので、特別なコマンドではないことを覚えておいて下さい。しかし対話モードには ``clear ans`` という特別コマンドがあり、 ``ans`` の値を消去できます。このコマンドは例えば、メモリ上に巨大な結果を持っていて、次の計算へ移る前にそれを消しておきたい場合に便利です。

::

  > clear ans
  > ans;
  ans

Specifying Symbol Selections
----------------------------

シンボル選択を定義する

The ``clear``, ``dump`` and ``show`` commands all accept the following options
for specifying a subset of symbols and definitions on which to operate. All
symbols must be specified in fully qualified form. Options may be combined,
thus, e.g., ``show -mft`` is the same as ``show -m -f -t``. Some options
specify optional numeric parameters; these must follow immediately behind the
option character if present, as in ``-t0``.

``clear``, ``dump``, ``show`` コマンドは次のコマンドを共通して受け入れます。これらのコマンドで、処理したいシンボルや定義のサブセットを定義することができます。

-c
    Selects defined constants.

    定義済み定数を選択します。

-f
    Selects defined functions.

    定義済み関数を選択します。

-g
    Indicates that the following symbols are actually shell glob patterns and
    that all matching symbols should be selected.

    この後に続くシンボルがシェルグロブパターンであることを示し、それにマッチするシンボルが選択されるよう指定します。

-m
    Select defined macros.

    定義済みマクロを選択します。

-pflag
    Select only private symbols if *flag* is nonzero (the default), otherwise
    (*flag* is zero) select only public symbols. If this option is omitted
    then both private and public symbols are selected.

    *flag* 部分が非ゼロ（デフォルト）である場合、 private なシンボルだけを選択します。そうでない（ *flag* がゼロである）場合、 public なシンボルだけを選択します。このオプションが省略された場合、 private および public なシンボルが選択されます。

-tlevel
    Select symbols and definitions at the given "level" of definitions and
    above. This is described in more detail below. Briefly, the executing
    program and all imported modules (including the prelude) are at level 0,
    while "temporary" definitions made interactively in the interpreter are at
    level 1 and above. Thus a level of 1 restricts the selection to all
    temporary definitions, whereas 0 indicates all definitions (i.e.,
    everything, including the prelude). If *level* is omitted, it defaults to
    the current definitions level.

    与えられた "level" 以上の階層にあるシンボルと定義を選択します。これについては下部に詳しい説明があります。簡単に言うと、実行中のプログラムとインポートされているモジュール（ prelude を含む）がレベル 0 であり、対話モードのインタープリタで作られた「一時的な」定義はレベル 1 以上となります。したがってレベルを 1 と指定した場合、選択対象は全ての一時的定義までに制限されます。それに対して、 0 を指定すると、全定義（すなわち、 prelude を含めたあらゆるもの）を対象とすることになります。もし *level* が省略された場合、現在の定義レベルがデフォルトとなります。

-v
    Select defined variables.

    定義済み変数を選択します。

In addition, the -h option prints a short help message describing all
available options of the command at hand.

加えて、 -h オプションは、利用可能な全コマンドオプションの簡単なヘルプメッセージを出力します。

If none of the -c, -f, -m and -v options are specified, then all kinds of
symbols (constants, functions, macros and variables) are selected, otherwise
only the specified categories will be considered.

-c, -f, -m, -v のいずれも指定されない場合、全種類のシンボル（定数、関数、マクロ、変数）が選択されます。いずれかが指定された場合、指定されたカテゴリーだけが考慮されます。

A reasonable default is used if the -t option is omitted. By default, if no
symbols are specified, only temporary definitions are considered, which
corresponds to -t1. Otherwise the command applies to all corresponding
definitions, no matter whether they belong to the executing program, the
prelude, or some temporary level, which has the same effect as -t0. This
default choice can be overridden by specifying the desired level explicitly.

-t オプションが省略された場合、 reasonable なオプションが使用されます。デフォルトでは、シンボルが指定されていない場合、 一時的な定義だけが考慮されます（ -t1 を指定したのと同じ）。何らかの指定がある場合、コマンドはその指定に対応する全ての定義に対して適用されます。その対象が属しているのが実行中のプログラムであろうと、 prelude であろうと、いずれかの一時的レベルであろうと関係ありません。これは -t0 指定と同じ効果にあたります。必要なレベルを明示的に指定することで、このデフォルト指定を上書きすることができます。

As a special case, just ``clear`` (without any other options or symbol
arguments) always backs out to the previous definitions level (instead of
level #1). This is inconsistent with the rules set out above, but is
implemented this way for convenience and backward compatibility. Thus, if you
really want to delete all your temporary definitions, use ``clear -t1``
instead. When used in this way, the ``clear`` command will only remove
temporary definitions; if you need to remove definitions at level #0, you must
specify those symbols explicitly.

特別なケースとして、ただ ``clear`` と入力する（他にオプションやシンボル引数を何も付けない）と、常に直前の定義レベルが返されます（ level #1 の代わりに）。これは上のルールセットと相反することですが、便利さと後方互換性のためにこのように実装されています。したがって、もし一時的な定義を全て削除したいなら、代わりに ``clear -t1`` を使って下さい。こうすると、 ``clear`` コマンドは一時的な定義だけを消去します。 level #0 の定義を消去する必要があるなら、それらのシンボルを明示的に指定しなければなりません。

Note that ``clear -g *`` will have pretty much the same disastrous
consequences as the Unix command ``rm -rf *``, so don't do that. Also note
that a macro or function symbol may well have defining equations at different
levels, in which case a command like ``clear -tn foo`` might only affect some
part of ``foo``'s definition. The ``dump`` and ``show`` commands work
analogously (albeit less destructively). See `Definition Levels`_ below for
some examples.

``clear -g *`` は Unix コマンド ``rm -rf *`` とよく似た破滅的な結果となりますので、実行しないよう注意して下さい。また、マクロや関数のシンボルは、異なるレベルにある定義等式を持っている可能性がかなりあり、その場合 ``clear -tn foo`` は ``foo`` の定義の一部だけにしか効果が及ばないことにも注意して下さい。 ``dump`` と ``show`` コマンドの動作は似ています（albeit less destructively）。下部 `Definition levels`_ にいくつか具体例があります。

The show Command
----------------

The ``show`` command can be used to obtain information about defined symbols
in various formats. Besides the common selection options discussed above, this
command recognizes the following additional options for specifying the content
to be listed and the format to use.

``show`` コマンドを使うと、定義済みシンボルに関する情報を様々なフォーマットで取得できます。このコマンドは、上で議論された選択オプションに加えて、次のような追加オプションを認識します。これらのオプションは、リストされる内容や表示フォーマットを指定するためのものです。

-a
    Disassembles pattern matching automata. Works like the -v4 option of the
    interpreter.

    パターンマッチングオートマトンを逆アセンブルします。インタープリタの -v4 オプションと同じように機能します。

-d
    Disassembles LLVM IR, showing the generated LLVM assembler code of a
    function. Works like the -v8 option of the interpreter.

    LLVM IR を逆アセンブルし、ある関数の LLVM アセンブラコードを表示します。インタープリタの -v8 オプションと同じように機能します。

-e
    Annotate printed definitions with lexical environment information (de
    Bruijn indices, subterm paths). Works like the -v2 option of the
    interpreter.

    表示される定義に、レキシカル環境情報（ de Bruijn インデックス、下位項パス）を注記します。インタープリタの -v2 オプションと同じように機能します。

-l
    Long format, prints definitions along with the summary symbol
    information. This implies -s.

    ロングフォーマットで、つまり定義とともに summary symbol information を出力します。 -s の意味を含みます。

-s
    Summary format, print just summary information about listed symbols.

    サマリーフォーマット、つまりリストされるシンボルの summary information を出力します。

Symbols are always listed in lexicographic order. Note that some of the
options (in particular, -a and -d) may produce excessive amounts of
information. By setting the PURE_MORE environment variable, you can specify a
shell command to be used for paging, usually more(1) or less(1).

シンボルは常に lexicographic な順序でリストされます。オプションのうちいくつか（特に -a と -d ）はとても多量の情報を生み出す可能性がありますので、気をつけて下さい。 PURE_MORE 環境変数を使って、ページングに使うシェルコマンド（たいていは more(1) か less(1) ）を指定できます。

For instance, to list all temporary definitions made in an interactive
session, simply say:

例えば、ある対話セッション中に作った一時的定義をすべてリストするには、次のようにします::

  > show

You can also list a specific symbol, no matter whether it comes from the
interactive command line, the executing script or the prelude:

また、特定のシンボルをリストすることもできます。そのシンボルが対話コマンドで作られたものか、あるいは実行中のスクリプトや prelude で作られたかは関係ありません::

  > show foldl
  foldl f a x::matrix = foldl f a (list x);
  foldl f a s::string = foldl f a (chars s);
  foldl f a [] = a;
  foldl f a (x:xs) = foldl f (f a x) xs;

Wildcards can be used with the -g option, which is useful if you want to print
an entire family of related functions, e.g.:

-g オプションとともにワイルドカードを指定することもできます。関連する関数ファミリーの全体を出力したいときに便利です::

  > show -g foldl*
  foldl f a x::matrix = foldl f a (list x);
  foldl f a s::string = foldl f a (chars s);
  foldl f a [] = a;
  foldl f a (x:xs) = foldl f (f a x) xs;
  foldl1 f x::matrix = foldl1 f (list x);
  foldl1 f s::string = foldl1 f (chars s);
  foldl1 f (x:xs) = foldl f x xs;

Or you can just specify multiple symbols as follows (this also works with
multiple glob patterns when you add the -g option):

あるいは、次のようにただ複数のシンボルを指定することもできます（ -g オプションを追加した場合には複数の glob パターンとも同時に機能します）。

  > show min max
  max x y = if x>=y then x else y;
  min x y = if x<=y then x else y;

You can also select symbols by category. E.g., the following command shows
summary information about all the variable symbols along with their current
values (using the "long" format):

シンボルをカテゴリーで選択することもできます。例えば、次のコマンドは全ての変数シンボルについて要約情報を（「ロング」フォーマットで）表示します::

  > show -lvg *
  argc       var  argc = 0;
  argv       var  argv = [];
  compiling  var  compiling = 0;
  sysinfo    var  sysinfo = "x86_64-unknown-linux-gnu";
  version    var  version = "0.37";
  5 variables

Or you can list just private symbols of the namespace ``foo``, as follows:

あるいは、 ``foo`` 名前空間のプライベートシンボルだけを表示するには、次のようにします::

  > show -pg foo::*

The following command will list each and every symbol that's currently defined
(instead of ``-g *`` you can also use the ``-t0`` option):

次のコマンドは、現在定義されている全シンボルをそれぞれリストします（ ``-g *`` の代わりに ``-t0`` オプションを使うこともできます）::

  > show -g *

This usually produces a lot of output and is rarely needed, unless you'd like
to browse through an entire program including all library imports. (In that
case you might consider to use the ``dump`` command instead, which writes the
definitions to a file which can then be loaded into a text editor for easier
viewing. This may occasionally be useful for debugging purposes.)

このコマンドは通常、多量の出力を行い、またほとんど必要となることはないでしょう。ライブラリのインポートを含め、プログラム全体を通して閲覧したいと思うなら別ですが（その場合は代わりに ``dump`` コマンドの使用を検討して下さい。 ``dump`` コマンドは定義情報をファイルに書き込み、テキストエディタで簡単に読み込める状態にします。デバッグ目的ならこの方法が役に立つこともあるでしょう）。

Finally, there are two alternate forms of the ``show`` command: ``show
namespace`` which lists the current and search namespaces, and ``show
namespaces`` which lists all declared namespaces. These come in handy if you
have forgotten what namespaces are currently active and which other namespaces
are available in your program. For instance:

最後に、 ``show`` コマンドの他の形式を 2 つ示します。 ``show namespace`` はカレント名前空間と検索用名前空間をリストします。そして ``show namespaces`` は宣言済み名前空間をすべリストします。この 2 つは、現在有効な名前空間が何であったか忘れたときや、自分のプログラム内でどの名前空間が利用可能かわからなくなったときに便利です。具体的には::

  > show namespace
  > show namespaces
  namespace C;
  namespace matrix;
  > using namespace C;
  > namespace my;
  > show namespace
  namespace my;
  using namespace C;

Definition Levels
-----------------

定義レベル

To help with incremental development, the interpreter offers some facilities
to manipulate the current set of definitions interactively. To these ends,
definitions are organized into different subsets called `levels`. As already
mentioned, the prelude, as well as other source programs specified when
invoking the interpreter, are always at level 0, while the interactive
environment starts at level 1.

incremental development を助けるため、インタープリタは、現在の定義セットをインタラクティブに操作する機能をいくつか提供します。この目的のため、定義は複数の異なるサブセットに編成されます。このサブセットは `レベル` と呼ばれます。すでに述べた通り、 prelude や、インタープリタ起動時に定義される他のソースプログラムは、すべてレベル 0 に置かれます。対話環境はレベル 1 からスタートします。

Each ``save`` command introduces a new temporary level, and each subsequent
``clear`` command (without any arguments) "pops" the definitions on the
current level and returns you to the previous one (if any). This gives you a
"stack" of temporary environments which enables you to "plug and play" in a
(more or less) safe fashion, without affecting the rest of your program. For
all practical purposes, this stack is unlimited, so that you can create as
many levels as you like. Example:

``save`` コマンドは毎回、新たな一時的レベルを 1 つ導入します。また、後に続く ``clear`` コマンド（引数なし）はカレントレベルにある定義をすべて "pop" し、（もし存在するなら）一つ前のレベルへあなたを戻します。これにより、一時的な環境の「スタック」を使うことができ、プログラムの他の部分に影響を与えることなく（だいたいは）安全なやり方で「プラグ・アンド・プレイ」を行うことができます。実用的なものとするため、このスタックの数は無制限なので、好きなだけたくさんのレベルを作ることができます。例えば::

  > foo (x:xs) = x+foo xs;
  > foo [] = 0;
  > show
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > foo (1..10);
  55
  > clear
  This will clear all temporary definitions at level #1.
  Continue (y/n)? y
  > show
  > foo (1..10);
  foo [1,2,3,4,5,6,7,8,9,10]

We've seen already that normally, if you enter a sequence of equations, they
will be recorded in the order in which they were written. However, it is also
possible to override definitions in lower levels with the ``override``
command:

私たちはもう、一連の等式を打ち込んだ場合、それが書かれた順に記録されていくことを普通のものと感じます。しかし、 ``override`` コマンドを使うと、下位レベルにある定義を上書きすることもできます::

  > foo (x:xs) = x+foo xs;
  > foo [] = 0;
  > show
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > foo (1..10);
  55
  > save
  save: now at temporary definitions level #2
  > override
  > foo (x:xs) = x*foo xs;
  > show
  foo (x:xs) = x*foo xs;
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > foo (1..10);
  warning: rule never reduced: foo (x:xs) = x+foo xs;
  0

Note that the equation ``foo (x:xs) = x*foo xs;`` was inserted before the
previous ``foo (x:xs) = x+foo xs;`` rule, which is at level #1. (The latter
equation is now "shadowed" by the rule we just entered, hence the compiler
warns us that this rule can't be reduced any more.)

``foo (x:xs) = x*foo xs;`` という等式が、レベル #1 にある ``foo (x:xs) = x+foo xs;`` ルールの直前に挿入されたことに注目して下さい（後者の等式は、打ち込んだばかりの等式の「陰に隠れて」います。そのためコンパイラは、そのルールが決して reduced されないことを警告しています）。

Even in override mode, new definitions will be added after other definitions
at the *current* level. This allows us to just continue adding more
high-priority definitions overriding lower-priority ones:

上書きモードにおいてさえ、新たな定義は *カレント* レベルにある他の定義の後ろに追加されます。このことにより、優先度の低い定義を上書きして優先度のより高い等式を追加し続けることができます::

  > foo [] = 1;
  > show
  foo (x:xs) = x*foo xs;
  foo [] = 1;
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > foo (1..10);
  warning: rule never reduced: foo (x:xs) = x+foo xs;
  warning: rule never reduced: foo [] = 0;
  3628800

Again, the new equation was inserted above the existing lower-priority rules,
but below our previous ``foo (x:xs) = x*foo xs;`` equation entered at the same
level. As you can see, we have now effectively replaced our original
definition of ``foo`` with a version that calculates list products instead of
sums, but of course we can easily go back one level to restore the previous
definition:

もう一度、新たな定義は優先度の低い既存ルールよりも前に挿入されました。しかしその下で、前の等式 ``foo (x:xs) = x*foo xs;`` が同じレベルに入っています。ご覧の通り、私たちは今や実際に、 ``foo`` のオリジナル定義を別のバージョンに置き換えました。別のバージョンは、合計の代わりに list products を計算します。しかし、もちろん私たちは簡単にレベルを1つ戻して前バージョンの定義を有効にすることができます::

  > clear
  This will clear all temporary definitions at level #2.
  Continue (y/n)? y
  clear: now at temporary definitions level #1
  clear: override mode is on
  > show
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > foo (1..10);
  55

Note that ``clear`` reminded us that override mode is still enabled (``save``
will do the same if override mode is on while pushing a new definitions
level). To turn it off again, use the ``underride`` command. This will revert
to the normal behaviour of adding new equations below existing ones:

まだ上書きモードが有効であること ``clear`` コマンドがを思い出させてくれている点に注目して下さい（上書きモードが有効な状態で新たな定義レベルを push した場合、 ``save`` コマンドもまったく同じことをしてくれるでしょう）。上書きモードを再びオフにするには ``underride`` コマンドを使います。オフにすると、新たな定義を既存定義の下に追加する通常動作へ復帰します::

  > underride

Finally, it's also possible to use ``clear`` to back out multiple levels at
once, if you specify the target level to be cleared with the -t option. For
instance:

最後に、 ``clear`` コマンドを使って複数のレベルを一度に取り消すことも可能です。 -t オプションとクリアすべきレベルを指定します。例えば::

  > save
  save: now at temporary definitions level #2
  > let bar = 99;
  > show
  let bar = 99;
  foo (x:xs) = x+foo xs;
  foo [] = 0;
  > clear -t1 // this scraps all our scribblings!
  This will clear all temporary definitions at level #1 and above.
  Continue (y/n)? y
  clear: now at temporary definitions level #1
  > show
  >

Debugging
---------

デバッグ

The interpreter provides a simple but reasonably convenient symbolic debugging
facility when running interactively. To make this work, you have to specify
the -g option when invoking the interpreter:

インタープリタは、対話モードで実行されているとき、シンプルながら適度に便利なシンボリックデバッグ機能を提供します。この機能を有効にするには、インタープリタ起動時に -g オプションを指定します::

  $ pure -g

This option disables tail call optimization (see `Stack Size and Tail
Recursion`_) to make it easier to debug programs. It also causes special
debugging code to be generated which will make your program run *much*
slower. Therefore the -g option should only be used if you actually need the
debugger.

このオプションは末尾呼び出し最適化〔tail call optimization〕（ `Stack Size and Tail Recursion`_ 参照）を無効にすることで、プログラムのデバッグを容易にします。また、特別なデバッグ用コードを追加するので、あなたのプログラムは *かなり* 遅くなります。したがって -g オプションを使うのは本当にデバッガが必要な場合だけにすべきです。

One common use of the debugger is "post mortem" debugging after an evaluation
ended with an unhandled exception. In such a case, the ``bt`` command of the
interpreter prints a backtrace of the call sequence which caused the
exception. Note that this only works if debugging mode was enabled. For
instance:

よくあるデバッガの使い方として、ある評価がハンドルされない例外で終了した後に "post mortem" デバッグを行うことがあります。このようなケースで、インタープリタの ``bt`` コマンドを使うと、例外を引き起こした呼び出しシーケンスのバックトレースが出力されます。ただしデバッグモードが有効な場合のみ機能することを忘れないで下さい。例えば::

  > [1,2]!3;
  <stdin>, line 2: unhandled exception 'out_of_bounds' while evaluating '[1,2]!3'
  > bt
     [1] (!): (x:xs)!n::int = xs!(n-1) if n>0;
       n = 3; x = 1; xs = [2]
     [2] (!): (x:xs)!n::int = xs!(n-1) if n>0;
       n = 2; x = 2; xs = []
     [3] (!): []!n::int = throw out_of_bounds;
       n = 1
  >> [4] throw: extern void pure_throw(expr*) = throw;
       x1 = out_of_bounds

The last call, which is also marked with the ``>>`` symbol, is the call that
raised the exception. The format is similar to the ``p`` command of the
debugger, see below, but ``bt`` always prints a full backtrace. (As with the
``show`` command of the interpreter, you can set the PURE_MORE environment
variable to pipe the output through the corresponding command, or use
|evalcmd|_ to capture the output of ``bt`` in a string, cf. Reflection_.)

最後の呼び出し（ ``>>`` 記号でもマークされている）は例外を発生させた呼び出しです。フォーマットはデバッグの ``p`` コマンドと似ていますが、 ``bt`` は常に完全なバックトレースを出力します（インタープリタの ``show`` コマンドのときと同じように、 PURE_MORE 環境変数を設定すると、設定されたプログラムに出力が渡されます。あるいは |evalcmd|_ を使うと ``bt`` の出力を文字列としてキャプチャできます。 cf. Reflection_ ）。

The debugger can also be used interactively. To these ends, you can set
breakpoints on functions with the ``break`` command. The debugger then gets
invoked as soon as a rule for one of the given functions is
executed. Example:

デバッガを対話的に使うこともできます。そうするには、 ``break`` コマンドを使って関数にブレークポイントを設定します。すると、ブレークポイントが設定されている関数のルールのうち一つが実行されたときにデバッガが起動します。例えば::

  > fact n::int = if n>0 then n*fact (n-1) else 1;
  > break fact
  > fact 1;
  ** [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
  (Type 'h' for help.)
  :
  ** [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 0
  :
  ++ [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 0
       --> 1
  ** [2] (*): x::int*y::int = x*y;
       x = 1; y = 1
  :
  ++ [2] (*): x::int*y::int = x*y;
       x = 1; y = 1
       --> 1
  ++ [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
       --> 1
  1

Lines beginning with ``**`` indicate that the evaluation was interrupted to
show the rule (or external) which is currently being considered, along with
the current depth of the call stack, the invoked function and the values of
parameters and other local variables in the current lexical environment. In
contrast, the prefix ``++`` denotes reductions which were actually performed
during the evaluation and the results that were returned by the function call
(printed as ``--> return value``).

``**`` で始まっている行は次のことを示しています。ルール（または external）を表示するために中断されたこと、コールスタックの深さ、実行された関数、パラメータの値、現在のレキシカル環境にあるその他のローカル変数です。対照的に ``++`` プレフィクスが示しているのは、評価の間に実際に行われた変形〔reductions〕と、関数呼び出しが返した結果（ ``--> return value`` と出力されている）です。

Sometimes you might also see funny symbols like ``#<case>``, ``#<when>`` or
``#<closure>`` instead of the function name. These indicate lambdas and the
special variable-binding environments, which are all implemented as anonymous
closures in Pure. Also note that the debugger doesn't know about the argument
names of external functions (which are optional in Pure and not recorded
anywhere), so it will display the generic names ``x1``, ``x2`` etc. instead.

時おりあなたは、関数名の代わりに ``#<case>`` や ``#<when>`` 、 ``#<closure>`` といった妙な記号を目にすることもあるでしょう。これらはが示すのは、ラムダと、変数に束縛された特別な環境で、 Pure においては全て無名クロージャとして実装されています。また、デバッガは external 関数の引数名を何も知りません（ Pure では optionals であり、どこにも記録されません）。その代わり ``x1``, ``x2`` などなど総称的な名前で表示されます。

At the debugger prompt '``:``' you can enter various special debugger
commands, or just keep on hitting the carriage return key to walk through an
evaluation step by step, as we did in the example above. (Command line editing
works as usual at the debugger prompt, if it is enabled.) The usual commands
are provided to walk through an evaluation, print and navigate the call stack,
step over the current call, or continue the evaluation unattended until you
hit another breakpoint. If you know other source level debuggers like gdb then
you should feel right at home. You can type ``h`` at the debugger prompt to
print the following list:

デバッガのプロンプト '``:``' では様々なデバッガ用特別コマンドを入力できます。あるいは、上の例でそうしたように、ただリターンを叩き続けると評価を一段階ごとに通覧する〔walk through〕ことができます（コマンドライン編集はデバッガプロンプトでも通常通り機能します（有効になっていれば））。通常のコマンドには、評価を通覧するもの、出力するもの、コールスタックを移動するもの、 current call を step over するもの、次のブレークポイントに当たるまで立ち止まらずに評価を継続するものがあります。もし gdb のような他のソースレベルデバッガを使えるならなじみやすいものでしょう。デバッガプロンプトで ``h`` とタイプすると次のリストが出力されます::

  : h
  Debugger commands:
  a       auto: step through the entire program, run unattended
  a       auto: プログラム全体を通り抜け、立ち止まらず実行
  c [f]   continue until next breakpoint, or given function f
  c [f]   次のブレークポイントか、与えられた関数 f まで継続
  h       help: print this list
  h       help: このリストを出力
  n       next step: step over reduction
  n       next step: 次の変形をステップオーバー
  p [n]   print rule stack (n = number of frames)
  p [n]   ルールスタックを出力（n = フレーム数）
  r       run: finish evaluation without debugger
  r       run: デバッガなしで評価を終了
  s       single step: step into reduction
  s       single step: 変形へステップイン
  t, b    move to the top or bottom of the rule stack
  t, b    ルールスタックの先頭〔top〕または末尾〔bottom〕へ移動
  u, d    move up or down one level in the rule stack
  u, d    ルールスタック層を1レベル上へ移動、または下へ移動
  x       exit the interpreter (after confirmation)
  x       インタープリタを終了（確認あり）
  .       reprint current rule
  .       現在のルールを再表示
  ! cmd   shell escape
  ! cmd   シェルエスケープ
  ? expr  evaluate expression
  ? expr  式〔expression〕を評価
  <cr>    single step (same as 's')
  <cr>    シングルステップ（ 's' と同じ）
  <eof>   step through program, run unattended (same as 'a')
  <eof>   プログラムを通り抜け、立ち止まらず実行（ 'a' と同じ）

The command syntax is very simple. Besides the commands listed above you can
also enter comment lines (``// comment text``) which will just be
ignored. Extra arguments on commands which don't expect any will generally be
ignored as well. The single letter commands all have to be separated from any
additional parameters with whitespace, whereas the '``!``', '``?``' and
'``.``' commands count as word delimiters and can thus be followed immediately
by an argument. For convenience, the '``?``' command can also be omitted if
the expression to be evaluated doesn't start with a single letter or one of
the special punctuation commands.

コマンド文法はとてもシンプルです。上にリストされているコマンドに加え、コメント行（ ``// コメントテキスト`` ）を入力することもできます（単純に無視される）。引数をひとつも取らないコマンドへの追加引数もまた、通例は無視されます。全ての1文字コマンドは、パラメータとの間がスペースで区切られていなければなりません。それに対して '``!``' 、 '``?``' および '``.``' コマンドは区切り文字の一つに数えられるので、直後に引数を置くことができます。評価されるべき式が1文字で始まらない場合か、特別な句読点文字〔 !/?/. 〕で始まらない場合、便宜のため、 '``?``' コマンドを省略することができます。

The debugger can be exited or suspended in the following ways:

デバッガは次の方法で中断・終了することができます:

* You can type ``c`` to continue the evaluation until the next breakpoint, or
  ``c foo`` in order to proceed until the debugger hits an invokation of the
  function ``foo``.

* ``c`` とタイプすると、次のブレークポイントまで評価を継続します〔continue〕。あるいは ``c foo`` とすると、デバッガが ``foo`` 関数の呼び出しに出会うまで進みます。

* You can type ``r`` to run the rest of the evaluation without the debugger.

* ``r`` とタイプすると、デバッガなしで残りの評価を実行します。

* The ``a`` ("auto") command single-steps through the rest of the evaluation,
  running unattended. This command can also be entered by just hitting the
  end-of-file key (``Ctrl-D`` on Unix systems) at the debugger prompt.

* ``a`` （"auto"）コマンドは、立ち止まらずに残りの評価を single-steps through します。デバッガプロンプトで end-of-file キー（ Unix システム上では ``Ctrl-D`` ）を叩くだけでもこのコマンドを入力できます。

* You can also type ``x`` to exit from the debugger *and* the interpreter
  immediately (after confirmation).

* ``x`` とタイプすると、デバッガ *および* インタープリタを（確認後）すぐに終了します。

At the debugger prompt, you can use the ``u`` ("up"), ``d`` ("down"), ``t``
("top") and ``b`` ("bottom") commands to move around on the current call
stack. The ``p`` command prints a range of the call stack centered around the
currently selected stack frame, which is indicated with the ``>>`` tag,
whereas ``**`` denotes the current bottom of the stack (which is the rule to
be executed with the single step command). The ``p`` command can also be
followed by a numeric argument which indicates the number of stack frames to
be printed (this will then become the default for subsequent invocations of
``p``). The ``n`` command steps over the call selected with the stack
navigation commands. For instance:

デバッガプロンプトにおいて ``u`` ("up"), ``d`` ("down"), ``t`` ("top"), ``b`` ("bottom") コマンドを使うと、カレントコールスタック上を動き回ることができます。 ``p`` コマンドは、現在選択されているスタックフレームを中心とした一定範囲のコールスタックを出力します。現在選択されているスタックフレームは ``>>`` タグで示され、 ``**`` は現在のスタックの末尾〔bottom〕を示しています（which はシングルステップコマンドによって実行されるルールです）。また、 ``p`` コマンドには数値引数を追加することができます。こ数値の引数は、出力されるべきスタックフレームの数を示すものです。（この設定は後に続く ``p`` コマンドのデフォルトともなります）。 ``n`` コマンドはスタック移動コマンドによって選択されている呼び出しをステップオーバーします。例えば::

  > fact 3;
  ** [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 3
  : c *
  ** [4] (*): x::int*y::int = x*y;
       x = 1; y = 1
  : p
     [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 3
     [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 2
     [3] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
  ** [4] (*): x::int*y::int = x*y;
       x = 1; y = 1
  : u
  >> [3] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
  : u
  >> [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 2
  : p
     [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 3
  >> [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 2
     [3] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
  ** [4] (*): x::int*y::int = x*y;
       x = 1; y = 1
  : n
  ++ [2] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 2
       --> 2
  ** [2] (*): x::int*y::int = x*y;
       x = 3; y = 2
  :

If you ever get lost, you can reprint the current rule with the '``.``'
command:

もし現在のルールを忘れてしまったら、 '``.``' コマンドで再表示できます::

  : .
  ** [2] (*): x::int*y::int = x*y;
       x = 3; y = 2

Another useful feature is the ``?`` command which lets you evaluate any Pure
expression, with the local variables of the current rule bound to their
corresponding values. Like the ``n`` command, ``?`` applies to the current
stack frame as selected with the stack navigation commands. The expression
must be entered on a single line, and the trailing semicolon is optional. For
instance:

もう一つ便利な機能は ``?`` コマンドです。これであらゆる Pure 式を、カレントルールのローカル変数（それぞれの値に束縛されている）を使いながら評価することができます。 ``n`` コマンドと同じく、 ``?`` はカレントスタックフレーム（スタック移動コマンドでの選択に従う）に対して適用されます。この式は1行で入力されなければならず、末尾のセミコロンの有無は問いません。例えば::

  > fact 3;
  ** [1] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 3
  : c *
  ** [4] (*): x::int*y::int = x*y;
       x = 1; y = 1
  : ?x+y
  2
  : u
  >> [3] fact: fact n::int = if n>0 then n*fact (n-1) else 1;
       n = 1
  : n>0, fact n
  1,1

Note that the current set of breakpoints can only be changed with the
``break`` and ``del`` commands of the interpreter, see `Interactive Commands`_
above. Use ``break`` without arguments to list the currently defined
breakpoints. Breakpoints can be deleted with the ``del`` command, which is
followed by the function and operator symbols to be removed from the
breakpoint list. If ``del`` is invoked without arguments, it clears all
breakpoints (after confirmation).

ブレークポイントのカレントセットはインタープリタの ``break`` および ``del`` コマンドでしか変更できません。上部 `Interactive Commands`_ を参照して下さい。引数なしで ``break`` を使うと、現在定義されているブレークポイントをリストできます。ブレークポイントは ``del`` コマンドで削除できます。削除したい関数シンボルや演算子シンボルをコマンドの後ろに指定します。 ``del`` が引数なしで実行された場合、全ブレークポイントを（確認後に）削除します。

Interactive Startup
-------------------

In interactive mode, the interpreter also runs some additional scripts at
startup, after loading the prelude and the scripts specified on the command
line. This lets you tailor the interactive environment to your liking.

対話モードにおいて、インタープリタは起動時に追加スクリプトをいくつか実行します。この追加スクリプトは prelude とコマンドラインで指定されたスクリプトを読み込んだ後に実行されます。これにより、あなた好みの対話環境を仕立てることができます。

The interpreter first looks for a .purerc file in the user's home directory
(as given by the HOME environment variable) and then for a .purerc file in the
current working directory. These are just ordinary Pure scripts which may
contain any additional definitions that you need. The .purerc file in the home
directory is for global definitions which should always be available when
running interactively, while the .purerc file in the current directory can be
used for project-specific definitions.

インタープリタはまずユーザのホームディレクトリ（ HOME 環境変数により与えられる）から .purerc ファイルを探し、次にカレントワーキングディレクトリから .purerc ファイルを探します。これらは単なる普通の Pure スクリプトであり、必要な追加定義をいくらでも入れることができます。ホームディレクトリの .purerc ファイルはグローバル定義のためのもので、対話モードにおいては常に使うことができるものとなります。それに対してカレントディレクトリの .purerc ファイルはプロジェクト固有の定義のために使えるものです。

Finally, you can also have a .pure initialization file in the current
directory, which is usually created with the ``dump`` command (see
above). This file is loaded after the .purerc files if it is present.

最後に、カレントディレクトリ内に初期化ファイル .pure を置くこともできます。これは通例 ``dump`` コマンド（上を参照）によって作られます。このファイルが読み込まれるのは .purerc ファイル（もしあれば）の直後です。

The interpreter processes all these files in the same way as with the ``run``
command (see above). When invoking the interpreter, you can specify the --norc
option on the command line if you wish to skip these initializations.

インタープリタはこれらのファイル全てを同じ方法で、つまり ``run`` コマンド（上部参照）を使って処理します。

Batch Compilation
=================

バッチコンパイル

As of Pure 0.21, the interpreter has a new -c option which provides a
convenient means to turn Pure scripts into standalone executables. This
feature is still a bit experimental right now. In particular, note that the
compiled executable is essentially a *static snapshot* of your program which
is executed on the "bare metal", without a hosting interpreter. Only a minimal
runtime system is provided. This considerably reduces startup times, but also
implies the following quirks and limitations:

Pure 0.21 以降では、インタープリタが -c オプションを持っています。このオプションは Pure スクリプトをスタンドアローンの実行ファイルへと変える便利な手段を提供します。この機能は今でもやや実験的なものです。特に、コンパイルされた実行ファイルが本質的に、あなたのプログラムの *静的スナップショット* であることを忘れないで下さい。このスナップショットは "bare metal" 〔むき出しの金属？〕の上で実行され、ホストするインタープリタはありません。最小限のランタイムシステムだけが提供されます。これにより起動時間はかなり短くなりますが、同時に次のようなクセと制限を含んでいます:

.. _eval: purelib.html#eval
.. _evalcmd: purelib.html#evalcmd
.. |eval| replace:: ``eval``
.. |evalcmd| replace:: ``evalcmd``

* All toplevel expressions and ``let`` bindings are evaluated *after* all
  functions have been defined. This might cause inconsistent behaviour with an
  interpreted run of the same program, which executes expressions and variable
  definitions immediately, as the program is being processed. To avoid these
  semantic differences, you'll have to make sure that expressions are
  evaluated *after* all functions used in the evaluation have been defined
  completely.

* 全トップレベル式と全 ``let`` 束縛は、全関数が定義された *後で* 評価されます。これにより、同じプログラムをインタープリタで実行した場合と一貫しない挙動が起こるかもしれません。インタープリタでは式と変数の定義を、プログラムの処理に沿ってすぐに行います。このような意味の〔＝セマンティックな〕違いを避けるには、式が評価される *前に* その式の中で使われる全関数が完全に定義される状態を確かなものとしなければなりません。

* Toplevel expressions won't be of much use in a batch-compiled program,
  unless, of course, they are evaluated for their side-effects. Usually your
  program will have to include at least one of these to play the role of the
  "main program" in your script. In most cases these expressions are best
  placed after all the function and variable definitions, at the end of your
  program.

* トップレベル式は、バッチコンパイルされたプログラムではあまり使われません。ただしもちろん、トップレベル式が副作用のために評価されるのでない限りです。通例、あなたのプログラムは、 "main program" の役を担う式を少なくとも一つスクリプト内に含んでいなければなりません。多くのケースでは、全関数と全変数が定義された後に、つまりプログラムの末尾にトップレベル式を置くのがベストです。

* The |eval|_ function can only be used to evaluate plain toplevel
  expressions.  You can define local functions and variables in ``with`` and
  ``when`` clauses inside an expression, but you can't use ``eval`` to define
  new global variables and functions. In other words, anything which changes
  the executing program is "verboten". Moreover, the introspective
  capabilities provided by |evalcmd|_ (discussed under Reflection_ in the
  `Caveats and Notes`_ section) won't work either because the interactive
  commands are all disabled. If you need any of these capabilities, you have
  to run your program with the interpreter.

* |eval|_ 関数が使えるのは plain toplevel expressions の評価に対してだけです。式の中では ``with`` 節や ``when`` 節内でローカル関数やローカル変数を定義できますが、 ``eval`` を使ってグローバル変数やグローバル関数を定義することはできません。言い換えるなら、実行中のプログラムを変更するものは何であれ「禁止されている」のです。さらに言えば、 |evalcmd|_ （ `Caveats and Notes`_ セクション内 Reflection_ で議論されている）による introspective capabilities もまた機能しません。なぜなら、対話コマンドは全て無効にされるからです。もしこの機能のうちの何かが必要なら、プログラムをインタープリタで実行しなければなりません。

* Constant and macro definitions, being compile time features, aren't
  available in the compiled program. If you need to use these with |eval|_ at
  run time, you have to provide them through variable and function definitions
  instead. Also, the compiler usually strips unused functions from the output
  code, so that only functions which are actually called somewhere in the
  static program text are available to ``eval``. (The -u option and the
  --required pragma can be used to avoid this, see `Code Size and Unstripped
  Executables`_ below.)

* 定数とマクロの定義は、コンパイル時の機能であるため、コンパイル済みプログラムでは使えません。実行時に両者を |eval|_ とともに使う必要があるなら、その代わりに変数と関数の定義を通じて提供しなければなりません。また、通常では、コンパイラは出力コードから未使用の関数を除去してしまうので、 ``eval`` で使えるのは、静的なプログラムテキスト内のどこかで実際に呼び出される関数だけとなります（ -u オプションと --required プラグマを使えばこれを避けられます。下部 `Code Size and Unstripped Executables`_ を参照）。

* Code which gets executed to compute constant values at compile time will
  *not* be executed in the compiled executable, so your program shouldn't rely
  on side-effects of such computations (this would be bad practice anyway).
  Also, constant values in a batch-compiled script must be real constants, run
  time data such as pointers (other than the null pointer) and local functions
  are not permitted. (If necessary, you can bind such values to variables
  instead, then they will work fine even in a batch-compiled program.)

* コンパイル時に定数値を計算するため実行されるコードは、コンパイル済み実行ファイル内では実行 *されません* 。なので、あなたのプログラムはこうした計算の副作用に依存すべきではありません（いずれにせよこれはバッド・プラクティスです）。また、バッチコンパイルされたスクリプト内の定数値は real constant でなければなりません。ポインタ（ヌルポインタ以外）のような実行時データとローカル関数は許されません（もし必要なら、代わりにそのような値を変数へバインドすることができます。そうすればバッチコンパイル済みプログラム内でも見事に動作するはずです）。

What all this boils down to is that anything which requires the compile time
or interactive facilities of the interpreter, is unavailable. These
restrictions only apply at run time, of course. At compile time the program
*is* being executed by the interpreter so you can use |eval|_ and |evalcmd|_
in any desired way. See the description of the ``compiling`` variable below
for how to distinguish these cases in your script.

つまり煎じ詰めて言うと、コンパイル時にしか動作しないものや、インタープリタの対話機能を必要とするものは、何であろうと使えないわけです。もちろんこうした制限は実行時にのみ適用されます。コンパイル時に、プログラムはインタープリタによって実行 *されている* ので、 {eval|_ と |evalcmd|_ を思い通り使うことができます。あなたのスクリプト内で両ケースをどう区別したらよいかについて、以下にある ``compiling`` 変数の説明を参照して下さい。

For most kinds of scripts, the above restrictions aren't really that much of
an obstacle, or can easily be worked around. For the few scripts which
actually need the full dynamic capabilities of Pure you'll just have to run
the script with the interpreter. This isn't a big deal either, only the
startup will be somewhat slower because the script is compiled on the
fly. Once the JIT has done its thing the "interpreted" script will run every
bit as fast as the "compiled" one, since in fact *both* are compiled (only at
different times) to exactly the same code!

ほとんどの種類のスクリプトにとっては、上のような制限が実際の障害物となることはないか、あるとしても簡単に回り道できることでしょう。 Pure のダイナミックな性能を本当にフル活用しなければならないような数少ないスクリプトなら、インタープリタを使って実行する必要があります。これは大げさなことではなく、スクリプトがオン・ザ・フライでコンパイルされるため起動時間がいくらか長くなるだけです。一度 JIT が仕事を終えると、「解釈済み」〔"interpreted"〕スクリプトは「コンパイル済み」〔"compiled"〕のそれとあらゆる面で同じくらい速く実行されるはずです。実際のところ、 *どちらも* まったく同じコードへとコンパイルされる（そのタイミングだけが異なる）わけですから！

Also note that during a batch compilation, the compiled program is actually
executed as usual, i.e., the script is also run *at compile time*. This might
first seem to be a big annoyance, but it actually opens the door for some
powerful programming techniques like `partial evaluation`_. It is also a
necessity because of Pure's highly dynamic nature. For instance, Pure allows
you to define constants by evaluating an arbitrary expression (see `Constant
Definitions`_ below), and using ``eval`` a program can easily modify itself in
even more unforeseeable ways. Therefore pretty much anything in your program
can actually depend on previous computations performed while the program is
being executed.

また、バッチコンパイルの最中、コンパイルされるプログラムは通常通り実際に実行されます。すなわち、スクリプトは *コンパイル時にも* 実行されるわけです。最初はとても迷惑なことに思えるかもしれませんが、実はそれがいくつかの強力なプログラミングテクニック（ `partial evaluation`_ のような）への扉を開いてもくれるのです。また、これは Pure の highly dynamic nature のために必要なことでもあります。例えば、 Pure では任意の式を評価することで定数を定義でき（下部 `Constant Definitions`_ 参照）、また ``eval`` を使うことで、プログラムが自分自身をかなり予想しづらい方法で部分修正することもできます。したがって、あなたのプログラムのかなり多くの部分が、実行時に行われる計算に依存することになります。■原文の言わんとすることをよく掴めていない■

.. _partial evaluation: http://en.wikipedia.org/wiki/Partial_evaluation

Example
-------

具体例

For the sake of a concrete example, consider the following little script:

具体的な例として、次の小さなスクリプトを考えてみて下さい::

  using system;

  fact n = if n>0 then n*fact (n-1) else 1;

  main n = do puts ["Hello, world!", str (map fact (1..n))];

  if argc<=1 then () else main (sscanf (argv!1) "%d");

When invoked from the command line, with the number ``n`` as the first
parameter, this program will print the string ``"Hello, world!"`` and the list
of the first ``n`` factorials:

``n`` を第一引数としてコマンドラインから実行されると、このプログラムは文字列 ``"Hello, world!"`` と、最初の ``n`` 階乗のリストを出力します::

  $ pure -x hello.pure 10
  Hello, world!
  [1,2,6,24,120,720,5040,40320,362880,3628800]

Note the condition on ``argc`` in the last line of the script. This prevents
the program from producing an exception if no command line parameters are
specified, so that the program can also be run interactively:

最終行にある ``argc`` の条件に注目して下さい。これはコマンドラインで引数が指定されない場合にプログラムが例外を起こすことを防いでいます。そのため、このプログラムを対話的に実行することも可能です::

  $ pure -i -q hello.pure
  > main 10;
  Hello, world!
  [1,2,6,24,120,720,5040,40320,362880,3628800]
  ()
  > quit

To turn the script into an executable, we just invoke the Pure interpreter
with the -c option, using the -o option to specify the desired output file
name:

スクリプトを実行ファイルに変えるには、 Pure インタープリタを -c オプションとともに起動するだけです。 -o オプションを使ってお好みの出力ファイル名を指定します::

  $ pure -c hello.pure -o hello
  $ ./hello 10
  Hello, world!
  [1,2,6,24,120,720,5040,40320,362880,3628800]

Next suppose that we'd like to supply the value ``n`` at *compile* rather than
run time. To these ends we want to turn the value passed to the ``main``
function into a compile time constant, which can be done as follows:

次は、実行時でなく *コンパイル時* に ``n`` 値を与えたい場合を考えましょう。こうするには、 ``main`` 関数に渡される値をコンパイル時の定数に変更したいわけですが、次のようにします::

  const n = if argc>1 then sscanf (argv!1) "%d" else 10;

(Note that we provide ``10`` as a default if ``n`` isn't specified on the
command line.)

（コマンドラインで引数が指定されない場合のデフォルトとして ``10`` を与えていることに注意して下さい）

Moreover, in such a case we usually want to skip the execution of the main
function at compile time. The Pure runtime provides a special system variable
``compiling`` which holds a truth value indicating whether the program is
actually running under the auspices of the batch compiler, so that it can
adjust accordingly. In our example, the evaluation of ``main`` becomes:

さらに、このような場合、通常私たちは、コンパイル時にメイン関数の実行をスキップしたいと考えます。 Pure ランタイムは特別なシステム変数 ``compiling`` を提供しています。この変数は真偽値を保持し、プログラムがバッチコンパイラの庇護の下で実際に実行されるかどうかを示します。これにより、必要に応じて調整が可能です。私たちの例では、 ``main`` の評価は次のようになります::

  if compiling then () else main n;

Our program now looks as follows:

これで私たちのプログラムは次のようになりました::

  using system;

  fact n = if n>0 then n*fact (n-1) else 1;

  main n = do puts ["Hello, world!", str (map fact (1..n))];

  const n = if argc>1 then sscanf (argv!1) "%d" else 10;
  if compiling then () else main n;

This script "specializes" ``n`` to the first (compile time) parameter when
being batch-compiled, and it still works as before when we run it through the
interpreter in both batch and interactive mode, too:

このスクリプトでは、バッチコンパイルされる場合、 ``n`` を（コンパイル時の）第一引数に "specializes" しています。また、前までと同じく、インタープリタのバッチモードでも対話モードでも実行することができます::

  $ pure -i -q hello.pure
  Hello, world!
  [1,2,6,24,120,720,5040,40320,362880,3628800]
  > main 5;
  Hello, world!
  [1,2,6,24,120]
  ()
  > quit

  $ pure -x hello.pure 7
  Hello, world!
  [1,2,6,24,120,720,5040]

  $ pure -o hello -c -x hello.pure 7
  $ ./hello
  Hello, world!
  [1,2,6,24,120,720,5040]

You'll rarely need an elaborate setup like this, most of the time something
like our simple first example will do the trick. But, as you've seen, Pure can
easily do it.

このように精巧な設定が必要となることはほとんどなく、たいていの場合は最初のシンプルな例のようなもので事足りてしまうでしょう。しかし、ご覧の通り、 Pure では簡単にできることなのです。

Code Size and Unstripped Executables
------------------------------------

コードサイズと Unstripped Executables

By default, the batch compiler strips unused functions from the output code,
to keep the code size small. You can disable this with the -u option, in which
case the output code includes *all* functions defined in the compiled program
or imported through a ``using`` clause, even if they don't seem to be used
anywhere. This considerably increases compilation times and makes the compiled
executable much larger. For instance, on a 64 bit Linux systems with ELF
binaries the executable of our hello.pure example is about thrice as large:

デフォルトでは、バッチコンパイラは使われない関数を出力コードから除去し、コードサイズを小さく保ちます。 -u オプションを使うとこの機能を無効にできます。無効にした場合、出力コードは、コンパイルされたプログラム内で定義されている関数と、 ``using`` 節を通じてインポートされた関数を *すべて* 含むことになります。どこでも使われていないように見えるものさえも含みます。こうするとコンパイルにかかる時間はかなり増え、実行ファイルはかなり大きくなります。例えば、 ELF バイナリを使う 64 ビット Linux システムでは、例に使った hello.pure の実行ファイルが3倍ほど大きくなります::

  $ pure -o hello -c -x hello.pure 7 && ls -l hello
  -rwxr-xr-x 1 ag users 178484 2010-01-12 06:21 hello
  $ pure -o hello -c -u -x hello.pure 7 && ls -l hello
  -rwxr-xr-x 1 ag users 541941 2010-01-12 06:21 hello

(Note that even the stripped executable is fairly large when compared to
compiled C code, as it still contains the symbol table of the entire program,
which is needed by the runtime environment.)

（不要部分を除去した実行ファイル〔stripped executable〕であっても、コンパイルされた C コードと比べれば相当大きくなることを覚えておいて下さい。なぜなら、その実行ファイルはプログラム全体のシンボルテーブルをまだ含んでいるからです。このシンボルテーブルはランタイム環境が必要とするものです）

Stripped executables should be fine for most purposes, but you have to be
careful when using ``eval`` in your compiled program. The compiler only does a
*static* analysis of which functions might be reached from the initialization
code (i.e., toplevel expressions and ``let`` bindings). It does *not* take
into account code run via the ``eval`` routine. Thus, functions used only in
``eval``\ ed code will be stripped from the executable, as if they were never
defined at all. If such a function is then being called using ``eval`` at
runtime, it will evaluate to a plain constructor symbol.

Stripped executables はほとんどの目的にとって十分なものでしょう。しかしプログラム中で ``eval`` を使うときは気をつけなければいけません。コンパイラは初期化コード（つまりトップレベル式と ``let`` 束縛）から到達される関数を *静的に* しか解析しません。これは ``eval`` ルーチンを通じて実行されるコードを考慮に入れ *ません* 。したがって、 ``eval`` されるコード内でしか使われない関数は実行ファイルから除去されてしまい、まったく定義されなかったのと同じ状態になります。もしこのような関数が実行時に ``eval`` を使って呼び出されると、 plain constructor symbol を評価することになります。

If this is a problem then you can either use the -u option to produce an
unstripped executable, or you can force functions to be included in the
stripped executable with the ``--required`` pragma (cf. `Code Generation
Options`_). For instance:

プログラムがある場合、あなたは -u オプションを使って unstripped executable を作るか、あるいは ``--required`` プラグマを使って関数が stripped executables に含まれるよう強制することができます（cf. `Code Generation Options`_ ）。::

  #! --required foo
  foo x = bar (x-1);
  eval "foo 99";

Other Output Code Formats
-------------------------

その他の出力コードフォーマット

Note that while the batch compiler generates native executables by default, it
can just as well create object files which can be linked into other C/C++
programs and libraries:

バッチコンパイラはデフォルトではネイティブな実行ファイルを生成しますが、他にも、オブジェクトファイルを生成して他の C/C++ プログラムやライブラリへリンクすることも可能であることを覚えておいて下さい::

  $ pure -o hello.o -c -x hello.pure 7

The .o extension tells the compiler that you want an object file. When linking
the object module, you also need to supply an initialization routine which
calls the ``__pure_main__`` function in hello.o to initialize the compiled
module. This routine is declared in C/C++ code as follows:

.o 拡張子はコンパイラに、あなたがオブジェクトファイルを望んでいることを伝えます。オブジェクトモジュールをリンクする場合、あなたは追加の初期化ルーチンを追加しなければなりません。このルーチンは hello.o 内で ``__pure_main__`` 関数を呼び出し、コンパイルされたモジュールを初期化します。このルーチンは C/C++ コードで次のように宣言されています::

  extern "C" void __pure_main__(int argc, char** argv);

As indicated, ``__pure_main__`` is to be invoked with two parameters, the
argument count and NULL-terminated argument vector which become the ``argc``
and the ``argv`` of the Pure program, respectively. (You can also just pass 0
for both arguments if you don't need to supply command line parameters.) The
purpose of ``__pure_main__`` is to initialize a shell instance of the Pure
interpreter which provides the minimal runtime support necessary to execute
the Pure program, and to invoke all "initialization code" (variable
definitions and toplevel expressions) of the program itself.

ここに示されているように、 ``__pure_main__`` は2つのパラメータとともに呼び出されます。一つは引数の数、もう一つはヌル文字で終わる引数ベクターで、それぞれ Pure プログラムの ``argc`` と ``argv`` にあたります（コマンドラインパラメータを使わない場合には、ただ両方に 0 を渡してもかまいません）。 ``__pure_main__`` の目的は Pure インタープリタのシェルインスタンスを初期化することにあり、これによって最小限のランタイムサポートが提供されます。このランタイムサポートは、 Pure プログラムを実行するために、また全「初期化コード」（変数定義とトップレベル式）を呼び出すために必要なものです。

A minimal C ``main`` function which does the job of initializing the Pure
module looks as follows:

Pure モジュールを初期化する役を担う、 C の最小限の ``main`` 関数は次のようなものです::

  extern void __pure_main__(int argc, char** argv);

  int main(int argc, char** argv)
  {
    __pure_main__(argc, argv);
    return 0;
  }

If you link the ``main`` routine with the Pure module, don't forget to also
pull in the Pure runtime library. Assuming that the above C code is in
pure_main.c:

``main`` ルーチンを Pure モジュールにリンクするなら、 Pure ランタイムライブラリにそれを引き込むことも忘れないで下さい。上の C コードが pure_main.c であるとすると::

  $ gcc -c pure_main.c -o pure_main.o
  $ g++ -o hello hello.o pure_main.o -lpure
  $ ./hello
  Hello, world!
  [1,2,6,24,120,720,5040]

(The C++ compiler is used as the linker here so that the standard C++ library
gets linked in, too. This is necessary because Pure's runtime library is
actually written in C++.)

（ここでは C++ コンパイラをリンカとして使っており、その結果標準 C++ ライブラリも一緒にリンクされています。 Pure ランタイムライブラリは実際には C++ で書かれているので、必要なことです）

In fact, this is pretty much what ``pure -c`` actually does for you when
creating an executable.

実のところ、これは実行ファイルを作ろうとしたときに ``pure -c`` が行うことと、まさに同じです。

If your script loads dynamic libraries (``using "lib:...";``) then you'll also
have to link with those; *all* external references have to be resolved at
compile time. This is taken care of automatically when creating
executables. Otherwise it is a good idea to run ``pure -c`` with the
``-v0100`` verbosity option so that it prints the libraries to be linked (in
addition to the commands which are invoked in the compilation process):

もしあなたのスクリプトが動的ライブラリを読み込む（ ``using "lib:...";`` ）ならば、あなたはそのライブラリをリンクしなければなりません。 *全* 外部参照はコンパイル時に解決されなければならないのです。実行ファイルを作る際には、自動的にこれらを面倒見てくれます。そうでない場合、 ``pure -c`` を饒舌オプション ``-v0100`` とともに実行するのは良いアイデアです。こうすると、リンクされるライブラリが出力されます（コンパイルの過程で呼び出されるコマンドに加えて）::

  $ pure -v0100 -c hello.pure -o hello.o
  opt -f -std-compile-opts hello.o.bc | llc -f -o hello.o.s
  gcc -c hello.o.s -o hello.o
  Link with: g++ hello.o -lpure

Well, we already knew that, so let's consider a slightly more interesting
example from Pure's ODBC module:

さて、これでやり方はわかったので、もう少し興味深い例を Pure の ODBC モジュールから取り、考えてみましょう::

  $ pure -v0100 -c pure-odbc/examples/menagerie.pure -o menagerie.o
  opt -f -std-compile-opts menagerie.o.bc | llc -f -o menagerie.o.s
  gcc -c menagerie.o.s -o menagerie.o
  Link with: g++ menagerie.o /usr/local/lib/pure/odbc.so -lpure
  $ g++ -shared -o menagerie.so menagerie.o /usr/local/lib/pure/odbc.so -lpure

Note that the listed link options are necessary but might not be sufficient;
``pure -c`` just makes a best guess based on the Pure source. On most systems
this will be good enough, but if it isn't, you can just add options to the
linker command as needed to pull in additional required libraries.

リストされているリンクオプションは必要なものばかりですが、十分ではないことに注意して下さい。 ``pure -c`` は Pure ソースを基礎として best guess を行います。ほとんどのシステム上ではそれで十分なのですが、そうではなかった場合、リンカコマンドにオプションを追加して、必要な追加ライブラリを引き込む必要があります。

As this last example shows, you can also create shared libraries from Pure
modules. However, on some systems (most notably x86_64), this requires that
you pass the ``-fPIC`` option when batch-compiling the module, so that
position-independent code is generated:

この最後の例が示す通り、あなたは Pure モジュールから共有ライブラリを作り出すこともできます。しかし、いくつかのシステム（特に x86_64 ）上では、モジュールをバッチコンパイルする際に ``-fPIC`` オプションを渡す必要があります。そうすると、位置に依存しないコードが生成されます::

  $ pure -c -fPIC pure-odbc/examples/menagerie.pure -o menagerie.o

Also note that even when building a shared module, you'll have to supply an
initialization routine which calls ``__pure_main__`` somewhere.

また、共有モジュールをビルドするときでさえも、あなたは初期化ルーチンを提供する必要があります。初期化ルーチンはどこかで ``__pure_main__`` モジュールを呼び出します。

Last but not least, ``pure -c`` can also generate just plain LLVM assembler
code:

最後になりましたが、 ``pure -c`` はプレーンな LLVM アセンブラコードを生成することもできます::

  pure -c hello.pure -o hello.ll

Note the .ll extension; this tells the compiler that you want an LLVM
assembler file. An LLVM bitcode file can be created just as easily:

.ll 拡張子に注目して下さい。これにより、あなたが LLVM アセンブラファイルを望んでいることがコンパイラに伝わります。 LLVM ビットコードファイルを作り出すことも簡単にできます::

  pure -c hello.pure -o hello.bc

In these cases you'll have to have to handle the rest of the compilation
yourself. This gives you the opportunity, e.g., to play with special
optimization and code generation options provided by the LLVM
toolchain. Please refer to the `LLVM documentation`_ (in particular, the
description of the opt and llc programs) for details.

このようなケースでは、あなたは残りのコンパイル過程を自分で扱わなければなりません。そのとき、例えば LLVM ツールチェーンが提供する特別な最適化オプションやコード生成オプションを使用する機会も与えられているわけです。詳しいことは `LLVM documentation`_ （特に opt と llc プログラムについての解説）を参照して下さい。

.. _LLVM documentation: http://llvm.org/docs/

Calling Pure Functions From C
-----------------------------

Pure 関数を C から呼び出す

Another point worth mentioning here is that you can't just call Pure functions
in a batch-compiled module directly. That's because in order to call a Pure
function, at least in the current implementation, you have to set up a Pure
stack frame for the function. However, there's a convenience function called
``pure_funcall`` in the runtime API to handle this. This function takes a
pointer to the Pure function, the argument count and the arguments themselves
(as ``pure_expr*`` objects) as parameters. For instance, here is a pure_main.c
module which can be linked against the hello.pure program from above, which
calls the ``fact`` function from the Pure program:

ここで述べておくに値することをもう一つ。 Pure 関数をバッチコンパイルされたモジュール内からただ直接呼び出すということはできません。なぜかというと、 Pure 関数を呼び出すためには、少なくともその時点の実装において、関数のためのスタックフレームを設定する必要があるからです。しかし、この課題を扱うために、 ``pure_funcall`` と呼ばれる便利な関数がランタイム API の中にあります。この関数はパラメータとして、 Pure 関数へのポインタ、引数の数、引数そのもの（ ``pure_expr*`` オブジェクト）を取ります。例として、ここに pure_main.c モジュールがあります。このモジュールを上の hello.pure プログラムにリンクさせることができ、 hello.pure は Pure プログラムから ``fact`` 関数を呼び出します::

  #include <stdio.h>
  #include <pure/runtime.h>

  extern void __pure_main__(int argc, char** argv);
  extern pure_expr *fact(pure_expr *x);

  int main()
  {
    int n = 10, m;
    __pure_main__(0, NULL);
    if (pure_is_int(pure_funcall(fact, 1, pure_int(n)), &m))
      printf("fact %d = %d\n", n, m);
    return 0;
  }

And here's how you can compile, link and run this program:

そして、このプログラムをコンパイル・リンク・実行する方法は次の通り::

  $ pure -o hello.o -c -x hello.pure 7
  $ gcc -o pure_main.o -c pure_main.c
  $ g++ -o myhello hello.o pure_main.o -lpure
  $ ./myhello
  Hello, world!
  [1,2,6,24,120,720,5040]
  fact 10 = 3628800

Note that the first two lines are output from the Pure program; the last line
is what gets printed by the ``main`` routine in pure_main.c.

最初の2行は Pure プログラムからの出力で、最終行は pure_main.c の ``main`` ルーチンによる出力です。

Caveats and Notes
=================

警告と注意

This section is a grab bag of casual remarks, useful tips and tricks, and
information on common pitfalls, quirks and limitations of the current
implementation and how to deal with them.

このセクションは casual remarks, useful tips and tricks, そして現在の実装のよくある落とし穴やクセ、制限と、それをうまく扱う方法などの寄せ集めです。

Purity
------

純粋さ

People keep asking me what's so "pure" about Pure. The long and apologetic
answer is that Pure tries to stay as close as possible to the spirit of term
rewriting without sacrificing practicality. It's possible and in fact quite
easy to write purely functional programs in Pure, and you're encouraged to use
it that way when possible. On the other hand, Pure doesn't get in your way if
you want to call external operations with side effects; it does allow you to
call any C function after all.

人からいつも Pure の何が「ピュア」なんだとよく聞かれます。長くて弁解がましい答えは以下のようなものです。 Pure は実用性を犠牲にしないまま項書き替えの精神に近いところに留まろうとつとめています。 Pure でピュアな関数プログラムを書くことは可能であり、実際とても簡単なことで、また Pure は可能な限りあなたがそうすることを奨励します。他方、あなたがもし side effect とともに外部の処理を呼び出そうとするなら、 Pure はそれを邪魔しません。要するにあらゆる C 関数を呼び出すことが許されています。

The short answer is that I simply liked the name, and there wasn't any
programming language named "Pure" yet (quite a feat nowadays), so there's one
now. :)

短い答えとしては、私は単純にこの名前が気に入っていて、しかも "Pure" と名付けられたプログラミング言語がまだなかった（今考えるとすごいこと）ので、この名前になっています :)

Backward Compatibility
----------------------

後方互換性

Pure 0.7 introduced built-in matrix structures, which called for some minor
changes in the syntax of comprehensions and arithmetic
sequences. Specifically, the template expression and generator/filter clauses
of a comprehension are now separated with ``|`` instead of ``;``. Moreover,
arithmetic sequences with arbitrary stepsize are now written ``x:y..z``
instead of ``x,y..z``, and the '``..``' operator now has a higher precedence
than the '``,``' operator. This makes writing matrix slices like
``x!!(i..j,k..l)`` much more convenient.

Pure 0.7 で組み込みマトリクス構造が導入されました。それにより、内包と等差数列の文法に若干のマイナーチェンジが必要となりました。特に、テンプレート式と、内包のジェネレータ／フィルタ節は今や、 ``;`` ではなく ``|`` で区切られます。さらに、任意の差〔stepsize〕をとる等差数列は ``x,y..z`` ではなく ``x:y..z`` と書かれるようになり、 '``..``' 演算子は '``,``' 演算子よりも高い優先度を持つようになっています。これにより、マトリクススライスをもっと便利に ``x!!(i..j,k..l)`` などと書くことができるようになっています。

In Pure 0.13 the naming of the logical and bitwise operations was changed, so
that these are now called ``~``, ``&&``, ``||`` and ``not``/``and``/``or``,
respectively. (Previously, ``~`` was used for bitwise, ``not`` for logical
negation, which was rather inconsistent, albeit compatible with the naming of
the ``not`` operation in Haskell and ML.) Also, to stay in line with this
naming scheme, inequality was renamed to ``~=`` (previously ``!=``).

Pure 0.13 では、論理演算とビット演算の naming が変わり、その結果それぞれ ``~``, ``&&``, ``||`` と ``not``/``and``/``or`` と呼ばれるようになりました（その前は ``~`` がビット演算に使われており、 ``not`` は論理否定に使われていて、一貫性に欠ける状態でしたが、 Haskell や ML の ``not`` 演算とは互換性がありました）。また、この命名規則に合わせるため、不等号〔inequality〕は ``~=`` へ改名されました（その前までは ``!=`` ）。

Pure 0.14 introduced the namespaces feature. Consequently, the scope of
private symbols is now confined to a namespace rather than a source module;
scripts making use of private symbols need to be adapted accordingly. Also
note that syntax like ``foo::int`` may now also denote a qualified symbol
rather than a tagged variable, if ``foo`` has been declared as a
namespace. You can work around such ambiguities by renaming the variable, or
by placing spaces around the '``::``' delimiter (these aren't permitted in a
qualified symbol, so the construct ``foo :: int`` is always interpreted as a
tagged variable, no matter whether ``foo`` is also a valid namespace).

Pure 0.14 では名前空間機能が導入されました。その結果、プライベートシンボルのスコープは名前空間の範囲内に限定され、ソースモジュール内の範囲ではなくなりました。プライベートシンボルを使うスクリプトはそれに適合させる必要があります。また、 ``foo::int`` のような文法は、 ``foo`` が名前空間として宣言されている場合、タグ付き変数ではなく修飾子つきシンボルを示すようになりました。こうした解釈の曖昧さに対処するには、変数を改名するか、あるいは '``::``' デリミタの左右にスペースを置きます（これは修飾子つきシンボルでは許可されないので、 '``foo :: int``' という構造は常にタグ付き変数として解釈されます。このとき ``foo`` が有効な名前空間であるかどうかは問題となりません）。

Pure 0.26 extended the namespaces feature to add support for hierarchical
namespaces. This means that name lookup works in a slightly different fashion
now (see `Hierarchical Namespaces`_ for details), but old code which doesn't
use the new feature should continue to work unchanged.

Pure 0.26 では名前空間機能を拡張し、階層状の名前空間サポートを追加しました。これにより、名前検索の挙動がやや変わりました（詳しくは `Hierarchical Namespaces`_ 参照）。しかし、新しい機能を使っていない過去のコードは変更なしで動作しつづけるはずです。

Pure 0.26 also changed the ``nullary`` keyword to ``nonfix``, which is more
consistent with the other kinds of fixity declarations. Moreover, the parser
was enhanced so that it can cope with a theoretically unbounded number of
precedence levels, and the system of standard operators in the prelude was
modified so that it becomes possible to sneak in new operator symbols with
ease; details can be found in the `Symbol Declarations`_ section.

また Pure 0.26 では ``nullary`` キーワードが ``nonfix`` へ変更されました。これは他の fixity 宣言とより調和するものです。さらに、パーサーが改善された結果、理論的には無限の優先度レベルを扱えるようになりました。また、 prelude 内の標準演算子システムが修正された結果、新たな演算子シンボルを〔標準演算子の隙間へ〕簡単にすべり込ませることができるようになりました。詳しいことは `Symbol Declarations`_ セクションで述べられています。

Pure 0.41 added support for optimization of indirect tail calls, so that any
previous restrictions on the use of tail recursion in indirect function calls
and mutually recursive globals have been removed. Moreover, the logical
operators ``&&`` and ``||`` are now tail-recursive in their second operand and
can also be extended with user-defined equations, just like the other
builtins. Note that this implies that the values returned by ``&&`` and ``||``
aren't normalized to the values 0 and 1 any more (this isn't possible with
tail call semantics). If you need this then you'll have to make sure that
either the operands are already normalized, or you'll have to normalize the
result yourself.

Pure 0.41 では indirect tail calls 最適化のサポートが加わりました。その結果、 tail recursion in indirect function calls と mutually recursive globals の使用に関するあらゆる制限が除去されました。さらに、論理演算子 ``&&`` および ``||`` は今や第2オペランドにおいて末尾再帰であり、また他の組み込み演算子と同様にユーザ定義の等式で拡張することができます。 ``&&`` と ``||`` によって返される値はもはや 0 と 1 に正規化されていないことに注意して下さい（this isn't possible with tail call semantics）。もしこの正規化が必要であれば、オペランドのいずれもがすでに正規化されていることを確かなものとするか、あるいは結果を自分で正規化しなければなりません。

Also, as of Pure 0.41 the batch compiler produces stripped executables by
default. To create unstripped executables you now have to use the -u option,
see `Code Size and Unstripped Executables`_ for details. The -s option to
produce stripped executables is still provided for backward compatibility, but
it won't have any effect unless you use it to override a previous -u option.

また Pure 0.41 以降では、バッチコンパイラはデフォルトで stripped executables を作り出します。 unstripped executables を作るためには -u オプションを使わなければなりません。詳しくは `Code Size and Unstripped Executables`_ を参照して下さい。stripped executables を作る -s オプションも後方互換性のためにまだ提供されますが、このオプションが効果を持つのは、その前に指定された -u オプションを上書きする場合のみです。

Pure 0.43 changed the rules for looking up symbols in user-defined namespaces.
Unqualified symbols are now created in the current (rather than the global)
namespace by default, see `Symbol Lookup and Creation`_ for details. The -w
option can be used to get warnings about unqualified symbols which are
resolved to a different namespace than previously.

Pure 0.43 ではユーザ定義名前空間からシンボルを検索するルールが変わりました。修飾子なしシンボルは今やデフォルトでカレント名前空間（グローバル名前空間ではなく）に作成されます。詳しくは `Symbol Lookup and Creation`_ を参照して下さい。 -w オプションは修飾子なしシンボルについての警告を得るために使います。修飾子なしシンボルは、それまでと異なる名前空間に解決されるようになっています。

Error Recovery
--------------

The parser uses a fairly simplistic panic mode error recovery which tries to
catch syntax errors at the toplevel only. This seems to work reasonably well,
but might catch some errors much too late. Unfortunately, Pure's terseness
makes it rather difficult to design a better scheme. As a remedy, the parser
accepts an empty definition (just ``;`` by itself) at the toplevel only. Thus,
in interactive usage, if the parser seems to eat away your input without doing
anything, entering an extra semicolon or two should break the spell, putting
you back at the toplevel where you can start typing the definition again.

パーサーはかなりシンプルな panic mode error recovery を使います。これはトップレベルに限りシンタックスエラーをキャッチしようとするものです。これはなかなか良く動作するように見えますが、いくつかのエラーについてはかなり後からキャッチすることもあります。不運なことに、 Pure の簡潔さがより良いスキームの設計を難しくしています。改善策として、パーサーはトップレベルに限り空の定義（ただ ``;`` を置くだけ）を許容します。したがって、対話的に使う場合、パーサーがあなたの入力を何もしないまま飲み込んでしまったら、追加のセミコロンを1つか2つ入力すると、その魔法を打ち破り、あなたが定義を打ち込み始めたところであるトップレベルへと再び戻してくれます。

The __show__ Function
---------------------

__show__ 関数

As of Pure 0.6, the interpreter provides a "hook" to override the print
representations of expressions at runtime by means of the ``__show__``
function, which works in a fashion similar to Haskell's ``show``
function. This feature is still a bit experimental, but seems to work
reasonably well for the purposes for which it is intended.

Pure 0.6 から、インタープリタはある「フック」を提供しています。この「フック」は ``__show__`` 関数を使って実行時に式の出力形式を上書きするためのものです。これは Haskell の ``show`` 関数のやり方と似た動作をします。この機能はまだ少し実験的なものですが、この機能が目指す目的についてはかなり良く動作しているようです。

``__show__`` is just an ordinary Pure function expected to return a string
with the desired custom representation of a normal form value given as the
function's single argument. This function is not defined by default, so you
are free to add any rules that you want. The interpreter prints the strings
returned by ``__show__`` just as they are. It will not check whether they
conform to Pure syntax and/or semantics, or modify them in any way.

``__show__`` は単なる普通の Pure 関数で、関数の単一引数として与えられた a normal form value を望みの representation にカスタムした状態の文字列として返すことを目的としています。この関数はデフォルトでは定義されないので、あなたが望むどのようなルールでも自由に追加することができます。インタープリタは ``__show__`` が返す文字列を単にそのまま出力します。 Pure の syntax and/or semantics を満たしているかどうかはチェックされません, or modify them in any way.

Custom print representations are most useful for interactive purposes, if
you're not happy with the default print syntax of some kinds of objects. One
particularly useful application of ``__show__`` is to change the format of
numeric values. Here are some examples:

Custom print representations は、ある種類のオブジェクトが対話モードで出力される際のデフォルト syntax が気に入らないとき、とても役に立つものです。 ``__show__`` の特に役立つ application は、数値の表示フォーマットを変えることです。次にいくつか例を示します::

  > using system;
  > __show__ x::double = sprintf "%0.6f" x;
  > 1/7;
  0.142857
  > __show__ x::int = sprintf "0x%0x" x;
  > 1786;
  0x6fa
  > using math;
  > __show__ (x::double +: y::double) = sprintf "%0.6f+%0.6fi" (x,y);
  > cis (-pi/2);
  0.000000+-1.000000i

The prelude function ``str``, which returns the print representation of any
Pure expression, calls ``__show__`` as well:

prelude で定義される関数 ``str`` は、あらゆる Pure 式の the print representation を返しますが、 ``__show__`` をも呼び出します::

  > str (1/7);
  "0.142857"

Conversely, you can call the ``str`` function from ``__show__``, but in this
case it always returns the default representation of an expression. This
prevents the expression printer from going recursive, and allows you to define
your custom representation in terms of the default one. E.g., the following
rule removes the ``L`` suffixes from bigint values:

反対に、 ``__show__`` から ``str`` 関数を呼ぶこともできます。しかしこの場合、 ``str`` は常に式のデフォルト representation を返します。これにより式プリンタは再帰に陥らず、あなたのカスタム representation を定義できます in terms of the default one. 例えば、次のルールは bigint 値の末尾の ``L`` を除去します::

  > __show__ x::bigint = init (str x);
  > fact n = foldl (*) 1L (1..n);
  > fact 30;
  265252859812191058636308480000000

Of course, your definition of ``__show__`` can also call ``__show__`` itself
recursively to determine the custom representation of an object.

もちろん、あなたの ``__show__`` 定義が ``__show__`` それ自身を再帰的に呼び出して、オブジェクトのカスタム representation を定義することもできます。

One case which needs special consideration are thunks (futures). The printer
will *never* use ``__show__`` for those, to prevent them from being forced
inadvertently. In fact, you *can* use ``__show__`` to define custom
representations for thunks, but only in the context of a rule for other kinds
of objects, such as lists. For instance:

特別な考慮を要するケースの一つが、サンク（future）です。プリンタがサンクに対して ``__show__`` を使うことは *決してありません* 。軽率に評価が強制されないようにするためです。実のところ、 ``__show__`` を使ってサンクのカスタム representation を定義することは *可能* なのですが、多種のオブジェクト（リストなど）のためのルールの文脈に限られます。例えば::

  > nonfix ...;
  > __show__ (x:xs) = str (x:...) if thunkp xs;
  > 1:2:(3..inf);
  1:2:3:...

Another case which needs special consideration are numeric matrices. For
efficiency, the expression printer will always use the default representation
for these, unless you override the representation of the matrix as a
whole. E.g., the following rule for double matrices mimics Octave's default
output format (for the sake of simplicity, this isn't perfect, but you get the
idea):

もう一つ特別な考慮を要するケースは、数値マトリクスです。効率のため、式プリンタは数値マトリクス出力の際、常にデフォルト representation を使用します。ただしマトリクスの representation 全体をあなたが上書きした場合は別です。例えば、次の浮動小数点値マトリクス〔double matrices〕に対するルールは Octave のデフォルト出力フォーマットを真似ています（簡潔にするため、完全に真似てはいませんが、考え方はわかると思います）::

  > __show__ x::matrix =
  >   strcat [printd j (x!(i,j))|i=0..n-1; j=0..m-1] + "\n"
  > with printd 0 = sprintf "\n%10.5f"; printd _ = sprintf "%10.5f" end
  > when n,m = dim x end if dmatrixp x;
  > {1.0,1/2;1/3,4.0};
     1.00000   0.50000
     0.33333   4.00000

Finally, by just purging the definition of the ``__show__`` function you can
easily go back to the standard print syntax:

最後に、 ``__show__`` 関数の定義をただ除去することで、標準の出力 syntax へ簡単に戻すことができます::

  > clear __show__
  > 1/7; 1786; cis (-pi/2);
  0.142857142857143
  1786
  6.12303176911189e-17+:-1.0

Note that if you have a set of definitions for the ``__show__`` function which
should always be loaded at startup, you can put them into the interpreter's
interactive startup files, see `Interactive Usage`_.

あなたが ``__show__`` 関数のための定義セットを持っていて、それが常に起動時にロードされる場合、あなたはそれをインタープリタの対話スタートアップファイル内に置くこともできます。 `Interactive Usage`_ を参照して下さい。

Non-Linear Patterns
-------------------

非線型パターン

As explained in section Patterns_, Pure allows multiple occurrences of the
same variable in a pattern (so-called non-linearities):

Patterns_ セクションでも説明した通り、 Pure は一つのパターン内に同じ変数が複数回現れることを許します（いわゆる非線型性）::

  foo x x = x;

This rule will only be matched if both occurrences of ``x`` are bound to the
same value. More precisely, the two instances of ``x`` will checked for
syntactic equality during pattern matching, using the |same|_ primitive
provided by the prelude. This may need time proportional to the sizes of both
argument terms, and thus become quite costly for big terms. In fact, ``same``
might not even terminate at all if the compared terms are both infinite lazy
data structures, such as in ``foo (1..inf) (1..inf)``. So you have to be
careful to avoid such uses.

このルールは、2つある ``x`` の両方が同じ値へ束縛されている場合だけマッチします。より厳密に言えば、パターンマッチングの間に ``x`` のインスタンス2つの統語的な〔syntactic equality〕がチェックされます。このチェックには prelude が提供する |same|_ プリミティブが使われます。このチェックには、引数の両項のサイズに比例して時間がかかるので、大きな項に対してはとてもコストを要することになります。実際、 ``same`` がまったく終わらない可能性もあります。比較される両項がどちらも無限長の遅延評価データ構造（例えば ``foo (1..inf) (1..inf)`` など）の場合がそうです。なので、このような使用を避けるよう注意しなければなりません。

When using non-linearities in conjunction with "as" patterns, you also have to
make sure that the "as" variable does not occur inside the corresponding
subpattern. Thus a definition like the following is illegal:

"as" パターンを持つ条件内で非線型を使うときは、 "as" 変数が、それに対応する下位パターンの内側に現れないようにも気をつけなければなりません。よって、次のような定義は違反となります::

  > foo xs@(x:xs) = x;
  <stdin>, line 1: error in pattern (recursive variable 'xs')

The explanation is that such a pattern couldn't possibly be matched by a
finite list anyway. Indeed, the only match for ``xs@(x:xs)`` would be an
infinite list of ``x``\ 's, and there's no way that this condition could be
verified in a finite amount of time. Therefore the interpreter reports a
"recursive variable" error in such situations.

これに対する釈明は、このようなパターンは有限長のリストによりマッチされる可能性がいずれにせよないということです。たしかに ``xs@(x:xs)`` にマッチするのは ``x`` の無限長のリストのみであり、この条件が有限の時間内に確認される見込みはありません。そのためインタープリタはこのような状況で "recursive variable" 〔「再帰変数」〕エラーをレポートするのです。

"As" Patterns
-------------

"as" パターン

In the current implementation, "as" patterns cannot be placed on the "spine"
of a function definition. Thus rules like the following, which have the
pattern somewhere in the head of the left-hand side, will all provoke an error
message from the compiler:

現在の実装では、 "as" パターンを関数宣言の「背骨」〔"spine"〕に置くことができません。よって次のようなルール（左辺の先頭のどこかに "as" パターンを持つ）はコンパイラのエラーメッセージを引き起こすでしょう::

  a@foo x y   = a,x,y;
  a@(foo x) y = a,x,y;
  a@(foo x y) = a,x,y;

This is because the spine of a function application is not available when the
function is called at runtime. "As" patterns in pattern bindings (``let``,
``const``, ``case``, ``when``) are not affected by this restriction since the
entire value to be matched is available at runtime. For instance:

なぜこうなるかというと、関数 application の背骨は、実行時に関数が呼び出されたタイミングでは利用できない〔is not available〕からです。パターン束縛内の "as" パターン（ ``let``, ``const``, ``case``, ``when`` ）はこの制限を受けません。なぜなら、マッチされる値全体を、実行時に利用できる〔is available〕からです。例えば::

  > case bar 99 of y@(bar x) = y,x+1; end;
  bar 99,100

Head = Function
---------------

頭＝関数

"As" patterns are also a useful device if you need to manipulate function
applications in a generic way. Note that the "head = function" rule means that
the head symbol ``f`` of an application ``f x1 ... xn`` occurring on (or
inside) the left-hand side of an equation, variable binding, or
pattern-matching lambda expression, is always interpreted as a literal
function symbol (not a variable). This implies that you cannot match the
"function" component of an application against a variable, at least not
directly. An anonymous "as" pattern like ``f@_`` does the trick, however,
since the anonymous variable is always recognized, even if it occurs as the
head symbol of a function application. Here's a little example which
demonstrates how you can convert a function application to a list containing
the function and all arguments:

"as" パターンは関数適用を総称的な方法で扱うのに役立つ仕組みです。「頭＝関数」ルールとは、 ``f x1 ... xn`` という適用におけるシンボル ``f`` が、等式、パターンマッチング、ラムダ式いずれかの左辺（かその内側）に現れるとき、そのシンボルは常にリテラル関数シンボルと解釈される（変数ではなく）ことを意味しています。ということは、ある適用の内の「関数」要素を変数にマッチさせることはできません（少なくとも直接には）。しかし ``f@_`` のような無名 "as" パターン does the trick, なぜなら無名変数は、関数適用の先頭シンボルとして現れたときでさえ、常に認識されるからです。次にいくつか例を示しますが、この例では、関数適用を、関数と全引数を含むリストへとどのように変換するかを示しています::

  > foo x = a [] x with a xs (x@_ y) = a (y:xs) x; a xs x = x:xs end;
  > foo (a b c d);
  [a,b,c,d]

This may seem a little awkward, but as a matter of fact the "head = function"
rule is quite useful since it covers the common cases without forcing the
programmer to declare "constructor" symbols (except nonfix symbols). On the
other hand, generic rules operating on arbitrary function applications are not
all that common, so having to "escape" a variable using the anonymous "as"
pattern trick is a small price to pay for that convenience.

これはいささか不便です。しかし事実として「頭＝関数」ルールはとても便利なものです。なぜなら、とてもありふれた場面において、プログラマーに「コンストラクタ」シンボルの宣言（ノンフィクス宣言を除く）を強制しなくて済むからです。他方、任意の関数適用を操作する総称的ルールを使う場面は、それほどありふれていません。なので、無名 "as" パターントリックを使って変数を「エスケープ」しなければならない手間は、この便利さに比べると大したことではありません。

Sometimes you may also run into the complementary problem, i.e., to match a
function argument against a given function. Consider this code fragment:

あなたはときどき run into the complementary problem かもしれません。すなわち、ある関数の引数を、与えられた関数にマッチさせる場面です。次の部分コードを考えて下さい::

  foo x = x+1;
  foop f = case f of foo = 1; _ = 0 end;

You might expect ``foop`` to return true for ``foo``, and false on all other
values. Better think again, because in reality ``foop`` will always return
true! In fact, the Pure compiler will warn you about the second rule of the
``case`` expression not being used at all:

もしかすると ``foop`` は、 ``foo`` を受け取った場合のみ真を返し、他の全ての値に対して偽を返すと思ったでしょうか。だって、実際 ``foop`` は常に真なわけですから！ 事実、 Pure コンパイラは case 式の第二ルールが決して使われないことについて警告してくるでしょう::

  > foop 99;
  warning: rule never reduced: _ = 0;
  1

This happens because an identifier on the left-hand side of a rule, which is
neither the head symbol of a function application nor a ``nonfix`` symbol, is
always considered to be a variable (cf. `Parameters in Equations`_), even if
that symbol is defined as a global function elsewhere. So ``foo`` isn't a
literal name in the above ``case`` expression, it's a variable! (As a matter
of fact, this is rather useful, since otherwise a rule like ``f g = g+1``
would suddenly change meaning if you happen to add a definition like ``g x =
x-1`` somewhere else in your program, which certainly isn't desirable.)

これはルール左辺の識別子のせいで起こることです。この識別子は関数適用の「頭」シンボルでもなければ、 ``nonfix`` シンボルでもなく、常に変数であるものと解釈されます（cf. `Parameters in Equations`_ ）。たとえそのシンボルがどこかでグローバル関数として宣言されていても、です。そのため ``foo`` は、上の ``case`` 式のリテラル名ではなく、変数なのです！（実際問題、これはむしろ便利です。もしそうでないとすると、 ``f g = g+1`` のようなルールは、プログラムのどこかで ``g x = x-1`` という定義が追加されたら、意味が突然変わってしまうことになります。これは望まれないことでしょう）

A possible workaround is to "escape" the function symbol using an empty
namespace qualifier:

可能な次善策としては、空の名前空間修飾子を使って関数シンボルを「エスケープ」することです::

  foop f = case f of ::foo = 1; _ = 0 end;

This trick works in ``case`` expressions and function definitions, but fails
in circumstances in which qualified variable symbols are permitted (i.e., in
variable and constant definitions). A better solution is to employ the
syntactic equality operator ``===`` defined in the prelude to match the target
value against the function symbol. This allows you to define the ``foop``
predicate as follows:

この trick は ``case`` 式内と関数定義内で機能しますが、修飾子つき変数シンボルが許される状況（すなわち、変数と定数の定義内）では失敗します。よりよい解決法は、統語的な等値演算子〔syntactic equality operator〕 ``===`` を使うことです。これは prelude 内で定義されており、■対象となる値を関数シンボルとマッチさせます■。これを使って ``foop`` predicate を次のように宣言できます::

  > foop f = f===foo;
  > foop foo, foop 99;
  1,0

Another way to deal with the situation would be to just declare ``foo`` as a
nonfix symbol. However, this makes the ``foo`` symbol "precious", i.e., after
such a declaration it cannot be used as a local variable anymore. It's usually
a good idea to avoid that kind of thing, at least for generic symbols, so the
above solution is preferred in this case.

この状況をうまく扱うもう一つの方法は、 ``foo`` を単にノンフィクスシンボルとして宣言することです。しかし、こうすると ``foo`` シンボルは「かけがえのない」ものとなります。すなわち、宣言の後、もはやそのシンボルをローカル変数として使うことはできなくなります。たいていの場合（少なくとも総称的シンボルについては）、このような状態は避けたほうがよいので、今回の場合に好ましいのは上の解決策です。

With and when
-------------

with と when

A common source of confusion is that Pure provides two different constructs to
bind local function and variable symbols, respectively. This distinction is
necessary because Pure does not segregate defined functions and constructors,
and thus there is no magic to figure out whether an equation like ``foo x =
y`` by itself is meant as a definition of a function ``foo`` with formal
parameter ``x`` and return value ``y``, or a pattern binding defining the
local variable ``x`` by matching the pattern ``foo x`` against the value of
``y``. The ``with`` construct does the former, ``when`` the latter. (As a
mnemonic, you may consider that ``when`` conveys a sense of time, as the
individual variable definitions in a ``when`` clause are executed in order,
while the function definitions in a ``with`` clause are all done
simultaneously.)

ローカル関数シンボルとローカル変数シンボルを束縛する2つの異なる構造を、 Pure がそれぞれ別個に提供していることは、しばしば混乱の原因となります。この区別は必要なのですが、その理由は、 Pure が定義済み関数と定義済みコンストラクタを分離していないことにあります。このため ``foo x = y`` という等式が、関数 ``foo`` （ ``x`` という形式的パラメータと返値 ``y`` を持つ）の宣言なのか、それともパターン束縛（パターン ``foo x`` を ``y`` の値にマッチさせることでローカル変数 ``x`` を定義する）なのか結論を出す魔法は存在しないのです。 ``with`` 構造は前者を行うもので、 ``when`` は後者を行うものです（記憶法として、 ``when`` 節が時間的な意味を伝えると考えてもよいかもしれません。 ``when`` 節内の個々の変数定義は順番に実行されますが、それに対して ``with`` 節内の関数定義はすべて同時に実行されます）。

Another speciality is that ``with`` and ``when`` clauses are tacked on to the
end of the expression they belong to. This mimics mathematical language and
makes it easy to read and understand a definition in a "top-down" fashion.
This style differs considerably from other block-structured programming
languages, however, which often place local definitions in front of the code
they apply to. To grasp the operational meaning of such nested definitions, it
can be helpful to read the nested scopes "in reverse" (from bottom to
top). Some people also prefer to write their programs that way. In difference
to Haskell and ML which have ``let`` expressions to support that kind of
notation, Pure doesn't provide any special syntax for this. But note that you
can always write ``when`` clauses in the following style which places the
"body" at the bottom of the clause:

もう一つの speciality は、 ``with`` 節と ``when`` 節が、それぞれの属する式の末尾に tracked on されることです。これは数学言語を真似たもので、「トップダウン」方式で定義を読解することを容易にします。このスタイルは他のブロック構造型プログラミング言語とかなり異なっています。他の言語ではしばしば、ローカル定義を、それが適用されるコードの前に置きます。こうしたネストされた定義の処理の流れを把握するには、ネストされたスコープを「逆に」（下から上へ）読むことが役立ちます。少なからぬ人々はこうした方法でプログラムを書くことを好みます。 Haskell と ML はそのような記法をサポートするため ``let`` 式を持っていますが、 Pure にはこうした特別な文法が一切ありません。ただし、あなたはいつでも ``when`` 節を次のようなスタイルで書き、 "body" を節の末尾に置くことができることを忘れないで下さい::

  result when
    y = foo (x+1);
    z = bar y;
    result = baz z;
  end;

This doesn't incur any overhead, since the compiler will always eliminate the
trivial "tail binding" for the result value. E.g., the above will compile to
exactly the same code as:

これはいかなる負荷を背負い込むこともありません。なぜならコンパイラは result の値について trivial な "tail binding" を常に除去するからです。例えば、上のコードは次のコードとまったく同じものとしてコンパイルされます::

  baz z when
    y = foo (x+1);
    z = bar y;
  end;

Numeric Calculations
--------------------

数値計算

If possible, you should decorate numeric variables on the left-hand sides of
function definitions with the appropriate type tags, like ``int`` or
``double``. This often helps the compiler to generate better code and makes
your programs run faster. The ``|`` syntax makes it easy to add the necessary
specializations of existing rules to your program. E.g., taking the
polymorphic implementation of the factorial as an example, you only have to
add a left-hand side with the appropriate type tag to make that definition go
as fast as possible for the special case of machine integers:

可能なら、あなたは関数定義の左辺にある数値変数を型タグ（ ``int`` や ``double`` など）で修飾すべきです。こうすることはコンパイラがより良いコードを生成するのを助け、あなたのプログラムを速くします。 ``|`` syntax は、あなたのプログラムに、■既存ルールの必要な特殊化■を追加することを容易にします。例えば、階乗関数の polymorphic な実装を例とすると、適切な型タグを左辺に追加するだけで、その定義を可能な限り素早く machine integers に特化したものへ変えることができます::

  fact n::int    |
  fact n         = n*fact(n-1) if n>0;
                 = 1 otherwise;

(This obviously becomes unwieldy if you have to deal with several numeric
arguments of different types, however, so in this case it is usually better to
just use a polymorphic rule.)

（ただし、それぞれ型が異なる数値引数をいくつか扱わなければならない場合、こうすると明らかに不格好になります。そのような場合はたいてい、ただ polymorphic なルールをそのまま使う方が良いでしょう）

Also note that int (the machine integers), bigint (the GMP "big" integers) and
double (floating point numbers) are all different kinds of objects. While they
can be used in mixed operations (such as multiplying an int with a bigint
which produces a bigint, or a bigint with a double which produces a double),
the ``int`` tag will only ever match a machine int, *not* a bigint or a
double. Likewise, ``bigint`` only matches bigints (never int or double
values), and ``double`` only doubles. Thus, if you want to define a function
operating on different kinds of numbers, you'll also have to provide equations
for all the types that you need (or a polymorphic rule which catches them
all). This also applies to equations matching against constant values of these
types. In particular, a small integer constant like ``0`` only matches machine
integers, not bigints; for the latter you'll have to use the "big L" notation
``0L``. Similarly, the constant ``0.0`` only matches doubles, but not ints or
bigints.

また、 int （the machine integers）、 bigint （ GMP の "big" integers ）および double （浮動小数点数）はそれぞれ型の異なるオブジェクトです。それぞれを混在させて処理を行うこともできますが（例えば int と bigint を掛けた積は bigint となり、 bigint と double の積は double となる、など）、 ``int`` タグがマッチするのは machine int だけであり、 bigint や double にはマッチ *しません* 。同じように、 ``bigint`` は bigint だけにマッチし（ int 値や double 値にはマッチしない）、 ``double`` は double だけです。したがって、異なる種類の数値を処理する関数を定義したい場合、必要なすべての型のための等式を提供しなければなりません（もしくは polymorphic なルールなら全てのケースをキャッチします）。このことは、そうした型を持つ定数にマッチする等式についてもあてはまります。特に、 ``0`` のような整数の小さな整数は machine integers にのみマッチし、 bigint にはマッチしません。後者の場合、 "big L" 記法を使って ``0L`` とする必要があります。同じように、定数 ``0.0`` は double にだけマッチし、 int や bigint にはマッチしません。

Constant Definitions
--------------------

定数の定義

Constants differ from variables in that they cannot be redefined (that's their
main purpose after all) and that their values, once defined, are determined at
compile time rather than run time. For instance:

定数が変数と異なるのは、再定義することができない点（結局それが主な目的です）と、一度定義されたら、実行時ではなくコンパイル時に値が決定されるという点です。例えば::

  > const c = 2;
  > foo x = c*x;
  > show foo
  foo x = 2*x;
  > foo 99;
  198

While a variable can be rebound to a new value at any time, you will get an
error message if you try to do this with a constant:

変数を新しい値に再束縛することはいつでもできますが、定数を再束縛しようとするとエラーメッセージを受け取るでしょう::

  > const c = 3;
  <stdin>, line 5: symbol 'c' is already defined as a constant

Note that in interactive mode you can work around this by purging the old
definition with the ``clear`` command. However, this won't affect any earlier
uses of the symbol:

対話モードでは、古い定義を ``clear`` コマンドで取り除くと、これを回避できます。しかし、それよりも前のシンボル使用に対しては影響しません::

  > clear c
  > const c = 3;
  > bar x = c*x;
  > show foo bar
  bar x = 3*x;
  foo x = 2*x;

(You'll also have to purge any existing definition of a variable if you want
to redefine it as a constant, or vice versa, since Pure won't let you redefine
an existing constant or variable as a different kind of symbol. The same also
holds if a symbol is currently defined as a function or a macro.)

（すでに定義済みの変数を定数として〔同じシンボル名で〕再定義したい場合、まず既存の定義を除去する必要があります。定数を変数にしたい場合も同様です。なぜかというと、 Pure では、すでに存在する定数や変数を別種のシンボルとして再定義することが許されないからです。あるシンボルが関数やマクロとして定義されている場合でも、このことは変わりません）

As the value of a constant is known at compile time, the compiler can apply
various optimizations to uses of such values. In particular, the Pure compiler
inlines constant scalars (numbers, strings and pointers) by literally
substituting their values into the output code, and it also precomputes simple
constant expressions involving only (machine) integer and double
values. Example:

定数の値はコンパイルの段階でわかるので、コンパイラはその値が使われる部分に様々な最適化を施すことができます。特に、 Pure コンパイラは定数スカラー（数値、文字列、ポインタ）をインライン化します。具体的には、定数スカラーの値を出力コードへと直訳的に〔literally〕 substitute し、また (machine) integer 値と double 値だけを含むシンプルな定数式を事前計算します。例です::

  > extern double atan(double);
  > const pi = 4*atan 1.0;
  > show pi
  const pi = 3.14159265358979;
  > foo x = 2*pi*x;
  > show foo
  foo x = 6.28318530717959*x;

In addition, the LLVM backend eliminates dead code automatically, so you can
employ a constant to configure your code for different environments, without
any runtime penalties:

それに加えて、 LLVM バックエンドはデッドコード〔dead code〕を自動的に排除するので、あなたは自分のコードを異なる環境に向けて設定することができ、そうした場合でも実行時のペナルティはありません::

  const win = index sysinfo "mingw32" >= 0;
  check boy = bad boy if win;
            = good boy otherwise;

In this case the code for one of the branches of ``check`` will be completely
eliminated, depending on the outcome of the configuration check.

この場合、 ``check`` の枝のどちらか一本のコード〔＝最終的な出力コード〕は完全に除去されるでしょう。どちらが除去されるかは設定チェックの結果次第です。

For efficiency, constant aggregates (lists, tuples, matrices and other kinds
of non-scalar terms) receive special treatment. Here, the constant is computed
once and stored in a read-only variable which then gets looked up at runtime,
just like an ordinary global variable. However, there is still a big
difference. If a script is batch-compiled (cf. `Batch Compilation`_), the
constant value is computed at compile time only; when running the compiled
executable, the constant value is simply reconstructed, which is often much
more efficient than recomputing its value. For instance, you might use this to
precompute a large table whose computation may be costly or involve functions
with side effects:

効率のため、定数集合（リスト、タプル、マトリクス、およびその他の非スカラー項）は特別扱いを受けます。すなわち、定数は一度だけ計算されて読み込み専用の変数内に保存され、実行時には通常のグローバル変数と同じようにその値が検索されます。しかし、まだ一つ大きな違いがあります。もしスクリプトがバッチコンパイルされた場合（ cf. `Batch Compilation`_ ）、定数値はコンパイル時にのみ計算されます。コンパイル済み実行ファイルが実行されたとき、定数値は単純に再構築されるので、値を再計算するよりも通常はとても効率が良くなります。例えば、■これを使って大きなテーブルを事前計算したいと思うかもしれません。この計算はコストがかかるか、副作用を持つ関数を含んでいます■::

  const table = [foo x | x = 1..1000000];
  process table;

Last but not least, constants can also be used in patterns, but only if you
also declare them as ``nonfix``. This is useful, e.g., if you'd like to use
constants such as ``true`` and ``false`` on the left-hand side of a
definition, just like other ``nonfix`` symbols:

最後になりましたが、定数をパターン内で使うこともできます。ただし定数を ``nonfix`` として宣言した場合に限られます。これが役に立つのは、例えば、あなたが ``true`` や ``false`` などの定数を、他の ``nonfix`` シンボルのように、定義の左辺で使いたい場合です::

  > show false true
  const false = 0;
  const true = 1;
  > nonfix false true;
  > check false = "no"; check true = "yes";
  > show check
  check 0 = "no";
  check 1 = "yes";
  > check (5>0);
  "yes"

(Note that without the ``nonfix`` declaration, the above definition of
``check`` wouldn't work as intended, because the ``true`` and ``false``
symbols on the left-hand side of the two equations would be interpreted as
local variables.)

（ ``nonfix`` 宣言を行わなかった場合、上の例における ``check`` の定義は望む通りに動作してくれません。なぜかというと、二つの等式の左辺にある ``true`` と ``false`` のシンボルはローカル変数と解釈されるからです）

External C Functions
--------------------

The interpreter always takes your ``extern`` declarations of C routines at
face value. It will not go and read any C header files to determine whether
you actually declared the function correctly! So you have to be careful to
give the proper declarations, otherwise your program will probably segfault
calling the function.

You also have to be careful when passing generic pointer values to external C
routines, since currently there is no type checking for these; any pointer
type other than ``char*``, ``expr*`` and the matrix pointer types is
effectively treated as ``void*``. This considerably simplifies lowlevel
programming and interfacing to C libraries, but also makes it very easy to
have your program segfault all over the place. Therefore it is highly
recommended that you wrap your lowlevel code in Pure routines and data
structures which do all the checks necessary to ensure that only the right
kind of data is passed to C routines.

Another limitation of the C interface is that it does not offer any special
support for C structs and C function parameters. However, an optional addon
module is available which interfaces to the libffi_ library to provide that
kind of functionality, please see the description of the pure-ffi_ module on
the Pure website for details.

.. _libffi: http://sourceware.org/libffi/
.. _pure-ffi: http://code.google.com/p/pure-lang/wiki/Addons#pure-ffi

Last but not least, to make it easier to create Pure interfaces to large C
libraries, there's a separate pure-gen_ program available at the Pure
website. This program takes a C header (.h) file and creates a corresponding
Pure module with definitions and ``extern`` declarations for the constants and
functions declared in the header. Please refer to the pure-gen(1) manual page
for details.

.. _pure-gen: http://code.google.com/p/pure-lang/wiki/Addons#pure-gen

Special Forms
-------------

Special forms are recognized at compile time only. Thus the ``catch``
function, as well as ``quote`` and the operators ``&&``, ``||``, ``$$`` and
``&``, are only treated as special forms in direct (saturated) calls. They can
still be used if you pass them around as function values or in partial
applications, but in this case they lose all their special call-by-name
argument processing.

The Quote
---------

Like in Lisp, the ``quote`` special form can be used to construct literal
expressions which can then be manipulated before actually evaluating them
using the built-in ``eval`` function. However, there are some notable
differences to the Lisp version of ``quote``:

* Local variables (i.e., variables bound by the left-hand side of an equation,
  a lambda expression or a ``case`` or ``when`` construct) can never be
  quoted, so the corresponding value gets substituted even into quoted
  expressions. Thus, e.g., ``'(2*42+2^n) when n = 12 end`` evaluates to
  ``2*42+2^12`` rather than ``2*42+2^n``.

* Only simple expressions can be quoted in Pure. Special constructs embedded
  in a quoted expression, such as conditionals and local bindings, are
  evaluated as usual. For instance, ``'(2*42+(2^n when n = 2*6 end))``
  evaluates to ``2*42+4096.0`` rather than quoting the embedded ``when``
  expression.

While it's possible to define a Lisp-like ``quasiquote`` in Pure (see the
`Recursive Macros`_ section for a simplified version, a full implementation
can be found in the Pure library sources), it's usually not needed. As
discussed above, substitution of local variables is performed even in quoted
expressions, so that it is quite easy to fill in variable parts in a quoted
"template" expression. For instance::

  > (\x -> '(2*x+1)) 99;
  2*99+1
  > foo x = '(2*x+1);
  > foo 99; foo $ '(7/y);
  2*99+1
  2*(7/y)+1

In fact, it is possible to perform arbitrary computations right in the middle
of a quoted expression, using one of the special ``if``-``then``-``else``,
``case``, ``when`` and ``with`` expressions, since these are never quoted
either. Example::

  > '(x+1 when x = '(2*3) end);
  2*3+1

Another useful feature of Lisp's ``quasiquote`` is the capability to splice
arguments into a function application. It is possible to achieve pretty much
the same in Pure with the following variation of the ``$`` operator which
"curries" its second (tuple) operand::

  infixr 0 $@ ;
  f $@ ()     = f;
  f $@ (x,xs) = f x $@ xs;
  f $@ x      = f x;

Now you can write, e.g.::

  > '(foo 1 2) $@ '(2/3,3/4);
  foo 1 2 (2/3) (3/4)

One shortcoming of Pure's ``quote`` is that there is no way to quote special
constructs such as lambdas. Macro expansion *is* inhibited in quoted
expressions, however, so it is possible to work around this limitation by
defining a custom special form to be used as a symbolic representation for,
say, a lambda expression, which reduces to a real lambda when evaluated. To
these ends, the ``eval`` function can be invoked with a string argument as
follows::

  def lambda x y = eval $ "\\ "+str ('x)+" -> "+str ('y);

Example::

  > let l = 'lambda x (x+1); l;
  lambda x (x+1)
  > let f = eval l; f; f 9;
  #<closure 0x7fdc3ca45be8>
  10

Other special constructs, such as ``case``, ``when`` and ``with`` can be
handled in a similar fashion.

Laziness
--------

Pure does lazy evaluation in the same way as `Alice ML`_, providing an
explicit operation (``&``) to defer evaluation and create a "future" which is
called by need. However, note that like any language with a basically eager
evaluation strategy, Pure cannot really support lazy evaluation in a fully
automatic way. That is, coding an operation so that it works with infinite
data structures usually requires additional thought, and sometimes special
code will be needed to recognize futures in the input and handle them
accordingly. This can be hard, but of course in the case of the prelude
operations this work has already been done for you, so as long as you stick to
these, you'll never have to think about these issues. (It should be noted here
that lazy evaluation has its pitfalls even in fully lazy FPLs, such as hidden
memory leaks and other kinds of subtle inefficiencies or non-termination
issues resulting from definitions being too lazy or not lazy enough. You can
read about that in any good textbook on Haskell.)

The prelude goes to great lengths to implement all standard list operations in
a way that properly deals with streams (a.k.a. lazy lists). What this all
boils down to is that all list operations which can reasonably be expected to
operate in a lazy way on streams, will do so. (Exceptions are inherently eager
operations such as ``#``, ``reverse`` and ``foldl``.) Only those portions of
an input stream will be traversed which are strictly required to produce the
result. For most purposes, this works just like in fully lazy FPLs such as
Haskell. However, there are some notable differences:

* Since Pure uses dynamic typing, some of the list functions may have to peek
  ahead one element in input streams to check their arguments for validity,
  meaning that these functions will be slightly more eager than their Haskell
  counterparts.

* Pure's list functions never produce truly cyclic list structures such as the
  ones you get, e.g., with Haskell's ``cycle`` operation. (This is actually a
  good thing, because the current implementation of the interpreter cannot
  garbage-collect cyclic expression data.) Cyclic streams such as ``cycle
  [1]`` or ``fix (1:)`` will of course work as expected, but, depending
  on the algorithm, memory usage may increase linearly as they are traversed.

* Pattern matching is always refutable (and therefore eager) in Pure. If you
  need something like Haskell's irrefutable matches, you'll have to code them
  explicitly using futures. See the definition of the ``unzip`` function in
  the prelude for an example showing how to do this.

Reflection
----------

Pure versions since 0.12 offer some basic reflection capabilities via the
``evalcmd`` primitive. This function provides access to interactive commands
like ``clear``, ``save`` and ``show``, which enable you to inspect and modify
the running program. The only "canonical" way to represent an entire Pure
program in Pure itself is the program text, hence ``evalcmd`` only provides a
textual interface at this time. But of course custom higher-level
representations can be built on top of that, similar to those discussed in
section `The Quote`_.

Here's an example showing what can be done using the ``show`` command and a
little bit of trivial text processing. The following ``sym_info`` function
retrieves information about a given collection of global symbols in a way
which can be processed in a Pure program. The ``cat`` argument can be any
combination of the letters "c", "v", "f" and "m" denoting the categories of
constants, variables, functions and macros, respectively. (You can also just
leave this empty if you don't care about the type of symbol.) The ``pat``
argument is a shell-like glob pattern for the name of symbols which should be
listed (just "*" matches all symbols). The result is a list of tuples ``(name,
value, cat, descr)`` with the name of the symbol and its value, as well as the
category and description of the symbol, as provided by ``show -s``.

::

  using system;
  sym_info cat::string pat::string
  = [name,eval ("("+name+")"),descr | name,descr = info]
  when
    // Get the info about matching symbols from the 'show' command.
    info = evalcmd $ sprintf "show -sg%s %s" (cat,pat);
    // Split into lines.
    info = if null info then [""] else split "\n" $ init info;
    // Get rid of the last line with the summary information.
    info = init info;
    // Retrieve the information that we need.
    info = [x | x@(s,_) = map fields info;
    // Get rid of extra lines containing extern and fixity declarations.
            s ~= "extern" && s ~= "nonfix" && s ~= "outfix" &&
            s ~= "prefix" && s ~= "postfix" && ~fnmatch "infix*" s 0];
  end with
    // Regex call to split the summary information about one symbol, as
    // returned by 'show -s', into the name and description parts.
    fields s::string = tuple $
            [info!2 | info = tail $ regs $ reg_info $
             regex "([^ ]+)[ ]+([a-z]*)[ ]*(.*)" REG_EXTENDED s 0];
  end;

E.g., this call retrieves information about all defined macros::

  > sym_info "m" "*";
  [("$",($),"mac","2 args, 1 rules"),(".",(.),"mac","3 args, 1 rules"),
  ("void",void,"mac","1 args, 6 rules")]

Hygienic Macros
---------------

衛生的なマクロ

As mentioned in the `Macro Hygiene`_ section, Pure macros are lexically scoped
and thus "hygienic". Macro hygiene is a somewhat esoteric topic for most
programmers, so let us take a brief look at what it's all about. The problem
avoided by hygienic macros is that of *name capture*. There are actually two
kinds of name capture which may occur in unhygienic macro systems:

`Macro Hygiene`_ セクションで述べた通り、 Pure のマクロはレキシカルスコープであり、したがって「衛生的」〔"hygienic"〕です。ほとんどのプログラマーにとって Macro hygiene はいくらか難解なトピックなので、どういうことなのか詳細に見ていきましょう。衛生的なマクロによって避けられるのは *name capture* の問題です。実際には2種類の name capture があり、どちらも衛生的でないマクロシステムで起こりうるものです:

* A free symbol in the macro *body* inadvertently becomes bound to the value
  of a local symbol in the context in which the macro is called.

* マクロ *本体* 内の自由シンボルが、マクロが呼び出されたコンテキスト内にあるローカルシンボルの値と、意図せず束縛されてしまう。

* A free symbol in the macro *call* inadvertently becomes bound to the value
  of a local symbol in the macro body.

* マクロ *呼び出し* 側の自由シンボルが、マクロ本体内にあるローカルシンボルの値と、意図せず束縛されてしまう。

Pure's hygienic macros avoid both pitfalls. Here is an example for the first
form of name capture:

Pure の衛生的なマクロは両方の落とし穴を回避します。ここで、最初の方の name capture の例を示します::

  > def G x = x+y;
  > G 10 when y = 99 end;
  10+y

Note that the expansion of the ``G`` macro correctly uses the global instance
of ``y``, even though ``y`` is locally defined in the context of the macro
call. (Sometimes this form of name capture is actually used deliberately in
order to make the macro use the binding of the symbol which is active at the
point of the macro call. This never works in Pure, hence in such cases you
will have to explicitly pass such symbols to the macro.)

``G`` マクロが展開されたとき、マクロの呼び出し側で ``y`` がローカル宣言されていてもなお、グローバルインスタンスの ``y`` が正しく使われていることに注意を向けて下さい（この形のname captureはときどき故意に使われています。マクロが呼び出された位置で有効なシンボル束縛を使うようにするためです。 Pure は決してこのような動作をしません。したがって、そのような場合にはマクロに対してそうしたシンボルを確実に渡す必要があります）。

In contrast, the second form of name capture is usually not intended, and is
therefore more dangerous. Consider the following example:

対照的に、二つ目のname captureはたいてい意図されることはなく、したがってもっと危険です。次の例を考えてみてください::

  > def F x = x+y when y = x+1 end;
  > F y;
  y+(y+1)

Pure again gives the correct result here. You'd have to be worried if you got
``(y+1)+(y+1)`` instead, which would result from the literal expansion ``y+y
when y = y+1 end``, where the (free) variable ``y`` passed to ``F`` gets
captured by the local binding of ``y``. In fact, that's exactly what you get
with C macros:

ここでも Pure は正しい結果を与えています。この代わりに ``(y+1)+(y+1)`` という結果を得たら、あなたは心配しなければならないでしょう。その場合 ``y+y when y = y+1 end`` という式の結果ということになり、そこでは ``F`` 関数に渡された（自由）変数 ``y`` がローカル束縛の ``y`` により捕らえられているわけです。実際、それは C マクロで起こることです::

  #define F(x) { int y = x+1; return x+y; }

Here ``F(y)`` expands to ``{ int y = y+1; return y+y; }`` which is usually
*not* what you want.

ここでは ``F(y)`` が ``{ int y = y+1; return y+y+}`` へと展開され、それは通常あなたの望むことでは *ない* でしょう。

There is also one Pure-related caveat here. The expression printer currently
doesn't check for different bindings of the same variable identifier when it
prints a (compile time) expression. E.g.:

ここで Pure に関する注意点がもう一つあります。式プリンターはいまのところ、コンパイル時の式を出力する際、同じ変数識別子の異なる束縛についてのチェックを行いません。例えば::

  > foo y = F y;
  > show foo
  foo y = y+y when y = y+1 end;

This *looks* as if ``y`` got captured, but in fact it's not, it's just the
``show`` command which displays the definition in an incorrect way. You can
add the ``-e`` option to ``show`` which prints the deBruijn indices of locally
bound symbols, then you see that the actual bindings are all right anyway
(note that the number before the colon is the actual deBruijn index, the
sequence of bits behind it is the subterm path):

これは ``y`` が捕らえられているかのように *見える* のですが、実際は違います。単に ``show`` コマンドが正しい方法で定義を表示しているだけなのです。 ``show`` コマンドに ``-e`` オプションを追加し、ローカル束縛のシンボルの deBruijn インデックスを表示させることができますが、そうすると、すべての束縛が正しく表示されるのを確認できます（コロンの前の数字が実際の deBruijn インデックスであることに注意して下さい。背後にある一連のビットシーケンスはsubterm pathです）::

  > show -e foo
  foo y/*0:1*/ = y/*1:1*/+y/*0:*/ when y/*0:*/ = y/*0:1*/+1 end;

Alas, this means that if you use ``dump`` to write such a definition to a text
file and read it back with ``run`` later, then you'll get the wrong
definition. Currently you will have to correct this manually.

ああ、もしあなたが ``dump`` を使ってこうした定義をファイルに書き込み、後から読み込んで ``run`` しようとしたら、誤った定義を得てしまうことでしょう。今のところそれは手作業で治すしかありません。

Stack Size and Tail Recursion
-----------------------------

Pure programs may need a considerable amount of stack space to handle
recursive function and macro calls, and the interpreter itself also takes its
toll. So you should configure your system accordingly (8 MB of stack space is
recommended for 32 bit systems, systems with 64 bit pointers probably need
more). If the PURE_STACK environment variable is defined, the interpreter
performs advisory stack checks on function entry and raises a Pure exception
if the current stack size exceeds the given limit. The value of PURE_STACK
should be the maximum stack size in kilobytes. Please note that this is only
an advisory limit which does not change the program's physical stack size.
Your operating system should supply you with a command such as ulimit(1) to
set the real process stack size. (The ``PURE_STACK`` limit should be a little
less than that, to account for temporary stack usage by the interpreter
itself.)

Like Scheme, Pure does proper tail calls (if LLVM provides that feature on the
platform at hand), so tail-recursive definitions should work fine in limited
stack space. For instance, the following little program will loop forever if
your platform supports the required optimizations::

  loop = loop;
  loop;

This also works if your definition involves function parameters, guards and
multiple equations, of course. Moreover, conditional expressions
(``if``-``then``-``else``) are tail-recursive in both branches, and the
logical operators ``&&`` and ``||``, as well as the sequence operator ``$$``,
are tail-recursive in their second operand.

Also note that tail call optimization is *always* disabled if the debugger is
enabled (-g). This makes it much easier to debug programs, but means that you
may run into stack overflows when debugging a program that does deep tail
recursion.

Handling of Asynchronous Signals
--------------------------------

As described in section `Exception Handling`_, signals delivered to the
process can be caught and handled with Pure's exception handling facilities.
This has its limitations, however. Since Pure code cannot be executed directly
from a C signal handler, checks for pending signals are only done on function
entry. This means that in certain situations (such as the execution of an
external C routine), delivery of a signal may be delayed by an arbitrary
amount of time. Moreover, if more than one signal arrives between two
successive signal checks, only the last one will be reported in the current
implementation.

When delivering a signal which has been remapped to a Pure exception, the
corresponding exception handler (if any) will be invoked as usual. Further
signals are blocked while the exception handler is being executed.

A fairly typical case is that you have to handle signals in a tail-recursive
function. This can be done with code like the following::

  using system;

  // Remap some common POSIX signals.
  do (trap SIG_TRAP) [SIGHUP, SIGINT, SIGTERM];

  loop = catch handler process $$ loop
  with handler (signal k) = printf "Hey, I got signal %d.\n" k end;
  process = sleep 1; // do something

Running the above ``loop`` function enters an endless loop reporting all
signals delivered to the process. Note that to make this work, the
tail-recursive invocation of ``loop`` must immediately follow the
signal-handling code, so that signals don't escape the exception handler.

Of course, in a real application you'd probably want the ``loop`` function to
carry around some data to be processed by the ``process`` routine, which then
returns an updated value for the next iteration. This can be implemented as
follows::

  loop x = loop (catch handler (process x))
  with handler (signal k) = printf "Hey, I got signal %d.\n" k $$ 0 end;
  process x = printf "counting: %d\n" x $$ sleep 1 $$ x+1;

Copying
=======

複製について

Pure comes with a fairly liberal license which lets you distribute your own
Pure programs and extensions under a license of your choice and permits
linking of commercial applications against the Pure runtime and the Pure
standard library without requiring special permission. Moreover, the Pure
interpreter (the ``pure`` main program), the Pure runtime library
(``libpure``) and the Pure standard library (the Pure scripts in the ``lib``
folder distributed with the software) are distributed as free software, and
you are welcome to modify and redistribute them under the appropriate license
terms, as detailed below.

(The above explanations are not legal advice. Please read the full text of the
licenses and consult qualified professional counsel for an interpretation of
the license terms as they apply to you.)

The *Pure interpreter* is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

The *Pure runtime library* and the *Pure standard library* are also free
software: you can redistribute them and/or modify them under the terms of the
GNU *Lesser* General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

Pure is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

Please see the |GPL|_ and the |LGPL|_ for the precise license terms. You can
also find the license conditions in the COPYING and COPYING.LESSER files
accompanying the software. Also, please see the source code for the copyright
and license notes pertaining to individual source files which are part of this
software.

Pure uses LLVM_ as its compiler backend. LLVM is under Copyright (c) 2003-2009
by the University of Illinois at Urbana-Champaign, and is licensed under a
3-clause BSD-style license, please read COPYING.LLVM included in the
distribution for the exact licensing terms. You can also find the LLVM license
at the LLVM_ website.

Author
======

作者

Albert Graf <Dr.Graef@t-online.de>, Dept. of Computer Music, Johannes
Gutenberg University of Mainz, Germany.

The author gratefully acknowledges the contributions by Scott E. Dillard,
Rooslan S. Khayrov, Eddie Rucker, Libor Spacek, Jiri Spitz and Sergei
Winitzki, as well as Toni Graffy, Michel Salim and Ryan Schmidt who maintain
the SUSE Linux, Fedora Core and OSX packages, respectively. Thanks are also
due to Vili Aapro, Alvaro Castro Castilla, John Cowan, Chris Double, Tim
Haynes, Roman Neuhauser, Wm Leler, John Lunney and Max Wolf.

See Also
========

.. _Aardappel:

Aardappel
    Wouter van Oortmerssen's functional programming language based on term
    rewriting, http://wouter.fov120.com/aardappel.

.. _Alice ML:

Alice ML
    A version of ML (see below) from which Pure borrows its model of lazy
    evaluation, http://www.ps.uni-sb.de/alice.

.. _Bertrand:

Bertrand
    Wm Leler's constraint programming language based on term rewriting,
    http://groups.google.com/group/bertrand-constraint. See Wm Leler:
    Constraint Programming Languages: Their Specification and Generation.
    Addison-Wesley, 1988.

.. _GNU Multiprecision Library:
.. _GMP:

GNU Multiprecision Library
    Free library for arbitrary precision arithmetic, http://gmplib.org.

.. _GNU Octave:
.. _Octave:

GNU Octave
    A popular high-level language for numeric applications and free MATLAB
    replacement, http://www.gnu.org/software/octave.

.. _GNU Scientific Library:
.. _GSL:

GNU Scientific Library
    A free software library for numeric applications, can be used with Pure's
    numeric matrices, http://www.gnu.org/software/gsl.

.. _Haskell:

Haskell
    A popular non-strict FPL, http://www.haskell.org.

.. _LLVM:

LLVM
    The LLVM code generator framework, http://llvm.org.

.. _ML:

ML
    A popular strict FPL. See Robin Milner, Mads Tofte, Robert Harper,
    D. MacQueen: The Definition of Standard ML (Revised). MIT Press, 1997.

.. _Pure:

Pure
    Find the latest releases and the mailing list at the Pure website,
    http://pure-lang.googlecode.com.

.. _Q:

Q
    Another term rewriting language by yours truly, http://q-lang.sf.net.
